<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SHACL Advanced Features</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async="async" class='remove'></script>
    <script src="https://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>
    <!-- link rel="stylesheet" type="text/css" href="local.css" / -->
    <script class='remove'>
	
			var prepareSyntaxRules = function() {
				$("[data-syntax-rule]").each(function(index, element) {
					var ruleId = $(element).attr("data-syntax-rule");
					var tr = $("<tr class=\"syntax-rule-tr\"><td class=\#syntax-rule-id\"><a class=\"syntax-rule-id-a\" href=\"#syntax-rule-" + ruleId + "\">" + ruleId + "</a></td><td>" + $(element).html() + "</td></tr>");
					tr.find("dfn").replaceWith(function(el) { return $("<a>" + $(this).text() + "</a>"); });
					$("#syntax-rules-table").append(tr);
					$(element).attr("id", "syntax-rule-" + ruleId);
				});
			};
	
      var respecConfig = {
      specStatus: "ED",
	  preProcess : [ prepareSyntaxRules ],
      edDraftURI: "http://w3c.github.io/data-shapes/shacl-asf/",
      shortName:  "shacl-asf",
      editors: [
		{
			name:       "Holger Knublauch",
			url:        "http://knublauch.com/",
			company:    "TopQuadrant, Inc.",
			companyURL: "http://topquadrant.com/",
			w3cid:      46500
		},
		{
			name:       "Dean Allemang",
			url:        "http://workingontologist.com",
			company:    "Working Ontologist LLC.",
			companyURL: "http://workingontologist.com"
		},
		{   
			name:       "Simon Steyskal",
         	url:        "http://steyskal.info/",
         	company:    "WU Vienna/Siemens AG",
         	w3cid: 	73545 
		}
      ],
      wg:           "RDF Data Shapes Working Group",
      wgURI:        "https://www.w3.org/2014/data-shapes",
      wgPublicList: "public-rdf-shapes",
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
	  noHighlightCSS: true
      };
    </script>
		<!-- <script src="https://www.w3.org/scripts/jquery/2.1/jquery.min.js"></script>  -->
 		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
				word-wrap: normal;
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
			}
			
			.def-sparql {
			}
			
			.def-sparql-body {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.diagram-class {
				border: 1px solid black; 
				border-radius: 4px; 
				width: 360px;
			}
			
			.diagram-class-name {
				font-size: 16px; 
				font-weight: bold; 
				text-align: center;
			}
			
			.diagram-class-properties {
				border-top: 1px solid black; 
			}
			
			.diagram-class-properties-start {
				padding: 8px;
			}
			
			.diagram-class-properties-section {
				border-top: 1px dashed #808080;
				padding: 8px;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}

			.target-can-be-skipped {
				color: darkslategray;
				font-style: italic;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
			
			.syntax {
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #d0d0d0;
				margin-bottom: 16px;
				padding: .5em 1em;
				background-color: #f6f6f6;
			}
			
			.syntax-rule-id {
				padding-right: 10px;
			}
			
			.syntax-rule-id-a {
				white-space: nowrap;
			}
			
			.validator-id-a {
				font-weight: bold;
				white-space: nowrap;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results, pre.example-other { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; white-space: pre !important; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before, pre.example-other:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 13em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 13em; }
			pre.example-results:before { color: #797; content: "Example validation results"; width: 13em; }
			pre.example-other { background: #bed; }
			pre.example-other, pre.example-other:before { border: 1px solid #ddd; }
			pre.example-other:before { color: #888; content: "Example"; width: 13em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #cca; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
  </head>
  <body>

		<section id='abstract'>
			This document describes extensions to SHACL [[!shacl]] including features to
			define custom targets, user-defined functions, node expressions and rules.
			While many of these features rely on SPARQL, they also define extension points
			that can be used by other languages.
		</section>

		<section id='sotd'>
			<p>
				It is a draft document and its contents are subject to change without notice.
			</p>
		</section>
				
		<section class="introductory">
			<h2>Document Conventions</h2>
			<p>
				Some examples in this document use Turtle [[!turtle]].
				The reader is expected to be familiar with SHACL [[!shacl]] and [[!sparql11-query]].
			</p>
			<p>
				Within this document, the following namespace prefix bindings are used:
			</p>
			<table class="term-table">
				<tr>
					<th>Prefix</th>
					<th>Namespace</th>
				</tr>
				<tr>
					<td><code>rdf:</code></td>
					<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
				</tr>
				<tr>
					<td><code>rdfs:</code></td>
					<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
				</tr>
				<tr>
					<td><code>sh:</code></td>
					<td><code>http://www.w3.org/ns/shacl#</code></td>
				</tr>
				<tr>
					<td><code>xsd:</code></td>
					<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
				</tr>
				<tr>
					<td><code>ex:</code></td>
					<td><code>http://example.com/ns#</code></td>
				</tr>
			</table>
			<p>
				Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
				These fragments of Turtle documents use the prefix bindings given above.
			</p>
			<pre class="example-shapes">
# This box represents a shapes graph
&lt;s&gt; &lt;p&gt; &lt;o&gt; .</pre>

			<pre class="example-js">
// This box contains JavaScript code</pre>

			<pre class="example-data">
# This box represents a data graph.</pre>

			<pre class="example-results">
# This box represents an output results graph</pre>

			<p>
				Formal definitions appear in blue boxes:
			</p>
			<div class="def def-sparql">
				<div class="def-header">TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains textual definitions. </pre>
			</div>
				
			<p class="syntax">
				Grey boxes such as this include syntax rules that apply to the shapes graph.
			</p>
				
			<p>
				<code>true</code> denotes the RDF term <code>"true"^^xsd:boolean</code>.
				<code>false</code> denotes the RDF term <code>"false"^^xsd:boolean</code>.
			</p>
		</section>
		
		<section class="introductory">
			<h2>Terminology</h2>
			<p>
				The terminology used throughout this document is consistent with the definitions in the
				main SHACL [[!shacl]] specification, which references terms from RDF [[!rdf11-concepts]].
				This includes the terms
				<dfn data-lt="bindings"><a href="https://www.w3.org/TR/shacl/#dfn-binding">binding</a></dfn>,
				<dfn data-lt="blank nodes"><a href="https://www.w3.org/TR/shacl/#dfn-blank-node">blank node</a></dfn>,
				<dfn data-lt="conform|conforms"><a href="https://www.w3.org/TR/shacl/#dfn-conforms">conformance</a></dfn>,
				<dfn data-lt="constraints"><a href="https://www.w3.org/TR/shacl/#dfn-constraint">constraint</a></dfn>,
				<dfn data-lt="constraint components"><a href="https://www.w3.org/TR/shacl/#dfn-constraint-component">constraint component</a></dfn>,
				<dfn data-lt="data graphs"><a href="https://www.w3.org/TR/shacl/#dfn-data-graph">data graph</a></dfn>,
				<dfn data-lt="datatypes"><a href="https://www.w3.org/TR/shacl/#dfn-datatype">datatype</a></dfn>,
				<dfn data-lt="failures"><a href="https://www.w3.org/TR/shacl/#dfn-failure">failure</a></dfn>,
				<dfn data-lt="focus nodes"><a href="https://www.w3.org/TR/shacl/#dfn-focus-node">focus node</a></dfn>,
				<dfn data-lt="RDF graphs|graphs|graph"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-graph">RDF graph</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-ill-formed">ill-formed</a></dfn>,
				<dfn data-lt="IRIs"><a href="https://www.w3.org/TR/shacl/#dfn-iri">IRI</a></dfn>,
				<dfn data-lt="literals"><a href="https://www.w3.org/TR/shacl/#dfn-literal">literal</a></dfn>,
				<dfn data-lt="nodes|RDF node"><a href="https://www.w3.org/TR/shacl/#dfn-node">node</a></dfn>,
				<dfn data-lt="node shapes"><a href="https://www.w3.org/TR/shacl/#dfn-node-shape">node shape</a></dfn>,
				<dfn data-lt="objects"><a href="https://www.w3.org/TR/shacl/#dfn-object">object</a></dfn>,
				<dfn data-lt="parameters"><a href="https://www.w3.org/TR/shacl/#dfn-parameter">parameter</a></dfn>,
				<dfn data-lt="pre-bind|pre-bound"><a href="https://www.w3.org/TR/shacl/#pre-binding">pre-binding</a></dfn>,
				<dfn data-lt="predicates"><a href="https://www.w3.org/TR/shacl/#dfn-predicate">predicate</a></dfn>,
				<dfn data-lt="property paths"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-property-path">property path</a></dfn>,
				<dfn data-lt="property shapes"><a href="https://www.w3.org/TR/shacl/#dfn-property-shape">property shape</a></dfn>,
				<dfn data-lt="RDF terms|terms|term"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-term">RDF term</a></dfn>,
				<dfn data-lt="SHACL instances"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-instance">SHACL instance</a></dfn>,
				<dfn data-lt="SHACL subclasses"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-subclass">SHACL subclass</a></dfn>,
				<dfn data-lt="shapes"><a href="https://www.w3.org/TR/shacl/#dfn-shape">shape</a></dfn>,
				<dfn data-lt="shapes graphs"><a href="https://www.w3.org/TR/shacl/#dfn-shapes-graph">shapes graph</a></dfn>,
				<dfn data-lt="solutions"><a href="https://www.w3.org/TR/shacl/#dfn-solution">solution</a></dfn>,
				<dfn data-lt="subjects"><a href="https://www.w3.org/TR/shacl/#dfn-subject">subject</a></dfn>,
				<dfn data-lt="targets"><a href="https://www.w3.org/TR/shacl/#dfn-target">target</a></dfn>,
				<dfn data-lt="triples"><a href="https://www.w3.org/TR/shacl/#dfn-triple">triple</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-validation">validation</a></dfn>,
				<dfn data-lt="validation reports"><a href="https://www.w3.org/TR/shacl/#dfn-validation-report">validation report</a></dfn>,
				<dfn data-lt="validation results"><a href="https://www.w3.org/TR/shacl/#dfn-validation-results">validation result</a></dfn>,
				<dfn data-lt="validators"><a href="https://www.w3.org/TR/shacl/#dfn-validator">validator</a></dfn>,
				<dfn data-lt="values"><a href="https://www.w3.org/TR/shacl/#dfn-value">value</a></dfn>,
				<dfn data-lt="value nodes"><a href="https://www.w3.org/TR/shacl/#dfn-value-nodes">value node</a></dfn>.
			</p>
		</section>

		<section id="intro">
			<h2>Introduction</h2>
			<p>
				The [[!shacl]] specification is divided into SHACL Core and SHACL-SPARQL:
			</p>
			<ul>	  
				<li>
					<strong>SHACL Core</strong> consists of frequently needed features for the representation of <a>shapes</a>,
					<a>constraints</a> and <a>targets</a>.
				</li> 
				<li>
					<strong>SHACL-SPARQL</strong> consists of all features of SHACL Core plus the advanced features of
					SPARQL-based <a>constraints</a> and an extension mechanism to declare new <a>constraint components</a>.
				</li>
			</ul>
	 		<p>
	 			This document extends the functionality of SHACL by defining RDF vocabularies to cover the following features:
	 		</p>
	 		<ul>
	 			<li><a>Custom Targets</a></li>
	 			<li><a>Annotation Properties</a>
	 			<li><a>SHACL Functions</a></li>
	 			<li><a>Node Expressions</a></li>
	 			<li><a>SHACL Rules</a></li>
	 		</ul>
	 		<p>
	 			Taken together or individually, these features greatly extend the application scenarios of SHACL.
	 		</p>
	 		<p>
	 			This document is a W3C Note, not a formal W3C Specification.
	 			However, to clarify the description of intended behaviours, it does use the key words
	 			MUST, MUST NOT, REQUIRED, SHOULD, SHOULD NOT, RECOMMENDED, MAY and OPTIONAL as described in [[RFC2119]].
	 		</p>
		</section>		

		<section id="targets">
			<h2>Custom Targets</h2>
			<p>
				In general, <a>targets</a> define a mechanism that is used by SHACL engines to determine the <a>focus nodes</a>
				that should be validated against a given <a>shape</a>.
				SHACL Core [[!shacl]] defines a fixed set of Core <a>targets</a> by means of properties such as <code>sh:targetClass</code>.
				These Core targets were designed to cover a large number of use cases while retaining a simple declarative data model.
				In some use cases, these Core targets are not sufficient. For example it is impossible to state that
				a shape should apply only to a subset of instances of a class, e.g. persons born in the USA.
				Or to nodes selected by completely different mechanisms.
			</p>
			<p>
				This section defines richer mechanisms to define <a>targets</a>, called <dfn data-lt="custom target">custom targets</dfn>.
				Custom targets are declared as <a>values</a> of the property <code>sh:target</code> in the <a>shapes graph</a>.
			</p>
			<p class="syntax">
				<span data-syntax-rule="target-nodeKind">The <a>values</a> of <code>sh:target</code> at a <a>shape</a> are
				<a>IRIs</a> or <a>blank nodes</a>.</span>
			</p>
			<p>
				A SHACL engine that supports <a>custom targets</a> treats the values of <code>sh:target</code> similar
				to the values of <code>sh:targetClass</code>, and uses the <a>values</a> of the <a>custom target</a> node
				to compute the target nodes.
				The algorithm that is used for this computation depends on the <code>rdf:type</code> of the <a>custom target</a>.
				The following sub-sections define two such algorithms:
			</p>
			<ul>
				<li><a>SPARQL-based targets</a></li>
				<li><a>SPARQL-based target types</a></li>
			</ul>
			<p>
				However, other types of targets can be supported by other extension languages such as JavaScript.
				The class <code>sh:Target</code> is the recommended base class for such extensions.
			</p>
			<p>
				The behavior of a SHACL engine that is unable to handle a given <a>custom target</a> is left undefined.
				SHACL Core processors do not even need to be aware of the existence of the <code>sh:target</code> property.
				Engines that are aware of this property and cannot handle a given <a>custom target</a> SHOULD at least report a warning.
			</p>
			<section id="SPARQLTarget">
				<h3>SPARQL-based Targets (sh:SPARQLTarget)</h3>
				<p>
					<a>Custom targets</a> that are <a>SHACL instances</a> of <code>sh:SPARQLTarget</code> are called
					<dfn data-lt="SPARQL-based target">SPARQL-based targets</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLTarget-select-count"><a>SPARQL-based targets</a> have exactly one <a>value</a> for the property <code>sh:select</code>.</span>
					<span data-syntax-rule="SPARQLTarget-prefixes-nodeKind"><a>SPARQL-based targets</a> may have <a>values</a> for the property <code>sh:prefixes</code>
					and these values are <a>IRIs</a> or <a>blank nodes</a>.</span>
					<span data-syntax-rule="SPARQLTarget-select-sparql">Using the <a>values</a> of <code>sh:prefixes</code> as defined by
					<a href="https://www.w3.org/TR/shacl/#sparql-prefixes">5.2.1 Prefix Declarations for SPARQL Queries</a> of [[!shacl]],
					the <a>values</a> of <code>sh:select</code> must be valid SPARQL 1.1 SELECT queries with a single result variable <code>this</code>.</span>
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based target that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based target example">
ex:
	sh:declare [
		sh:prefix &quot;ex&quot; ;
		sh:namespace &lt;http://example.com/ns#&gt; ;
	] .
				
ex:USCitizenShape
	a sh:NodeShape ;
	sh:target [
		a sh:SPARQLTarget ;
		sh:prefixes ex: ;
		sh:select """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	...</pre>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Let <code>Q</code> be the SPARQL SELECT query derived from the <a>values</a> of <code>sh:select</code>
						and <code>sh:prefixes</code> of the <a>SPARQL-based target</a> <code>T</code>.
						The <a>target</a> nodes of <code>T</code> are the <a>bindings</a> of the variable <code>this</code> returned
						by <code>Q</code> against the <a>data graph</a>.
					</div>
				</div>
				<p>
					While the SELECT queries can be used to identify all focus nodes for a given shape, SHACL processors sometimes
					also need to compute the inverse direction and find all shapes for which a given node needs to be validated against.
					For this reason, the following semantic restriction is recommended for SELECT queries used in SPARQL-based targets.
					Informally, SHACL Full processors can derive an equivalent ASK query from the SELECT query, pre-bind the potential focus node,
					and check whether the potential focus node needs to be validated against the shape that has the given target.
					Formally, let <code>A</code> be a SPARQL ASK query that is produced by replacing the <a href="https://www.w3.org/TR/sparql11-query/#rSelectClause">SelectClause</a>
					with <code>ASK</code> in the outermost SELECT query.
					Let <code>rs</code> be the set of RDF terms returned as <a>bindings</a> for the variable <code>this</code> in the <a>solutions</a> of the SELECT query.
					Then <code>A</code> returns <code>true</code> if and only if the variable <code>this</code> is <a>pre-bound</a> with a value from <code>rs</code>.
					SHACL processors MAY produce a <a>failure</a> if this rule is violated.
				</p>
			</section>
			<section id="SPARQLTargetType">
				<h3>SPARQL-based Target Types</h3>
				<p>
					The class <code>sh:TargetType</code> can be used to declare high-level vocabularies for targets in a <a>shapes graph</a>.
					The class <code>sh:SPARQLTargetType</code> is declared as <code>rdfs:subClassOf sh:TargetType</code> for
					<dfn>SPARQL-based target types</dfn>.  
					Other extension languages may define alternative execution instructions for target types with the same IRI,
					making them potentially more platform independent than pure <a>SPARQL-based targets</a>.
					Instances of the class <code>sh:SPARQLTargetType</code> specify a SPARQL SELECT query via the property <code>sh:select</code>,
					and this query has to fulfill the same syntactic and semantic rules as <a href="#SPARQLTarget">SPARQL-based Targets</a>.
				</p>
				<p>
					Similar to SPARQL-based <a>constraint components</a>, such targets take <a>parameters</a> and
					the parameter values become <a>pre-bound</a> variables in the associated SPARQL queries.
					The parameter values of such targets cannot not be blank nodes, and the same target has no more than one value per parameter.
					Similar to SPARQL-based <a>constraint components</a>, target types may also have values for the property <a href="#labelTemplate"><code>sh:labelTemplate</code></a>.
				</p>
				<p>
					The following example declares a new SPARQL-based target type that takes one parameter <code>ex:country</code>
					that gets mapped into the variable <code>country</code> in the corresponding SPARQL query to determine the resulting target nodes.
				</p>
				<pre class="example-shapes" title="Parameterized target example">
ex:PeopleBornInCountryTarget
	a sh:SPARQLTargetType ;
	rdfs:subClassOf sh:Target ;
	sh:labelTemplate "All persons born in {$country}" ;
	sh:parameter [
		sh:path ex:country ;
		sh:name "country" ;
		sh:description "The country that the focus nodes are 'born' in." ;
		sh:class ex:Country ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:prefixes ex: ;
	sh:select """
		SELECT ?this
		WHERE {
			?this a ex:Person .
			?this ex:bornIn $country .
		}
		""" .

ex:USCitizenShape
	a sh:NodeShape ;
	sh:target [
		a ex:BornInCountryTarget ;
		ex:country ex:USA ;
	] ;
	...</pre>
				<p>
					The set of focus nodes produced by such a target type consists of all bindings of the variable <code>this</code> in the result set,
					when the SPARQL SELECT query has been executed with the pre-bound parameter values.
				</p>
			</section>
		</section>
		
		<section id="sparql-constraints-annotations">
			<h2>Injecting Annotation Properties into Validation Results</h2>
			<p>
				This section extends the general <a href="https://www.w3.org/TR/shacl/#sparql-constraints-variables">mechanism from SHACL-SPARQL</a>
				[[!shacl]] to produce <a>validation reports</a> as a result of the <a>validation</a>.
			</p>
			<p>
				It is possible to inject so-called <dfn>annotation properties</dfn> into the validation result nodes created for each <a>solution</a> of the SELECT result sets.
				Any such property needs to be declared via a <a>value</a> of <code>sh:resultAnnotation</code> at the <a>subject</a> of the <code>sh:select</code> or <code>sh:ask</code> <a>triple</a>.
				<span data-syntax-rule="resultAnnotation-nodeKind">The values of <code>sh:resultAnnotation</code> are either <a>IRIs</a> or <a>blank nodes</a></span> with the following properties.
				In this table, the <em>Value type</em> column states the required SHACL class or datatype of the property values,
				and the <em>Count</em> column indicates the minimum and maximum number of values that the properties may have.
				If these value types and counts are violated then the shapes graph is invalid.
			</p>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Value type</th>
					<th>Count</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><code>sh:annotationProperty</code></td>
					<td><code>rdf:Property</code></td>
					<td><code>1&nbsp;(mandatory)</code></td>
					<td>The annotation property that shall be set</td>
				</tr>
				<tr>
					<td><code>sh:annotationVarName</code></td>
					<td><code>xsd:string</code></td>
					<td><code>0..1</code></td>
					<td>The name of the SPARQL variable to take the values from</td>
				</tr>
				<tr>
					<td><code>sh:annotationValue</code></td>
					<td></td>
					<td><code>0..unlimited</code></td>
					<td>Constant RDF terms that shall be used as default values</td>
				</tr>
			</table>
			<p>
				For each <a>solution</a> of a SELECT result set, a SHACL processor that supports annotations
				walks through the declared result annotations.
				The mapping from result annotations to SPARQL variables uses the following rules:
			</p>
			<ol>
				<li>If a <code>sh:resultAnnotation</code> has a <a>value</a> for the property <code>sh:annotationVarName</code> then the SHACL-SPARQL processor MUST look for the variable with the same name as the value of <code>sh:annotationVarName</code></li>
				<li>Otherwise, the SHACL-SPARQL processor MUST use the local name of the value of <code>sh:annotationProperty</code> as the variable name</li>
			</ol>
			<p>
				If a variable name could be determined, then the SHACL processor copies the binding for the given variable
				as a value for the property specified using <code>sh:annotationProperty</code> 
				into the validation result that is being produced for the current <a>solution</a>.
				If the variable has no binding in the result set <a>solution</a>, then the value of <code>sh:annotationValue</code> MUST be used, if present.
			</p>
			<p>
				Here is a slightly complex example, illustrating the use of result annotations.
			</p>
			<pre class="example-shapes">
ex:ShapeWithPathViolationExample
	a sh:NodeShape ;
	sh:targetNode ex:ExampleRootResource ;
	sh:sparql [
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:select """
			SELECT $this (ex:property1 AS ?path) (?first AS ?value) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>

			<pre class="example-data">
ex:ExampleRootResource
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
			<p>
				Validation produces the following validation result nodes:
			</p>
			<pre class="example-results">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:ExampleRootResource ;
		sh:resultPath ex:property1 ;
		sh:value ex:ExampleIntermediateResource ;
		sh:resultMessage "The message." ;
		sh:sourceConstraint [ the blank node of the sh:sparql above ] ;
		sh:sourceConstraintComponent sh:SPARQLConstraintComponent ;
		sh:sourceShape ex:ShapeWithPathViolationExample ;
		ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
	]
] .</pre>
		</section>
		
		<section id="functions">
			<h2>SHACL Functions</h2>
			<p>
				<dfn data-lt="function|functions|SHACL function">SHACL functions</dfn> declare operations that produce an <a>RDF term</a>
				based on zero or more <a>parameters</a> and a <a>data graph</a>.
				Each SHACL function has an <a>IRI</a>.
				The actual execution logic (or algorithm) of a SHACL function can be declared in a variety of execution languages,
				so that the same function <a>IRI</a> can potentially be executed on a multitude of platforms.
				This document defines one specific kind of SHACL functions, the <a>SPARQL-based functions</a>.
				<a href="http://w3c.github.io/data-shapes/shacl-js/#js-functions">JavaScript-based Functions</a> are defined in the
				separate <a href="http://w3c.github.io/data-shapes/shacl-js/">SHACL-JS</a> document.
			</p>
			<p>
				SHACL functions can be called within FILTER or BIND clauses of SPARQL queries.
				SHACL functions can also be used declaratively in frameworks such as the SHACL <a>node expressions</a>
				which are used in <a>SHACL rules</a>.
			</p>
			<section id="functions-example">
				<h3>An Example SPARQL-based Function</h3>
				<p>
					The following example illustrates the declaration of a SHACL function based on a simple mathematical SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:multiply
	a sh:SPARQLFunction ;
	rdfs:comment "Multiplies its two parameters $op1 and $op2." ;
	sh:parameter [
		sh:path ex:op1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:parameter [
		sh:path ex:op2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:returnType xsd:integer ;
	sh:select """
		SELECT ($op1 * $op2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Using the declaration above, SPARQL engines that support SHACL functions install a new SPARQL function based on the
					SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:multiply(7, 8)</code>, producing <code>56</code>,
					as illustrated in the following SPARQL query.
				</p>
				<pre class="example-other" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject ?area
WHERE {
	?subject ex:width ?width .
	?subject ex:height ?height .
	BIND (ex:multiply(?width, ?height) AS ?area) .
}</pre>
				<p>
					The following sections introduce the general properties that such functions may have,
					before the specific characteristics of <a>SPARQL-based functions</a> are defined.
				</p>
			</section>
			<section id="function-parameters">
				<h3>Function Parameters</h3>
				<p>
					The parameters of a <a>SHACL function</a> are declared using the property <code>sh:parameter</code>.
					This corresponds closely to the <a href="https://www.w3.org/TR/shacl/#constraint-components-parameters">parameter
					declarations of SPARQL-based constraint components</a>, and the same syntax rules apply.
				</p>
				<p id="parameters-ordering">
					Parameters are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?param1, ?param2)</code>.
					The ordering of function parameters is determined as follows:
				</p>
				<ol>
					<li>parameters are ordered in ascending order by the parameter's numeric <a>values</a> of <code>sh:order</code>.</li>
					<li>parameters that do not declare an <code>sh:order</code> are placed after those that have.</li>
					<li>parameters that do not declare an <code>sh:order</code> are ordered in ascending order of the local names of their declared <code>sh:path</code> values.</li>
				</ol>
				<p>
					Each parameter may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an <a>RDF term</a>.
				</p>
			</section>
			<section id="SPARQLFunction">
				<h3>SPARQL-based Functions</h3>
				<p>
					<a>SHACL instances</a> of <code>sh:SPARQLFunction</code> that are <a>IRIs</a> are called <dfn>SPARQL-based functions</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLFunction-query"><a>SPARQL-based functions</a> have exactly one <a>value</a> for either <code>sh:ask</code> or <code>sh:select</code>.
					The <a>values</a> of these properties are strings that can be parsed into SPARQL queries of type ASK (for <code>sh:ask</code>)
					or SELECT (for <code>sh:select</code>), using the SHACL-SPARQL <a href="https://www.w3.org/TR/shacl/#sparql-prefixes">prefix declaration mechanism</a>.
					SELECT queries return exactly one result variable and should not use the <code>SELECT *</code> syntax.</span>
				</p>
				<p>
					When the function is executed, the SPARQL processor needs to <a>pre-bind</a> variables based on the provided parameters
					of the function call.
					In the <a href="#functions-example">SHACL functions example</a> above, the value for the parameter declared as
					<code>ex:op1</code> is <a>pre-bound</a> to the variable <code>$op1</code>, etc.
					For ASK queries, the function's return value is the result of the ASK query execution, i.e. <code>true</code> or <code>false</code>.
					For SELECT queries, the function's return value is the <a>binding</a> of the (single) result variable of the first <a>solution</a> in the result set.
					Since all other bindings will be ignored, such SELECT queries should only return at most one <a>solution</a>.
					If the result variable is unbound, then the function generates a <a href="https://www.w3.org/TR/sparql11-query/#invocation">SPARQL error</a>.
				</p>
			</section>
		</section>
		
		<section id="node-expressions">
			<h2>Node Expressions</h2>
			<p>
				This section defines a feature called <dfn data-lt="node expression">node expressions</dfn>.
				Node expressions are declared as RDF nodes in a <a>shapes graph</a> and instruct a SHACL engine
				on how to compute a set of <a>nodes</a>.
				Each <a>node expression</a> is declared as a <a>node</a> and has one of the following types,
				each of which is defined together with its evaluation semantics in the following sub-sections.
			</p>
			<table class="term-table">
				<tr>
					<th>Node Expression Type</th>
					<th>Syntax</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><a>Focus Node Expression</a></td>
					<td><code>sh:this</code></td>
					<td>The set consisting of the current <a>focus node</a>.</td>
				</tr>
				<tr>
					<td><a>Constant Term Expression</a></td>
					<td>Any <a>IRI</a> or <a>literal</a> except <code>sh:this</code></td>
					<td>The set consisting of the given <a>term</a>.</td>
				</tr>
				<tr>
					<td><a>Function Expression</a></td>
					<td><a>Blank node</a> with a list-valued triple</td>
					<td>The results of evaluating a given <a>SHACL Function</a>.</td>
				</tr>
				<tr>
					<td><a>Path Expression</a></td>
					<td><a>Blank node</a> with <code>sh:path</code></td>
					<td>The <a>value nodes</a> for a given <a>property path</a>.</td>
				</tr>
				<tr>
					<td><a>Filter Shape Expression</a></td>
					<td><a>Blank node</a> with <code>sh:filterShape</code> and <code>sh:nodes</code></td>
					<td>The sub-set of the input nodes that conform to a given <a>shape</a>.</td>
				</tr>
				<tr>
					<td><a>Intersection Expression</a></td>
					<td><a>Blank node</a> with <code>sh:intersection</code></td>
					<td>The intersection of two or more input sets.</td>
				</tr>
				<tr>
					<td><a>Union Expression</a></td>
					<td><a>Blank node</a> with <code>sh:union</code></td>
					<td>The union set of two or more input sets.</td>
				</tr>
			</table>
			<p>
				The basic idea of these expressions is that they can be used to derive a set of RDF nodes from
				a given <a>focus node</a>, for example the set of all values of a given property of the focus node.
				Some of these expressions can be nested, i.e. they use the output of another expression as their input,
				leading to evaluation chains and trees.
			</p>
			<p>
				The following example declares a <a>node expression</a> that produces the display labels of all values of
				the property <code>ex:customer</code> that <a>conform</a> to a given <a>shape</a> <code>ex:GoodCustomerShape</code>.
				The assumption here is that there is a <a>SHACL function</a> <code>ex:displayLabel</code> which declares a
				single parameter.
			</p>
			<pre class="example-shapes" title="Node expression example">
[
	ex:displayLabel ( [
		sh:filterShape ex:GoodCustomerShape ;
		sh:nodes [ sh:path ex:customer ] ;
	] )
] .</pre>
			<p>
				To execute this example, an engine gets all <a>values</a> of <code>ex:customer</code> of the <a>focus node</a>, then filters
				them according to the <a>shape</a> <code>ex:GoodCustomerShape</code> and repeatedly calls the <a>SHACL function</a>
				<code>ex:displayLabel</code> with all values that pass the filter shape as parameters.
			</p>
			<p>
				Important use cases of such expressions are <a>filter constraints</a> and <a>SHACL rules</a>,
				yet the basic functionality and vocabulary may find many other use cases.
			</p>
			<p>
				Each of the following sub-sections defines a node expression type with its syntax rules 
				and evaluation semantics based on a mapping operation <code>Eval($expr, $this)</code> where the
				first argument <code>$expr</code> is the given expression, <code>$this</code> is the current <a>focus node</a>
				and which produces a set of RDF nodes.
			</p>
			<section id="node-expressions-focus">
				<h3>Focus Node Expressions</h3>
				<p>
					The <a>IRI</a> <code>sh:this</code> is the (only) node declaring a <dfn>focus node expression</dfn>.
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FOCUS NODE EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>focus node expression</a> <code>sh:this</code>, <code>Eval(sh:this, $this)</code> produces
						the set <code>{ $this }</code>.
					</div>
				</div>
			</section>
			<section id="node-expressions-constant">
				<h3>Constant Term Expressions</h3>
				<p>
					Any <a>literal</a> or <a>IRI</a> except <code>sh:this</code> declares a <dfn>constant term expression</dfn>.
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF CONSTANT TERM EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>constant term expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set <code>{ $expr }</code>.
					</div>
				</div>
			</section>
			<section id="node-expressions-filter-shape">
				<h3>Filter Shape Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="FilterShapeExpression">A <dfn>Filter Shape Expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> of <code>sh:filterShape</code> (which is a well-formed <a>shape</a>)
					and exactly one <a>value</a> of <code>sh:nodes</code> (which is a well-formed <a>node expression</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FILTER SHAPE EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>filter shape expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set of nodes for each <a>node</a> <code>?node</code>
						produced by evaluating the <a>node expression</a> declared using <code>sh:nodes</code> at <code>$expr</code>
						where <code>?node</code> <a>conforms</a> to the <a>shape</a> declared using <code>sh:filterShape</code> at <code>$expr</code>.
					</div>
				</div>
			</section>
			<section id="node-expressions-function">
				<h3>Function Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="FunctionExpression">A <dfn>Function Expression</dfn> is a <a>blank node</a>
					that does not fulfill any of the syntax rules of the other node expression types and which
					has exactly one <a>triple</a> where the <a>object</a> is a well-formed RDF list,
					and each member of that list is a well-formed <a>node expression</a>.</span>
					Let <code>T</code> be that triple.
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FUNCTION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>function expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set of nodes returned by evaluating the <a>SHACL function</a> specified as <a>predicate</a>
						of the triple <code>T</code> mentioned above.
						The arguments of the function call(s) are based on the results of the <a>node expressions</a> listed
						in the <a>object</a> of <code>T</code>.
						This is done for all combinations of nodes, unless there is no value for a non-optional parameter of the SHACL function.
					</div>
				</div>
			</section>
			<section id="node-expressions-path">
				<h3>Path Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="PathExpression">A <dfn>Path Expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> of the property <code>sh:path</code> (which are well-formed <a>property paths</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF PATH EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>path expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set of <a>value nodes</a> of the <a>focus node</a> <code>$this</code> for the <a>property path</a>
						specified using <code>sh:path</code> at <code>$expr</code>.
					</div>
				</div>
			</section>
			<section id="intersection">
				<h3>Intersection Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="intersection">An <dfn>Intersection Expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:intersection</code> which is a well-formed RDF list
					with at least two members (which are well-formed node expressions).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF INTERSECTION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>intersection expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set of nodes that are in the results of all of the <a>node expressions</a> declared
						as members of the <a>value</a> of <code>sh:intersection</code> at <code>$expr</code>.
					</div>
				</div>
			</section>
			<section id="union">
				<h3>Union Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="union">A <dfn>Union Expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:union</code> which is a well-formed RDF list
					with at least two members (which are well-formed node expressions).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF UNION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>union expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set of nodes that are in the results of all of the <a>node expressions</a> declared
						as members of the <a>value</a> of <code>sh:union</code> at <code>$expr</code>.
					</div>
				</div>
			</section>
		</section>
		
		<section id="ExpressionConstraintComponent">
			<h2>Expression Constraints</h2>
			<p>
				Based on <a>node expressions</a>, this section introduces a <a>constraint component</a> called
				<dfn data-lt="expression constraint">expression constraints</dfn>.
				Expression constraints can be used in any <a>shape</a> to declare the condition that the
				<a>node expression</a> specified via <code>sh:expression</code> has <code>true</code> as its (only) result.
				In the evaluation of these node expressions, the current <a>value node</a> of the <a>shape</a>
				becomes the <a>focus node</a>.
			</p>
			<p>
				<span class="component-class">Constraint Component IRI</span>: <code>sh:ExpressionConstraintComponent</code>
			</p>

			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary and Syntax Rules</th>
				</tr>
				<tr>
					<td><code>sh:expression</code></td>
					<td>
						The <a>node expression</a> that must return <a>true</a>.
						<span data-syntax-rule="expression-scope">The <a>values</a> of <code>sh:expression</code> at a
						<a>shape</a> must be well-formed <a>node expressions</a>.</span>
					</td>
				</tr>
			</table>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body" data-validator="Filter">
					For each <a>value node</a> <code>?value</code> where <code>Eval(?value, $expression)</code>
					returns a node set that is not equal to <code>{ true }</code>
					there is a <a>validation result</a> that has <code>?value</code> as its <code>sh:value</code>
					and <code>$expression</code> as its <code>sh:sourceConstraint</code>.
					If the <code>$expression</code> has <a>values</a> for <code>sh:message</code> in the <a>shapes graph</a>
					then these <a>values</a> become the (only) values for <code>sh:resultMessage</code> in the
					<a>validation result</a>.
				</div>
			</div>
			<p><em>The remainder of this section is informative.</em></p>
			<p>
				The following example assumes that there is are <a>SHACL functions</a> <code>ex:concat</code>,
				<code>ex:strlen</code> and <code>ex:lessThan</code> and uses them to verify that the
				combined string length of <code>ex:firstName</code> and <code>ex:lastName</code> is less than 30.
			</p>
			<pre class="example-shapes">
ex:FilterExampleShape
	a sh:NodeShape ;
	sh:expression [
		ex:lessThan ( 
			[ ex:strlen ( 
				[ ex:concat ( [ sh:path ex:firstName] [ sh:path ex:lastName ] ) ] ) 
			]
			30 );
	] .</pre>
		</section>

		<section id="rules">
			<h2>SHACL Rules</h2>
			<p>
				SHACL defines an RDF vocabulary to describe <a>shapes</a> - collections of <a>constraints</a> that apply to a set of nodes.
				Shapes can be associated with nodes using a flexible <a>target</a> mechanism, e.g. for all members of a class.
				One focus area of SHACL is data validation.
				However, the same principles of describing data patterns in shapes can also be exploited for other purposes.
				<em>SHACL rules</em> build on SHACL to form a light-weight RDF vocabulary for the exchange of <a>rules</a> that can be used
				to derive <a>inferred</a> RDF <a>triples</a> from existing <em>asserted</em> <a>triples</a>.
			</p>
			<p>
				The <a>SHACL rules</a> feature defined in this section includes a general framework using the properties
				such as <code>sh:rule</code> and <code>sh:condition</code>, plus an extension mechanism for specific <a>rule types</a>.
				This document defines two such rule types:
				<a>Triple rules</a> and <a>SPARQL rules</a>.
				Other documents, including <a href="http://w3c.github.io/data-shapes/shacl-js/">SHACL JavaScript Extensions</a>,
				define additional types of rules.
			</p>
			
			<section id="rules-example-classification" class="informative">
				<h3>An Example Triple Rule</h3>
				<p>
					This section illustrates the use of a <a>triple rule</a> that adds an <code>rdf:type</code>
					<a>triple</a> so that those <a>SHACL instances</a> of <code>ex:Rectangle</code> where the
					<code>ex:width</code> equals the <code>ex:height</code> are also marked to be instances of <code>ex:Square</code>.
					The rule applies only to well-formed rectangles that conform to the <code>ex:Rectangle</code> <a>shape</a>,
					e.g. by having exactly one width and height, both integers.
				</p>
				<pre class="example-shapes" title="A rule to classify certain rectangles as squares">
ex:Rectangle
	a rdfs:Class, sh:NodeShape ;
	rdfs:label "Rectangle" ;
	sh:property [
		sh:path ex:height ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
		sh:minCount 1 ;
		sh:name "height" ;
	] ;
	sh:property [
		sh:path ex:width ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
		sh:minCount 1 ;
		sh:name "width" ;
	] ;
	sh:rule [
		a sh:TripleRule ;
		sh:subject sh:this ;
		sh:predicate rdf:type ;
		sh:object ex:Square ;
		sh:condition ex:Rectangle ;
		sh:condition [
			sh:property [
				sh:path ex:width ;
				sh:equals ex:height ;
			] ;
		] ;
	] .</pre>
				<pre class="example-data">
ex:InvalidRectangle
	a ex:Rectangle .

ex:NonSquareRectangle
	a ex:Rectangle ;
	ex:height 2 ;
	ex:width 3 .
	
ex:SquareRectangle
	a ex:Rectangle ;
	ex:height 4 ;
	ex:width 4 .</pre>
				<p>
					For the <a>data graph</a> above, a SHACL rules engine will produce the following inferred triples:
				</p>
				<pre class="example-inferences">	ex:SquareRectangle rdf:type ex:Square .</pre>
				<p>
					No inferences will be made for <code>ex:NonSquareRectangle</code> because its width is not equal to
					its height.
					No inferences will be made for <code>ex:InvalidRectangle</code> because although it has equal width
					and height (namely none), it does not pass the <code>sh:condition</code> of being a well-formed rectangle.
				</p>
			</section>
			
			<section id="rules-example-sparql" class="informative">
				<h3>An Example SPARQL Rule</h3>
				<p>
					The following example illustrates a simple use case of a <a>SPARQL rule</a> that applies to all instances of a class <code>ex:Rectangle</code>
					and computes the values of the <code>ex:area</code> property by multiplying the rectangle's width and height:
				</p>
				<pre class="example-shapes" title="A rule to compute the area of a Rectangle">
ex:RectangleShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:property [
		sh:path ex:width ;
		sh:datatype xsd:integer ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:path ex:height ;
		sh:datatype xsd:integer ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:RectangleRulesShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:rule [
		a sh:SPARQLRule ;
		sh:prefixes ex: ;
		sh:construct """
			CONSTRUCT {
				$this ex:area ?area .
			}
			WHERE {
				$this ex:width ?width .
				$this ex:height ?height .
				BIND (?width * ?height AS ?area) .
			}
			""" ;
		sh:condition ex:RectangleShape ;    # Rule only applies to Rectangles that conform to ex:RectangleShape
	] ;
.</pre>
				<p>
					An engine that is capable of executing such rules would use the <a>target</a> statements associated
					with the <a>shapes</a> in the <a>shapes graph</a> to determine which rules need to be executed on which target nodes.
					For those target nodes that conform to any <a href="#condition">condition shapes</a>, it would execute the provided CONSTRUCT queries to produce the inferred triples.
					During the execution of the query, the variable <code>this</code> would have the current <a>focus node</a> as pre-bound variable.
					For the following <a>data graph</a>, the <a>triples</a> below would be produced.
				</p>
				<pre class="example-data">
ex:ExampleRectangle
	a ex:Rectangle ;
	ex:width 7 ;
	ex:height 8 .

ex:InvalidRectangle    # Lacks a value for ex:height, so sh:condition is not met
	a ex:Rectangle ;
	ex:width 7 .</pre>
				<p>
					Inferred triples:
				</p>
				<pre class="example-inferences">	ex:ExampleRectangle ex:area 56 .</pre>
				<p>
					The following variation produces the same results as the <a>SPARQL rule</a>, but
					uses a <a>Triple rule</a>.
					While not as expressive as CONSTRUCT-based rules, <a>Triple rules</a> are more declarative and
					may be executed on platforms that do not support SPARQL.
				</p>
				<pre class="example-shapes" title="A triple rule to compute the area of a Rectangle">
ex:RectangleRulesShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:rule [
		a sh:TripleRule ;
		sh:subject sh:this ;
		sh:predicate ex:area ;    # Computes the values of the ex:area property at the focus nodes
		sh:object [
			ex:multiply ( [ sh:path ex:width ] [ sh:path ex:height ] ) ;
		] ;
		sh:condition ex:RectangleShape ;    # Rule only applies to Rectangles that conform to ex:RectangleShape
	] .</pre>
			</section>
	
			<section id="rules-syntax">
				<h2>General Syntax of SHACL Rules</h2>
				<p>
					The <a>values</a> of the property <code>sh:rule</code> at a <a>shape</a> are called <dfn data-lt="rule|rules|SHACL rule">SHACL rules</dfn>.
					SHACL has a flexible design in which multiple types of rules can be supported,
					including <a>Triple rules</a> and <a>SPARQL rules</a>.
					Each <dfn data-lt="rule types">rule type</dfn> is identified by an <a>IRI</a> that is used as <code>rdf:type</code> of rules.
					Each rule type also defines <dfn>execution instructions</dfn> that can be implemented by rule engines.
				</p>
				<p class="syntax">
					<span data-syntax-rule="rule-type">Each <a>SHACL rule</a> has exactly one <code>rdf:type</code> which is a <a>IRI</a>.</span>
				</p>
				<p>
					All rules may have the properties defined in the rest of this section.
				</p>
				<section id="condition">
					<h3>sh:condition</h3>
					<p>
						A <a>rule</a> may have values for the property <code>sh:condition</code> to specify <a>shapes</a>
						that the <a>focus nodes</a> must conform to before the rule gets executed.
					</p>
					<p class="syntax">
						<span data-syntax-rule="condition-node">The <a>values</a> of <code>sh:condition</code> at a <a>rule</a> must be well-formed <a>shapes</a>.</span>
					</p>
				</section>
				<section id="rules-order">
					<h3>sh:order</h3>
					<p>
						Rules and shapes may specify its relative execution order as defined in this section.
					</p>
					<p class="syntax">
						<span data-syntax-rule="rule-order-maxCount">Each <a>rule</a> or <a>shape</a> may have at most one <a>value</a> for the
						property <code>sh:order</code>.</span>
						<span data-syntax-rule="rule-order-datatype">The values of <code>sh:order</code> at <a>rules</a> and <a>shapes</a>
						are <a>literals</a> with a <em>numeric</em> datatype such as <code>xsd:decimal</code>.</span>
					</p>
					<p>
						If unspecified, then the default order is assumed to be <code>0</code>.
						These values are used by a <a>rules engine</a> to determine the order of <a>rules</a> associated with the same <a>shape</a>.
						When the <a>rules</a> associated with a <a>shape</a> are executed, <a>rules</a> with larger values will be executed after
						those with smaller values.
					</p>
					<pre class="example-shapes" title="Rule order example">
ex:RuleOrderExampleShape
	a sh:NodeShape ;
	sh:targetClass ex:Person ;
	sh:rule [
		a sh:SPARQLRule ;
		rdfs:label "Infer uncles, i.e. male siblings of the parents of ?this" ;
		sh:prefixes ex: ;
		sh:order 1 ;   # Will be evaluated before 2
		sh:construct """
			CONSTRUCT {
				$this ex:uncle ?uncle .
			}
			WHERE {
				$this ex:parent ?parent .
				?parent ex:sibling ?uncle .
				?uncle ex:gender ex:male .
			}
			"""
	] ;
	sh:rule [
		a sh:SPARQLRule ;
		rdfs:label "Infer cousins, i.e. the children of the uncles" ;
		sh:prefixes ex: ;
		sh:order 2 ;
		sh:construct """
			CONSTRUCT {
				$this ex:cousin ?cousin .
			}
			WHERE {
				$this ex:uncle ?uncle .
				?cousin ex:parent ?uncle .
			}
			"""
	] .</pre>
				</section>
				<section id="deactivated">
					<h3>sh:deactivated</h3>
					<p>
						Rules may be <em>deactivated</em> by setting <code>sh:deactivated</code> to <code>true</code>.
						Deactivated rules are ignored by the rules engine.
					</p>
					<p class="syntax">
						<span data-syntax-rule="deactivated-maxCount">Each <a>rule</a> may have at most one <a>value</a> for the
						property <code>sh:deactivated</code>.</span>
						<span data-syntax-rule="deactivated-in">The <a>values</a> of <code>sh:deactivated</code> are either
						of the <code>xsd:boolean</code> literals <code>true</code> or <code>false</code>.</span>
					</p>
				</section>
			</section>
			<section id="Rules">
				<h3>The sh:Rules Entailment Regime</h3>
				<p>
					SHACL defines the property <a href="https://www.w3.org/TR/shacl/#shacl-rdfs"><code>sh:entailment</code></a>
					to link a <a>shapes graph</a> with <em>entailment regimes</em>.
					The <a>IRI</a> <code>sh:Rules</code> represents the SHACL rules entailment regime.
					In the following example, the shapes graph indicates to a SHACL validation engine that the SHACL rules
					inside of the <a>shapes graph</a> need to be executed prior to starting the validation.
					Engines that do <em>not</em> support the SHACL rules entailment regime are required to signal a <a>failure</a>
					if this <a>triple</a> is present.
				</p>
				<pre class="example-shapes">
&lt;http://example.org/my-shapes&gt;
	a owl:Ontology ;
	sh:entailment sh:Rules .</pre>
			</section>
			
			<section id="rules-execution">
				<h3>General Execution Instructions for SHACL Rules</h3>
				<p>
					A <dfn data-lt="rules engine">SHACL rules engine</dfn> is a computer procedure that takes as input
					a <a>data graph</a> and a <a>shapes graph</a> and is capable of adding <a>triples</a> to the <a>data graph</a>.
					The new <a>triples</a> that are produced by a rules engine are called the <dfn data-lt="inferring|infer">inferred</dfn> triples.
				</p>
				<p>
					Note that, from a logical perspective, the <a>data graph</a> will be <em>modified</em> if <a>triples</a> get inferred.
					This means that rules can trigger after other triples have been inferred.
					However, in cases where the original data should not be modified, implementations may construct a logical <a>data graph</a>
					that has the original data as one subgraph and a dedicated inferences graph as another subgraph, and where
					the inferred triples get added to the inferences graph only.
				</p>
				<p>
					In order to count as a SHACL rules engine, an implementation must be capable of <a>inferring</a> <a>triples</a>
					according to the following procedure (given in pseudo-code), or a different algorithm as long as the result
					is the same as specified.
					Informally, a rules engine executes each <a>rule</a> in the <a>shapes graph</a> until no new triples have
					been inferred by a full traversal of all <a>rules</a>.
				</p>
				<pre>
do {
	oldCount = number of triples in the data graph
	for each shape in the shapes graph, ordered by <code>sh:order</code> {
		for each non-deactivated <a>rule</a> in the shape, ordered by <a href="#rule-order">sh:order</a> {
			for each <a>target</a> node of the shape that <a>conforms</a> to all <a href="#condition">conditions</a> of the <a>rule</a>
				execute the <a>rule</a> following the <a>execution instructions</a> of the <a>rule type</a>
			}
		}
	}
	newCount = number of triples in the data graph
}
while(oldCount != newCount)</pre>
				<p>
					Note that the algorithm above may never terminate, e.g. if rules produce new <a>blank nodes</a> in each execution.
				</p>
				<p>
					If a <a>rules engine</a> is not able to execute a given <a>rule</a>
					because it does not support any of the <a>rule types</a> of the <a>rule</a>,
					then it MUST report a <a>failure</a>.
				</p>
			</section>

			<section id="TripleRule">
				<h3>Triple Rules</h3>
				<p>
					This section defines a <a>rule type</a> called <dfn data-lt="triple rule">triple rules</dfn>, identified by
					the <a>IRI</a> <code>sh:TripleRule</code>.
				<p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Summary and Syntax Rules</th>
					</tr>
					<tr>
						<td><code>sh:subject</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>subject</a> of the <a>triple</a>.
							<span data-syntax-rule="TripleRule-subject">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:subject</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:predicate</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>predicate</a> of the <a>triple</a>.
							<span data-syntax-rule="TripleRule-predicate">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:predicate</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:object</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>object</a> of the <a>triple</a>.
							<span data-syntax-rule="TripleRule-object">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:object</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
				</table>
				<div class="def def-text">
					<div class="def-header">EXECUTION OF TRIPLE RULES</div>
					<div class="def-text-body">
						Let <code>S</code>, <code>P</code> and <code>O</code> be the sets of nodes produced by evaluating
						the <a>node expressions</a> that are the values of <code>sh:subject</code>, <code>sh:predicate</code>
						and <code>sh:object</code> respectively at the <a>triple rule</a>.
						For each combination of members of <code>S</code>, <code>P</code> and <code>O</code>
						<a>infer</a> a <a>triple</a> <code>s p o</code>.
					</div>
				</div>
			</section>

			<section id="SPARQLRule">
				<h3>SPARQL Rules</h3>
				<p>
					This section defines a <a>rule type</a> called <dfn data-lt="SPARQL rule">SPARQL rules</dfn>,
					identified by the <a>IRI</a> <code>sh:SPARQLRule</code>.
				<p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Summary and Syntax Rules</th>
					</tr>
					<tr>
						<td><code>sh:construct</code></td>
						<td>
							The SPARQL CONSTRUCT query.
							<span data-syntax-rule="construct-count"><a>SPARQL rules</a> must have exactly one
							<a>value</a> for the property <code>sh:construct</code>.</span>
							<span data-syntax-rule="construct-datatype">The values of <code>sh:construct</code>
							are <a>literals</a> with datatype <code>xsd:string</code>.</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:prefixes</code></td>
						<td>
							The prefixes to use to turn the <code>sh:construct</code> into a SPARQL query.
							<a>SPARQL rules</a> may use the property <code>sh:prefixes</code> to declare a dependency on prefixes based on the
							mechanism defined in <a href="https://www.w3.org/TR/shacl/#sparql-prefixes">Prefix Declarations for SPARQL Queries</a>
							from the SHACL specification [[!shacl]].
							This mechanism allows users to abbreviate URIs in the <code>sh:construct</code> strings.
						</td>
					</tr>
				</table>
				<div class="def def-text">
					<div class="def-header">EXECUTION OF SPARQL RULES</div>
					<div class="def-text-body">
						Let <code>Q</code> be the SPARQL CONSTRUCT query derived from the values of the properties
						<code>sh:construct</code> and <code>sh:prefixes</code> of the <a>SPARQL rule</a> in the <a>shapes graph</a>.
						For each <a>focus node</a>, execute the query <code>Q</code>
						<a>pre-binding</a> the variable <code>this</code> to the <a>focus node</a>,
						and <a>infer</a> the constructed <a>triples</a>.
					</div>
				</div>
			</section>
		</section>
		
		<section id="syntax-rules" class="appendix">
			<h2>Summary of Syntax Rules from this Document</h2>
			<p>
				This section enumerates all normative syntax rules from this document.
				This section is automatically generated from other parts of this spec and hyperlinks are provided back
				into the prose if the context of the rule in unclear. 
				Nodes that violate these rules in a shapes graph are ill-formed.
			</p>
			<table class="term-table" id="syntax-rules-table">
				<tr>
					<th>Syntax Rule Id</th>
					<th>Syntax Rule Text</th>
				</tr>
			</table>
		</section>
						
		<section id="security" class="appendix informative">
			<h2>Security and Privacy Considerations</h2>
			<p>
				The features defined in this document share certain security and privacy considerations with those
				<a href="https://www.w3.org/TR/shacl/#security">mentioned</a> in [[!shacl]].
				The general advice is for users to only use trusted and controlled shape graphs.
			</p>
		</section>
		
  </body>
</html>
