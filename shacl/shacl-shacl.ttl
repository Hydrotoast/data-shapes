# A SHACL shapes graph to validate SHACL shapes graphs
# Draft last edited 2017-04-01

@prefix owl:  <http://www.w3.org/2002/07/owl#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh:   <http://www.w3.org/ns/shacl#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .

@prefix shsh: <http://www.w3.org/ns/shacl-shacl#> .

shsh:
	a owl:Ontology ;
	owl:imports sh: ;
	rdfs:label "SHACL for SHACL"@en ;
	rdfs:comment "This shapes graph can be used to validate SHACL shapes graphs against a subset of the syntax rules."@en ;
	sh:declare [
		sh:prefix "shsh" ;
		sh:namespace "http://www.w3.org/ns/shacl-shacl#" ;
	] .

	
shsh:ListShape
	a sh:NodeShape ;
	rdfs:label "List shape"@en ;
	rdfs:comment "A shape describing well-formed RDF lists."@en ;
	rdfs:seeAlso <https://www.w3.org/TR/shacl/#syntax-rule-SHACL-list> ;
	# TODO
.
	

shsh:ShapeShape
	a sh:NodeShape ;
	rdfs:label "Shape shape"@en ;
	rdfs:comment "A shape that can be used to validate syntax rules for other shapes."@en ;
	
	# See https://www.w3.org/TR/shacl/#shapes for what counts as a shape
	sh:targetClass sh:NodeShape ;
	sh:targetClass sh:PropertyShape ;
	sh:targetSubjectsOf sh:targetClass, sh:targetNode, sh:targetObjectsOf, sh:targetSubjectsOf ;
	sh:targetSubjectsOf sh:and, sh:class, sh:closed, sh:datatype, sh:disjoint, sh:equals, sh:flags, sh:hasValue,
		sh:ignoredProperties, sh:in, sh:languageIn, sh:lessThan, sh:lessThanOrEquals, sh:maxCount, sh:maxExclusive,
		sh:maxInclusive, sh:maxLength, sh:minCount, sh:minExclusive, sh:minInclusive, sh:minLength, sh:node, sh:nodeKind,
		sh:not, sh:or, sh:pattern, sh:property, sh:qualifiedMaxCount, sh:qualifiedMinCount, sh:qualifiedValueShape,
		sh:qualifiedValueShape, sh:qualifiedValueShapesDisjoint, sh:qualifiedValueShapesDisjoint, sh:sparql, sh:uniqueLang, sh:xone ;
		
	sh:property [
		sh:path sh:targetNode ;
		sh:nodeKind	sh:IRIOrLiteral ;	# targetNode-nodeKind
	] ; 
	sh:property [
		sh:path sh:targetClass ;
		sh:nodeKind sh:IRI ;			# targetClass-nodeKind
	] ;
	sh:property [
		sh:path sh:targetSubjectsOf ;
		sh:nodeKind sh:IRI ;			# targetSubjectsOf-nodeKind
	] ;
	sh:property [
		sh:path sh:targetObjectsOf ;
		sh:nodeKind sh:IRI ;			# targetObjectsOf-nodeKind
	] ;
	sh:or ( [ sh:not [ 
				sh:class rdfs:Class ; 
				sh:or ( [ sh:class sh:NodeShape ] [ sh:class sh:PropertyShape ] )
			] ]
			[ sh:nodeKind sh:IRI ]
		  ) ;							# implicit-targetClass-nodeKind
	
	sh:property [
		sh:path sh:severity ;
		sh:maxCount 1 ;					# severity-maxCount
		sh:nodeKind sh:IRI ;			# severity-nodeKind
	] ;
	sh:property [
		sh:path sh:message ;
		sh:or ( [ sh:datatype xsd:string ] [ sh:datatype rdf:langString ] ) ;   # message-datatype
	] ;
	sh:property [
		sh:path sh:deactivated ;
		sh:maxCount 1 ;					# severity-maxCount
		sh:in ( true false ) ;			# severity-datatype
	] ;

	sh:property [
		sh:path sh:and ;
		sh:node shsh:ListShape ;		# and-node
	] ;
	sh:property [
		sh:path ( sh:and [ sh:zeroOrMorePath rdf:rest ] rdf:first ) ;
		sh:node shsh:ShapeShape ;		# and-members-node
	] ;
	sh:property [
		sh:path sh:class ;
		sh:nodeKind sh:IRI ;			# class-nodeKind
	] ;
	sh:property [
		sh:path sh:closed ;
		sh:datatype xsd:boolean ;		# closed-datatype
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path sh:ignoredProperties ;
		sh:node shsh:ListShape ;		# ignoredProperties-node
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path ( sh:ignoredProperties [ sh:zeroOrMorePath rdf:rest ] rdf:first ) ;
		sh:nodeKind sh:IRI ;			# ignoredProperties-members-nodeKind
	] ;
	sh:property [
		sh:path sh:datatype ;
		sh:nodeKind sh:IRI ;			# datatype-nodeKind
		sh:maxCount 1 ;					# datatype-maxCount
	] ;
	sh:property [
		sh:path sh:disjoint ;
		sh:nodeKind sh:IRI ;			# disjoint-nodeKind
	] ;
	sh:property [
		sh:path sh:equals ;
		sh:nodeKind sh:IRI ;			# equals-nodeKind
	] ;
	sh:property [
		sh:path sh:in ;
		sh:maxCount 1 ;					# in-maxCount		
		sh:node shsh:ListShape ;		# in-node
	] ;
	sh:property [
		sh:path sh:languageIn ;
		sh:maxCount 1 ;					# languageIn-maxCount
		sh:node shsh:ListShape ;		# languageIn-node
	] ;
	sh:property [
		sh:path ( sh:languageIn [ sh:zeroOrMorePath rdf:rest ] rdf:first ) ;
		sh:datatype xsd:string ;		# languageIn-members-datatype
	] ;
	sh:property [
		sh:path sh:lessThan ;
		sh:nodeKind sh:IRI ;			# lessThan-nodeKind
	] ;
	sh:property [
		sh:path sh:lessThanOrEquals ;
		sh:nodeKind sh:IRI ;			# lessThanOrEquals-nodeKind
	] ;
	sh:property [
		sh:path sh:maxCount ;
		sh:datatype xsd:integer ;		# maxCount-datatype
		sh:maxCount 1 ;					# maxCount-maxCount
	] ;
	sh:property [
		sh:path sh:maxExclusive ;
		sh:maxCount 1 ;					# maxExclusive-maxCount
		sh:nodeKind sh:Literal ;		# maxExclusive-nodeKind
	] ;
	sh:property [
		sh:path sh:maxInclusive ;
		sh:maxCount 1 ;					# maxInclusive-maxCount
		sh:nodeKind sh:Literal ;		# maxInclusive-nodeKind
	] ;
	sh:property [
		sh:path sh:maxLength ;
		sh:datatype xsd:integer ;		# maxLength-datatype
		sh:maxCount 1 ;					# maxLength-maxCount
	] ;
	sh:property [
		sh:path sh:minCount ;
		sh:datatype xsd:integer ;		# minCount-datatype
		sh:maxCount 1 ;					# minCount-maxCount
	] ;
	sh:property [
		sh:path sh:minExclusive ;
		sh:maxCount 1 ;					# minExclusive-maxCount
		sh:nodeKind sh:Literal ;		# minExclusive-nodeKind
	] ;
	sh:property [
		sh:path sh:minInclusive ;
		sh:maxCount 1 ;					# minInclusive-maxCount
		sh:nodeKind sh:Literal ;		# minInclusive-nodeKind
	] ;
	sh:property [
		sh:path sh:minLength ;
		sh:datatype xsd:integer ;		# minLength-datatype
		sh:maxCount 1 ;					# minLength-maxCount
	] ;
	sh:property [
		sh:path sh:node ;
		sh:node shsh:ShapeShape ;		# node-node
	] ;
	sh:property [
		sh:path sh:nodeKind ;
		sh:in ( sh:BlankNode sh:IRI sh:Literal sh:BlankNodeOrIRI sh:BlankNodeOrLiteral sh:IRIOrLiteral ) ;	# nodeKind-in
		sh:maxCount 1 ;					# nodeKind-maxCount
	] ;
	sh:property [
		sh:path sh:not ;
		sh:node shsh:ShapeShape ;		# not-node
	] ;
	sh:property [
		sh:path sh:or ;
		sh:node shsh:ListShape ;		# or-node
	] ;
	sh:property [
		sh:path ( sh:or [ sh:zeroOrMorePath rdf:rest ] rdf:first ) ;
		sh:node shsh:ShapeShape ;		# or-members-node
	] ;
	sh:property [
		sh:path sh:pattern ;
		sh:datatype xsd:string ;		# pattern-datatype
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path sh:flags ;
		sh:datatype xsd:string ;		# flags-datatype
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path sh:property ;
		sh:node shsh:PropertyShape ;	# property-node
	] ;
	sh:property [
		sh:path sh:qualifiedMaxCount ;
		sh:datatype xsd:integer ;		# qualifiedMaxCount-datatype
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path sh:qualifiedMinCount ;
		sh:datatype xsd:integer ;		# qualifiedMinCount-datatype
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path sh:qualifiedValueShape ;
		sh:node shsh:ShapeShape ;		# qualifiedValueShape-node
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path sh:qualifiedValueShapesDisjoint ;
		sh:datatype xsd:boolean ;		# qualifiedValueShapesDisjoint-datatype
		sh:maxCount 1 ;					# multiple-parameters
	] ;
	sh:property [
		sh:path sh:uniqueLang ;
		sh:datatype xsd:boolean ;		# uniqueLang-datatype
		sh:maxCount 1 ;					# uniqueLang-maxCount
	] ;
	sh:property [
		sh:path sh:xone ;
		sh:node shsh:ListShape ;		# xone-node
	] ;
	sh:property [
		sh:path ( sh:xone [ sh:zeroOrMorePath rdf:rest ] rdf:first ) ;
		sh:node shsh:ShapeShape ;		# xone-members-node
	] ;
.
	
shsh:NodeShapeShape
	a sh:NodeShape ;
	sh:node shsh:ShapeShape ;
	sh:property [
		sh:path sh:path ;
		sh:maxCount 0 ;					# NodeShape-path-maxCount
	] ;
	sh:property [
		sh:path sh:lessThan ;
		sh:maxCount 0 ;					# lessThan-scope
	] ;
	sh:property [
		sh:path sh:lessThanOrEquals ;
		sh:maxCount 0 ;					# lessThanOrEquals-scope
	] ;
	sh:property [
		sh:path sh:maxCount ;
		sh:maxCount 0 ;					# maxCount-scope
	] ;
	sh:property [
		sh:path sh:minCount ;
		sh:maxCount 0 ;					# minCount-scope
	] ;
	sh:property [
		sh:path sh:qualifiedValueShape ;
		sh:maxCount 0 ;					# qualifiedValueShape-scope
	] ;
	sh:property [
		sh:path sh:uniqueLang ;
		sh:maxCount 0 ;					# uniqueLang-scope
	] ;
.

shsh:PropertyShapeShape
	a sh:NodeShape ;
	sh:targetSubjectsOf sh:path ;
	sh:node shsh:ShapeShape ;
	sh:property [
		sh:path sh:path ;
		sh:maxCount 1 ;					# path-maxCount
		sh:minCount 1 ;					# PropertyShape-path-minCount
		sh:node shsh:PathShape ;		# path-node
	] ;
.

shsh:PathShape
	a sh:NodeShape ;
	rdfs:label "Path shape"@en ;
	rdfs:comment "A shape that can be used to validate the syntax rules of well-formed SHACL paths."@en ;
	rdfs:seeAlso <https://www.w3.org/TR/shacl/#property-paths> ;
	# TODO, see https://lists.w3.org/Archives/Public/public-rdf-shapes/2017Feb/0115.html for some input
.

shsh:ShapesGraphShape
	a sh:NodeShape ;
	sh:targetObjectsOf sh:shapesGraph ;
	sh:nodeKind sh:IRI ;				# shapesGraph-nodeKind
.

shsh:EntailmentShape
	a sh:NodeShape ;
	sh:targetObjectsOf sh:entailment ;
	sh:nodeKind sh:IRI ;				# entailment-nodeKind
.
