# baseURI: http://www.w3.org/ns/shacl-hk

@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix owl:     <http://www.w3.org/2002/07/owl#> .
@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:    <http://www.w3.org/2000/01/rdf-schema#> .
@prefix vs:      <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix xsd:	 <http://www.w3.org/2001/XMLSchema#> .

@prefix sh: <http://www.w3.org/ns/shacl#> .

<http://www.w3.org/ns/shacl-hk>
	a owl:Ontology ;
	rdfs:comment "Suggested additions to the SHACL RDFS vocabulary (started by Holger). All terms are 'unstable'." ;
	owl:imports <http://www.w3.org/ns/shacl#> ;
.


# Constraint types metamodel --------------------------------------------------

sh:Parameterizable
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Class ;
	rdfs:label "Parameterizable" ;
	rdfs:comment """
		Abstract superclass of components that can take parameters, especially Functions and Validators.
		Parameters are declared using instances of sh:Parameter via the property sh:parameter.
		""" ;
.

sh:parameter
	a rdf:Property ;
	rdfs:label "parameter" ;
	rdfs:comment "Links a Parameterizable with instances of sh:Parameter." ;
	rdfs:domain sh:Parameterizable ;
	rdfs:range sh:Parameter ;
.

sh:labelTemplate
	a rdf:Property ;
	rdfs:label "label template" ;
	rdfs:comment """
		Outlines how human-readable labels of instances of the associated sh:Parameterizable shall be produced.
		The values must be strings that can contain {?paramName} as placeholders for the actual values of the given parameter.
		There may be multiple values, for different languages.
		"""^^rdf:HTML ;
	rdfs:domain sh:Parameterizable ;
	# range: sh:datatypeIn ( xsd:string rdf:langString ) ;
.

sh:Parameter
	a rdfs:Class ;
	rdfs:subClassOf sh:AbstractPropertyConstraint ;
	rdfs:label "Parameter" ;
	rdfs:comment """
		Instances of this class define a parameter, together with information about allowed value type, cardinality and other characteristics.
		"""^^rdf:HTML ;
.

sh:ConstraintType
	a rdfs:Class ;
	rdfs:subClassOf sh:Parameterizable ;
	rdfs:label "Constraint type" ;
	rdfs:comment """
		The class of constraint types such as sh:PatternConstraint.
		Constraint types serve as containers to group together the properties defining the constraint,
		for example sh:pattern and sh:flags.
		These properties can be linked to the constraint type via sh:parameter.
		Constraint types can also have links to validators (e.g. in SPARQL) that can be discovered by implementations.
		"""^^rdf:HTML ;
.

sh:propertyValidator
	a rdf:Property ;
	rdfs:domain sh:ConstraintType ;
	rdfs:range sh:Validator ;
.

sh:inversePropertyValidator
	a rdf:Property ;
	rdfs:domain sh:ConstraintType ;
	rdfs:range sh:Validator ;
.

sh:nodeValidator
	a rdf:Property ;
	rdfs:domain sh:ConstraintType ;
	rdfs:range sh:Validator ;
.

sh:Validator
	a rdfs:Class ;
	rdfs:label "Validator" ;
	rdfs:comment """
		A validator provides instructions on how to process a constraint definition.
		This class sh:Validator serves as base class for sh:SPARQLValidator and other possible implementations.
		"""^^rdf:HTML ;
.

sh:SPARQLValidator
	a rdfs:Class ;
	rdfs:subClassOf sh:Validator ;
	rdfs:subClassOf sh:SPARQLExecutable ;
	rdfs:label "SPARQL validator" ;
	rdfs:comment """
		A sh:Validator based on a SPARQL query, represented using sh:sparql.
		"""^^rdf:HTML ;
.

sh:SPARQLConstraint
	a rdfs:Class ;
	rdfs:subClassOf sh:Constraint ;
	rdfs:subClassOf sh:SPARQLValidator ;
	rdfs:label "SPARQL constraint" ;
	rdfs:comment """
		A constraint based on a SPARQL query, via sh:sparql.
		Instances of this class are directly associated with a shape using sh:constraint.
		"""^^rdf:HTML ;
.


# Result Annotations ----------------------------------------------------------

sh:resultAnnotation
	a rdf:Property ;
	rdfs:label "result annotation" ;
	rdfs:comment """
		Links a SPARQL validator with zero or more sh:ResultAnnotation instances, defining how to derive additional result properties based on the variables of the SELECT query.
		"""^^rdf:HTML ;
	rdfs:domain sh:SPARQLValidator ;
	rdfs:range sh:ResultAnnotation ;
.

sh:ResultAnnotation
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Result annotation" ;
	rdfs:comment "Defines the rules to derive the values of a given annotation property as extra values for a constraint violation." ;
	rdfs:isDefinedBy sh: ;
	vs:term_status "stable" ;
.

sh:annotationProperty
	a rdf:Property ;
	rdfs:label "annotation property" ;
	rdfs:comment "The annotation property that shall be set." ;
	rdfs:domain sh:ResultAnnotation ;
	rdfs:range rdf:Property ;
.

sh:annotationValue
	a rdf:Property ;
	rdfs:label "annotation value" ;
	rdfs:comment "The values of the annotation property." ;
	rdfs:domain sh:ResultAnnotation ;
.

sh:annotationVarName
	a rdf:Property ;
	rdfs:label "annotation variable name" ;
	rdfs:comment "The name of the SPARQL variable from the SELECT clause that shall be used for the values." ;
	rdfs:domain sh:ResultAnnotation ;
	rdfs:range xsd:string ;
.


# Functions Vocabulary --------------------------------------------------------

sh:Function
	a rdfs:Class ;
	rdfs:subClassOf sh:Parameterizable ;
	rdfs:label "Function" ;
	rdfs:comment """
		An object implementing a function that may take parameters, implemented in an executable language such as SPARQL.
		"""^^rdf:HTML ;
.

sh:SPARQLFunction
	a rdfs:Class ;
	rdfs:subClassOf sh:Function ;
	rdfs:subClassOf sh:SPARQLExecutable ;
	rdfs:comment "A Function backed by a SPARQL query." ;
.

sh:NodeValidationFunction
	a rdfs:Class ;
	rdfs:subClassOf sh:Function ;
	rdfs:subClassOf sh:Validator ;
	rdfs:label "Node validation function" ;
	rdfs:comment """
		A function that can also be used as a validator.
		Such functions take an implicit parameter <code>?value</code> and must return a boolean (have ASK type in SPARQL).
		"""^^rdf:HTML ;
.

sh:NodeValidationFunctions
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Node validation functions" ;
	rdfs:comment """
		The superclass of all validation functions that take a value as its first argument and return a boolean result
		(true if the value is OK).
		"""^^rdf:HTML ;
.


# Library of standard constraint types ----------------------------------------

sh:ClassConstraint
	sh:parameter [
		sh:predicate sh:class ;
	] ;
	sh:message "Values must be instances of {?class}" ;
	sh:propertyValidator sh:hasClass ;   # sh:hasClass is a NodeValidationFunction
	sh:inversePropertyValidator sh:hasClass ;
	sh:nodeValidator sh:hasClass ;
.

sh:EqualsConstraint
	sh:argument [
		sh:predicate sh:equals ;
	] ;
	sh:message "Value sets of {?predicate} and {?equals} must be equal" ;
	sh:propertyValidator [
		a sh:SPARQLValidator ;
		sh:sparql """
			SELECT $this ($this AS ?subject) $predicate ?object
			WHERE {
				{
					$this $predicate ?object .
					FILTER NOT EXISTS {
						$this $equals ?object .
					}
				}
				UNION
				{
					$this $equals ?object .
					FILTER NOT EXISTS {
						$this $predicate ?object .
					}
				}
			}
			"""
	]
.	

# ... etc for other constraint types

sh:PropertyConstraint
	rdfs:subClassOf sh:MinCountConstraint ;
	rdfs:subClassOf sh:PatternConstraint ;
	# ... other constraint types (of sh:property)
.

sh:InversePropertyConstraint
	rdfs:subClassOf sh:MinCountConstraint ;
	# ... other constraint types (of sh:inverseProperty)
.

sh:NodeConstraint
	rdfs:subClassOf sh:PatternConstraint ;
	# ... other constraint types of sh:constraint
.


# Helper functions ------------------------------------------------------------
# Here we need to decide whether these are in the sh: namespace.
# If we are defining the sh:sparql queries then I think they should be included
# If not, and we leave the Validators undefined, then we could also leave the 
# functions out.  However then there is less code reuse possible.

sh:hasClass
	a sh:NodeValidationFunction ;
	a sh:SPARQLFunction ;
	rdfs:subClassOf sh:NodeValidationFunctions ;
	rdfs:label "has class" ;
	rdfs:comment "Checks whether a given node ($value) is an instance of a given class ($class) or its subclasses. Returns false if the value is a literal. Returns true if $class is rdfs:Resource. Returns true if $class is rdf:List and $value has a rdf:first value." ;
	sh:parameter [
		sh:order 1 ;
		sh:predicate sh:class ;
		sh:class rdfs:Class ;
		sh:description "The type that the node must have." ;
	] ;
	sh:returnType xsd:boolean ;
	sh:sparql """
		ASK {
			FILTER (isIRI($value) || isBlank($value)) .
			FILTER (
				$class = rdfs:Resource ||
				($class = rdf:List && EXISTS { $value rdf:first ?any }) ||
				EXISTS { $value rdf:type/rdfs:subClassOf* $class }
				)
		}
		""" ;
.

# ... more validation functions


# Derived Values support ------------------------------------------------------

sh:DerivedValuesConstraint
	a rdfs:Class ;   # HK: sh:ConstraintType ;
	rdfs:subClassOf sh:AbstractPropertyConstraint ;
	sh:parameter [
		sh:predicate sh:derivedValues ;
		sh:class sh:ValuesDeriver ;
		sh:name "derived values" ;
		sh:description "Points at an object that wraps an executable body (e.g. a SPARQL query) that computes all values for the given property." ;
	] ;
.

sh:derivedValues
	a rdf:Property ;
	rdfs:domain sh:DerivedValuesConstraint ;
	rdfs:range sh:ValuesDeriver ;
.

sh:ValuesDeriver
	a rdfs:Class ;
.

sh:SPARQLValuesDeriver
	a rdfs:Class ;
	rdfs:subClassOf sh:ValuesDeriver ;
	rdfs:subClassOf sh:SPARQLExecutable ;
.


# TODOs
# - How is sh:predicate inherited by constraint types - sh:NodeConstraints don't need it
