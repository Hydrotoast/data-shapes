<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset="utf-8">
		<script src="//www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "ED",
				shortName:  "shacl",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/"
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
				wgPublicList: "public-data-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status"
			};
		</script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script> 
		<script>
		
			// Have injectPartsIntoTOC called when ReSpec is done (hack using a timer)
			var inti = setInterval(function() {
				if(window.respecEvents) {
					window.respecEvents.sub("end-all", function() {
						injectPartsIntoTOC();
					});
					clearInterval(inti);
				}
			}, 100);

			// Inject sub-headers for Part 1 and Part 2 into TOC
			injectPartsIntoTOC = function() {
				var ul = $("#respecContents");
				var first = $(ul.children()[1]);
				var middle = $(ul.children()[6]);
				first.before("<p class='part-header'>Part 1: Core Features</p>");
				middle.before("<p class='part-header'>Part 2: Advanced Features</p>");
			};
		
		</script>
		
		<style>

			pre {
				tab-size: 4;
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.part-header {
				font-weight: bold;
			}
		
			.term {
				font-style: italic;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}
		
			.todo {
				color: red;
			}

		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				SHACL (Shapes Constraint Language) is a language for checking constraints against RDF graphs and for describing graph structures.
				Some of these graph structures are captured as "shapes", which group together constraints about the same RDF nodes.
				Shapes provide a high-level vocabulary to identify predicates and their associated cardinalities, datatypes and other constraints.
				Additional constraints can be associated with shapes using SPARQL and similar executable languages.
				These executable languages can also be used to define new high-level vocabulary terms.
				SHACL shapes can be used to communicate data structures associated with some process or interface, generate or validate data, or drive user interfaces.
				This document defines the SHACL RDF vocabulary together with its underlying semantics.
			</p>	
		</section>

		<section id="sotd">
			<h4>Revision History</h4>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes/commits/gh-pages/shacl/index.html">Git repository</a>.
			</p>
			<ul>
				<li><b>2015-09-01</b>: Minor changes and clarifications</li>
				<li><b>2015-08-24</b>: Added section on sh:defaultValueType (<a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a>)</li>
				<li><b>2015-08-21</b>: Added support for validation functions (<a href="http://www.w3.org/2014/data-shapes/track/issues/79">ISSUE-79</a>)</li>
				<li><b>2015-08-14</b>:
					Added qualified cardinality restrictions (<a href="http://www.w3.org/2014/data-shapes/track/issues/72">ISSUE-72</a>),
					added sh:ignoredProperties to sh:ClosedShape (<a href="http://www.w3.org/2014/data-shapes/track/issues/58">ISSUE-58</a>),
					editorial improvements to terminology, added Glossary to appendix
				</li>
				<li><b>2015-08-07</b>: Extended the use of sh:severity to template constraints, split sh:source into sh:sourceConstraint and sh:sourceShape, renamed sh:root to sh:focusNode</li>
				<li><b>2015-07-31</b>: Added sh:text as the union of xsd:string and rdf:langString</li>
				<li><b>2015-07-30</b>: Integrated sh:InversePropertyScope and sh:AllObjects</li>
				<li><b>2015-07-24</b>: Added details of XSD-like facets (<a href="http://www.w3.org/2014/data-shapes/track/issues/64">ISSUE-64</a>)</li>
				<li>
					<b>2015-07-17</b>: Rewritten scope and filter mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/62">ISSUE-62</a>),
					suggestion for generalized execution language interface (<a href="http://www.w3.org/2014/data-shapes/track/issues/60">ISSUE-60</a>)
				</li>
				<li><b>2015-07-13</b>: Replaced Appendix with references to SHACL-REF document</li>
				<li><b>2015-07-03</b>: Editorial fixes, started revision history</li>
			</ul>
		</section>
	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				SHACL (Shapes Constraint Language) is an RDF-based language to formulate structural constraints on <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
				SHACL includes high-level constructs to represent restrictions on predicates used in <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a>.
				These restrictions can be grouped into "<span class="term">shapes</span>".
				Shapes can be used to restrict the number of property values and the permitted value types as well as other conditions.
				Some users will be content with using the high-level language only, which is called the <span class="term">SHACL Core Profile</span>
				and is described in sections 2 to 6 of this document.
			</p>
			<p>
				For more complex use cases, SHACL also includes facilities to express other restrictions in an executable language such as SPARQL and, possibly, other languages such as JavaScript.
				SHACL includes macro facilities that encapsulate reusable building blocks based on these executable languages into <span class="term">templates</span> and <span class="term">functions</span>.
				These advanced topics are covered from section 7 onwards. 
			</p>
			<p>
				SHACL is written in RDF and can be serialized in multiple RDF formats.
				The examples in this document use Turtle [[!turtle]].
				The reader should be familiar with basic RDF concepts [[!rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[!sparql11-overview]].
			</p>
			<section id="introduction-outline">
				<h3>Document Outline</h3>
				<p>
					The remaining sub-sections of the Introduction provide an overview of the complete language and introduce relevant terminology.
				</p>
				<p>
					The sections 2 - 6 cover the <span class="term">SHACL Core Profile</span> and may be read independently from the later sections.
				</p>
				<p>
					The sections 7 onwards are about the remaining features of the full SHACL language, including templates, functions and execution semantics.
				</p>
				<p>
					The Appendix provides a <a href="#terms">Glossary of Key Concepts</a> that may also serve as a quick overview of the language.
				</p>
				<p>
					The companion specification <a href="../shacl-ref/">SHACL Vocabulary Reference</a> provides additional normative definitions and details.
				</p>
			</section>
			<section id="introduction-overview">
				<h3>Overview and Terminology of Core Features</h3>
				<p>
					The following example illustrates the use of SHACL to define constraints on issues in a hypothetical bug tracking system.
					In the example scenario, the <a href="http://www.w3.org/TR/rdf-schema/#ch_class">RDFS class</a> <code>ex:Issue</code> is used to represent issues, and the class <code>schema:Person</code> represents users.
					One shape requires that each instance of <code>ex:Issue</code> has exactly one value for <code>ex:submittedBy</code>, that that value is an instance of <code>schema:Person</code> that satisfies the constraints on submitters, has at most one value for <code>ex:assignedTo</code>, and that that value is an instance of <code>schema:Person</code>.
					The submitter shape requires at least one value for <code>schema:email</code>. 
				</p>
				<pre class="example" title="Definition of ex:Issue and ex:SubmitterShape">
ex:Issue
	a sh:ShapeClass ;
	sh:property [
		sh:predicate ex:assignedTo ;
		rdfs:label "assigned to" ;
		rdfs:comment "The assignee of an issue must be a person." ;
		sh:maxCount 1 ;
		sh:valueClass schema:Person ;
	] ;
	sh:property [
		sh:predicate ex:submittedBy ;
		rdfs:label "submitted by" ;
		rdfs:comment "The submitter of an issue must be a person who also has an email address." ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
		sh:valueClass schema:Person ;
		sh:valueShape ex:SubmitterShape ;
	] .

ex:SubmitterShape
	a sh:Shape ;
	rdfs:comment "A submitter must have at least one email address." ;
	sh:property [
		sh:predicate schema:email ;
		sh:minCount 1 ;
	] .</pre>
				<p>
					The basic building blocks of SHACL are <span class="term">constraints</span>.
					Each <span class="term">constraint</span> defines a condition that can be validated against a node in a graph.
					The node against which a constraint is validated is called the <span class="term">focus node</span>.
					A <a href="#shapes"><span class="term">shape</span></a> defines a group of <span class="term">constraints</span> to be validated against the same <span class="term">focus node</span>.
					Many of these constraints are about a certain property only, and these are called <a href="#property-constraints"><span class="term">property constraints</span></a>.
					<span class="term">Constraints</span> are validated against a given <span class="term">focus node</span>, which can serve as starting point of property paths and other graph traversal algorithms.
					In the current draft, classes (such as <code>ex:Issue</code> above) MAY also be used as shapes.
					Such shape classes may be arranged in a <span class="term">specialization</span> hierarchy, effectively allowing some shape classes to further narrow down the constraints from other shape classes.
					Shape and constraint definitions are represented in RDF graphs called <span class="term">shapes graphs</span>.
				</p>
				<p>
					In the Issue example above, the shape <code>ex:Issue</code> includes two constraints.
					These constraints are here represented as blank nodes via <code>sh:property</code>.
					Each of these constraints specifies the restricted property via <code>sh:predicate</code>, and one or more constraint properties such as <code>sh:minCount</code> and <code>sh:valueClass</code>.
					The property <code>sh:valueShape</code> points to another <code>sh:Shape</code> that defines additional constraints that the values of
					the <code>ex:submittedBy</code> property must fulfill, in addition to being instances of <code>schema:Person</code>.
				</p>
				<p>
					One of the <a href="#operations"><span class="term">operations</span></a> of SHACL is validating a given RDF node against a given shape, producing <a href="#results"><span class="term">validation results</span></a>, including informational results, warnings and errors.
					Another operation is to validate a given graph using all applicable shapes.
					In order to support that operation, SHACL has the concept of <span class="term">scopes</span>.
					A <span class="term">scope</span> is linked to a shape and defines the nodes to which the shape applies.
					SHACL provides several scoping mechanisms, including node selection based on <code>sh:nodeShape</code> and <code>rdf:type</code> triples,
					as well as a more general scoping framework that produces focus nodes based on an executable language such as SPARQL.
					The scope of a shape can be narrowed down via <span class="term">filter shapes</span> that define pre-conditions that all focus nodes need to fulfill before they are validated.
				</p>
				<p>
					The following RDF graph defines two instances of the class <code>ex:Issue</code>.
					When constraint validation is started, a SHACL engine may follow the <code>rdf:type</code> link of these instances to determine which shapes need to be used.
					(If <code>ex:Issue</code> were not a class but a <code>sh:Shape</code>, then the property <code>sh:nodeShape</code> would have been used instead).
					The first instance passes validation without producing any results.
					The second instance produces an <code>sh:Error</code>, because its value for <code>ex:submittedBy</code> does not have an <code>schema:email</code>. 
				</p>
				<pre class="example" title="Sample Issue instances">
ex:ValidExampleIssue
	a ex:Issue ;
	ex:assignedTo ex:UserWithoutEmail ;
	ex:submittedBy ex:UserWithEmail .
	
ex:InvalidExampleIssue
	a ex:Issue ;
	ex:submittedBy ex:UserWithoutEmail .

ex:UserWithoutEmail
	a schema:Person .
	
ex:UserWithEmail
	a schema:Person ;
	schema:email "someone@example.org" .</pre>
				<p>
					When this instance data is validated, a SHACL engine will produce the following results:
				</p>
				<pre class="example" title="Validation results for the sample instances">
[
	a sh:Error ;
	sh:root ex:InvalidExampleIssue ;
	sh:subject ex:InvalidExampleIssue ;
	sh:predicate ex:submittedBy ;
	sh:object ex:UserWithoutEmail ;
	sh:message "Value does not have the shape ex:SubmitterShape." ;
]</pre>
			</section>
			<section id="introduction-overview-advanced">
				<h3>Overview and Terminology of Advanced Features</h3>
				<p>
					The following paragraphs give an overview of the advanced features of SHACL.
					Readers only interested in the Core Profile may skip this section.
				</p>
				<p>
					The validation of each <span class="term">constraint</span> is formalized with one or more <span class="term">execution languages</span>.
					This version of SHACL supports <a href="#sparql">SPARQL</a> as an <span class="term">execution language</span>, but other languages may be supported in future versions or by other communities.
					Each constraint needs to be backed by at least one <span class="term">executable body</span> in SPARQL, and any alternative bodies need to follow the same semantics as the SPARQL queries.
					Constraints may either directly define such an <span class="term">executable body</span> or point to a <a href="#templates"><span class="term">template</span></a>.
					Constraints that directly include an <span class="term">executable body</span> are called <span class="term">native constraints</span>.
					A <span class="term">template</span> serves as a parameterizable macro that wraps an <span class="term">executable body</span>.
					Constraints that rely on a <span class="term">template</span> are called <span class="term">template constraints</span>.
					The SHACL vocabulary includes a small library of such <span class="term">templates</span> for common constraint patterns, but anyone can add their own template libraries.
					Similar to constraint templates, SHACL also supports <span class="term">scope templates</span> that define a high-level vocabulary to represent <span class="term">scopes</span>.
					Templates can be grouped into so-called <a href="#profiles"><span class="term">profiles</span></a>.
					Some SHACL engines may decide to only support certain <span class="term">profiles</span> and implement them differently than the provided (SPARQL) bodies.
				</p>
				<p>
					The following example illustrates the use of a <span class="term">native SPARQL constraint</span>,
					to specify that there cannot be two resources with the same <code>schema:email</code>.
					Note that each result set row produced by the SELECT clause of the SPARQL query creates one validation result.
				</p>
				<pre class="example" title="A SPARQL-based constraint">
ex:UniqueEmailShape
	a sh:Shape ;
	sh:constraint [
		sh:message "There cannot be two resources with the same email address." ;
		sh:predicate schema:email ;
		sh:sparql """
			SELECT ?this (?this AS ?subject) (?email AS ?object)
			WHERE {
				?this schema:email ?email .
				?other schema:email ?email .
				FILTER (?this != ?other) .
			}
			"""
	] .</pre>
			</section>
			
			<section id="namespaces">
				<h3>Namespaces</h3>
				<p>
					The SHACL system vocabulary is available as a <a href="shacl.shacl.ttl">SHACL Turtle File</a>.
					<span class="todo">Currently contains slight differences from this spec.</span> 
				</p>
				
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
					<tr>
						<td><code>schema:</code></td>
						<td><code>http://schema.org/</code></td>
					</tr>
				</table>
			</section>
			
			<section id="conformance">
				<p>
					<span class="todo">TODO: We still need to mark non-normative sections.</span>
				</p>
			</section>
	
		</section>

		<section id="shapes">
			<h2>Shapes</h2>
			<div class="issue" data-number="23" title="Classes and/or Shapes">
				There is no agreement in the WG on the relationship of sh:Shape with classes.
				Proposals include:
				<ul>
					<li>Keep them completely separate, users only instantiate sh:Shape and use sh:extends</li>
					<li>Have rdfs:Class rdfs:subClassOf sh:Shape, use rdfs:subClassOf</li>
					<li>Have sh:Shape rdfs:subClassOf rdfs:Class, use rdfs:subClassOf</li>
					<li>Allow both approaches in parallel: either rdfs:Class/subClassOf or sh:Shape/extends</li>
					<li>Allow both and have sh:classShape or sh:classScope or sh:scopeClass to point from a class to its shapes (or vice versa)</li>
				</ul>
				In the absence of such an agreement, this document uses sh:Shape in most examples but allows
				classes to be also shapes, with the class sh:ShapeClass as syntactic sugar.
			</div>
			<p>
				A <span class="term">Constraint</span> defines restrictions on the structure of an RDF graph.
				A <span class="term">Shape</span> is a group of constraints that have the same focus nodes.
				For example, a shape can be used to state that all instances of a class must have a certain number of values for a given property.
				In that example, the instances of the class are the focus nodes, and the restriction on property values is expressed via a constraint.
			</p>
			<p>
				In the SHACL RDF vocabulary, Shapes are instances of the class <code>sh:Shape</code>.
			</p>
			<section id="shape-labels">
				<h3>Shape Labels and Comments</h3>
				<p>
					Like many other types of RDF resources, shapes SHOULD have human-readable labels via <code>rdfs:label</code>.
					The property <code>rdfs:comment</code> is recommended for documentation and definition purposes.
				</p>
			</section>
			<section id="shape-classes">
				<h3>Shapes and Classes</h3>
				<p>
					A shape can be associated with a class via the property <code>sh:scopeClass</code>.
					In such cases, the shape applies to all instances of the associated class, i.e. any node that has the <code>sh:scopeClass</code> or one of its subclasses as its <code>rdf:type</code>.
				</p>
				<p>
					If a <code>sh:Shape</code> is also an instance of <code>rdfs:Class</code> then the shape applies to all instances of that class.
					There is a built-in subclass of <code>sh:Shape</code> called <code>sh:ShapeClass</code> that is also a subclass of <code>rdfs:Class</code> to simplify the declaration of shapes that are also classes.
				</p>
				<p>
					A consequence of these links between shapes and classes is that shape declarations can specialize the shapes associated with the superclasses, declared via <code>rdfs:subClassOf</code>.
				</p>
				<p>
					The following figure illustrates some relationships between core classes of SHACL and RDF Schema.
					Note that the use of a UML-like notation does not imply that these RDF concepts are classes in an object-oriented sense.
				</p>
 				<figure>
					<img src='images/shacl-class-metamodel.png'>
					<figcaption>Illustration of some relationships between classes of SHACL and RDF Schema</figcaption>
				</figure>
				<div class="issue" data-number="78" title="Abstract classes">
					The following paragraph about <code>sh:abstract</code> is not yet approved by the WG.
					Options include:
					<ul>
						<li>No support of abstract classes</li>
						<li>Use <code>sh:abstract</code> entirely for documentation purposes</li>
						<li>Use <code>sh:abstract</code> also as a constraint check, possibly producing a warning</li>
					</ul>
				</div>
				<p>
					Classes with type <code>sh:ShapeClass</code> may be declared to be <span class="term">abstract</span> by
					setting their property <code>sh:abstract</code> to <code>true</code>.
					Abstract classes SHOULD not be instantiated directly, i.e. every instance of an abstract class SHOULD also
					have an <code>rdf:type</code> triple to a non-abstract subclass of the abstract class.
				</p>
			</section>
			<section id="shape-constraints">
				<h3>Shape Constraints</h3>
				<p>
					A shape defines a group of constraints applicable to the same <span class="term">focus node</span>.
					These constraints fall into three categories that are covered by subsequent sections.
				</p>
				<ul>
					<li>
						<a href="#property-constraints">Property Constraints</a> specify constraints applicable to a given property in the context of a shape.
						The properties <code>sh:property</code> and <code>sh:inverseProperty</code> are used to link a Shape with its property constraints.
					</li>
					<li>
						<a href="#other">Other constraints</a>:
						Logical operations (<a href="#not">not</a>, <a href="#and">and</a>, <a href="#or">or</a> and <a href="#xor">xor</a>),
						and	<a href="#ClosedShape">Closed Shapes</a> which limit properties of a node to those explicitly enumerated.
					</li>
					<li>
						<a href="#general-constraints">General Constraints</a> which define constraints that are not related to only a single property. 
						The property <code>sh:constraint</code> is used to link a shape with its general constraints.
					</li>
				</ul>
				<p>
					In addition, SHACL has a notion of <a href="#filterShape">filter shapes</a> that can be used to define pre-conditions
					that must be met for a constraint to apply to a given <span class="term">focus node</span>.
				</p>
 				<figure>
					<img src='images/shacl-constraint-metamodel.png'>
					<figcaption>Illustration of some core SHACL constraint classes</figcaption>
				</figure>
			</section>
		</section>
		
		<section id="property-constraints">
			<h2>Property Constraints</h2>
			<p>
				In many cases, the constraints defined by a shape are about a given property of the focus nodes.
				Depending on the direction of triple traversal, SHACL defines two properties to associate a shape with such property-related constraints:
			</p>
			<ul>
				<li><a href="#property-constraints-property"><code>sh:property</code></a> is used to link a shape with property constraints (on the objects of triples)</li>
				<li><a href="#property-constraints-inverseProperty"><code>sh:inverseProperty</code></a> is used to link a shape with inverse property constraints (on the subjects of triples)</li>
			</ul>
			<p>
				The following sections describe the role of each of these properties in detail.
				Note that this section only includes textual definitions of the semantics of those properties.
				Their formal definitions based on SPARQL are provided in the <a href="../shacl-ref/">SHACL Vocabulary Reference</a>.
			</p>

			<section id="property-constraints-property">
				<h3>Property Constraints (sh:property)</h3>
				<p>
					A <span class="term">property constraint</span> is a constraint that defines restrictions on the values of a given property in the context of the focus node.
					Here, the focus node is the <span class="term">subject</span> and the property is the <span class="term">predicate</span> of relevant triples.
					The property <code>sh:property</code> can be used to link a shape with its property constraints.
				</p>
				<div class="issue" data-number="70" title="Special treatment of blank nodes">
					The WG has not yet decided whether the special treatment of blank nodes explained below (and in other places) will remain in the language.
				</div>
				<p>
					In the SHACL RDF vocabulary, property constraints are instances of the class <code>sh:PropertyConstraint</code>.
					When used as values of <code>sh:property</code>, property constraints represented as blank nodes do not require an <code>rdf:type</code> triple.
					Note that <code>sh:property</code> may also have values that are sub-classes of <code>sh:PropertyConstraint</code>,
					but in this case the <code>rdf:type</code> triple is required.
					It is not valid to use <code>sh:property</code> for constraints that are not instance of <code>sh:PropertyConstraint</code>.
				</p>
				<p> 
					The following examples illustrate two ways of using property constraints.
					The first example uses a blank node:
				</p>
				<pre class="example" title="Property constraint represented by a blank node">
ex:InlinePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:valueClass ex:SomeClass ;
		rdfs:label "some property" ;
		rdfs:comment "Description of the role of ex:someProperty (in the context of the constraint)" ;
	] .</pre>
				<p>
					The second example defines a constraint as an IRI node, allowing it to be more easily referenced and shared across multiple shapes:
				</p>
				<pre class="example" title="Property constraint represented by a IRI">
ex:StandAlonePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property ex:StandAloneConstraint .

ex:StandAloneConstraint
	a sh:PropertyConstraint ;
	sh:predicate ex:someProperty ;
	sh:defaultValue ex:SomeInstance ;
	sh:minCount 1 ;
	sh:valueClass ex:SomeClass .</pre>
				<p>
					Property constraints may have an <code>rdfs:label</code> to provide a human-readable label for the property	in the context where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					Similarly, property constraints may have an <code>rdfs:comment</code> to provide a description of the property in the given context.
					Both <code>rdfs:label</code> and <code>rdfs:comment</code> may have multiple values, but SHOULD only have one value per language tag.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but may be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code> or <code>sh:valueClass</code> of the same constraint.
				</p>
				<p>
					The following sections provide details on the properties that may be used with <code>sh:PropertyConstraint</code>.
					Note that the textual definitions of those properties refer to the <a href="#results">Validation Results Vocabulary</a>
					introduced in a later section.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Properties</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><a href="#AbstractAllowedValuesPropertyConstraint"><code>sh:allowedValues</code></a></td>
						<td>Enumeration of allowed values</td>
					</tr>
					<tr>
						<td><a href="#AbstractDatatypePropertyConstraint"><code>sh:datatype</code></a></td>
						<td>Datatype of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractHasValuePropertyConstraint"><code>sh:hasValue</code></a></td>
						<td>A specific required value</td>
					</tr>
					<tr>
						<td><a href="#AbstractCountPropertyConstraint"><code>sh:minCount</code>, <code>sh:maxCount</code></a></td>
						<td>Minimum and maximum cardinality</td>
					</tr>
					<tr>
						<td><a href="#AbstractLengthPropertyConstraint"><code>sh:minLength</code>, <code>sh:maxLength</code></a></td>
						<td>Minimum and maximum string length</td>
					</tr>
					<tr>
						<td><a href="#AbstractMaxExclusivePropertyConstraint"><code>sh:maxExclusive</code></a></td>
						<td>Maximum exclusive value (&gt;)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMaxInclusivePropertyConstraint"><code>sh:maxInclusive</code></a></td>
						<td>Maximum inclusive value (&gt;=)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMinExclusivePropertyConstraint"><code>sh:minExclusive</code></a></td>
						<td>Minimum exclusive value (&lt;)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMinInclusivePropertyConstraint"><code>sh:minInclusive</code></a></td>
						<td>Minimum inclusive value (&lt;=)</td>
					</tr>
					<tr>
						<td><a href="#AbstractNodeKindPropertyConstraint"><code>sh:nodeKind</code></a></td>
						<td>Node kind (IRI, blank node, or literal) of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractPatternPropertyConstraint"><code>sh:pattern</code></a></td>
						<td>Regular expression string matching</td>
					</tr>
					<tr>
						<td>
							<a href="#AbstractValueClassPropertyConstraint"><code>sh:valueClass</code></a> and
							<a href="#AbstractDirectValueTypePropertyConstraint"><code>sh:directValueType</code></a>
						</td>
						<td>Type of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractValueShapePropertyConstraint"><code>sh:valueShape</code></a></td>
						<td>Nested shape of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractQualifiedValueShapePropertyConstraint"><code>sh:qualifiedValueShape</code>, <code>sh:qualifiedMinCount</code>, <code>sh:qualifiedMaxCount</code></a></td>
						<td>Nested shape of a given minimum/maximum number of values</td>
					</tr>
				</table>
				<section id="AbstractAllowedValuesPropertyConstraint">
					<h4>sh:allowedValues</h4>
					<p>
						The property <code>sh:allowedValues</code> can be used to enumerate the values a property can have.
						When specified, the value of the given property MUST be members of the specified set.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:allowedValues</code></td>
							<td><code>rdf:List</code></td>
							<td>Enumeration of allowed values</td>
						</tr>
					</table>
					<div id="def-allowedValues-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:allowedValues</code> must be well-formed instances of <code>rdf:List</code>.
							The members of that <code>rdf:List</code> must not be blank nodes.
							A <span class="term">validation result</span> must be produced for every triple that has the <span class="term">focus node</span> as its subject,
							the <code>sh:predicate</code> as its predicate and an object that is not a member of the given list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
							Each produced <span class="term">result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective invalid value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractAllowedValuesPropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:allowedValues constraint">
ex:AllowedValuesExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:allowedValues ( ex:Value1 ex:Value2 ex:Value3 ) ;
	] .

ex:AllowedValuesExampleValidResource
	ex:someProperty ex:Value2 .</pre>
				</section>
				<section id="AbstractDatatypePropertyConstraint">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all values of the given property.
						The values of <code>sh:datatype</code> must be instances of the class <code>rdfs:Datatype</code>, such as <code>xsd:string</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdfs:Datatype</code></td>
							<td>Datatype of all values (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div id="def-nodeType-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is not a literal, or is a literal with a mismatching datatype.
							A literal matches a datatype if the literal's datatype has the same IRI,
							or if its datatype is <code>rdf:langLiteral</code> or <code>xsd:string</code> and the expected datatype is <a href="../shacl-ref/#text"><code>sh:text</code></a>.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractDatatypePropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:datatype constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatype sh:text ;
	] .

ex:DatatypeShapeExampleValidResource
	ex:someProperty "Some value" ;
	ex:someProperty "Value with language tag"@en .

ex:DatatypeShapeExampleInvalidResource
	ex:someProperty 42 .</pre>
				</section>
				<section id="AbstractDirectValueTypePropertyConstraint">
					<h4>sh:directValueType</h4>
					<p>
						The property <code>sh:directValueType</code> can be used to restrict the <code>rdf:type</code> of all values of the given property.
						The values of <code>sh:directValueType</code> must be classes (instances of <code>rdfs:Class</code>).
						The main difference with <a href="#AbstractValueClassPropertyConstraint"><code>sh:valueClass</code></a> is that <code>sh:directValueType</code> does not include subclasses of the type.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:directValueType</code></td>
							<td><code>rdfs:Class</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div id="def-nodeType-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not have an <code>rdf:type</code> triple with the given value type as object.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractDirectValueTypePropertyConstraint">Definition in SPARQL</a>.</p>
				</section>
				<section id="AbstractHasValuePropertyConstraint">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify
						that the <span class="term">focus node</span> has a given RDF node among the values of the given
						predicate.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>any</td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if there is no triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and the <code>sh:hasValue</code> as its object.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractHasValuePropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:hasValue constraint">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .

ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
				</section>
				<section id="AbstractCountPropertyConstraint">
					<h4>sh:minCount, sh:maxCount</h4>
					<p>
						The properties <code>sh:minCount</code> and <code>sh:maxCount</code>
						restrict the number of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>. 
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum cardinality. Default value is 0.</td>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum cardinality. Default interpretation is unlimited.</td>
						</tr>
					</table>
					<div id="def-count-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The default value of <code>sh:minCount</code> is 0.
							Let <code>?count</code> be the number of triples that have the <span class="term">focus node</span> as
							the <span class="term">subject</span> and the <code>sh:predicate</code> as the <span class="term">predicate</span>.
							A <span class="term">validation result</span> must be produced in either of the following cases:
							If <code>?count</code> is less than the value of <code>sh:minCount</code>, or
							if <code>sh:maxCount</code> is present and <code>?count</code> is greater than the value of <code>sh:maxCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							and the predicate as its <code>sh:predicate</code>. 
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractCountPropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:minCount and sh:maxCount constraints">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
				<section id="AbstractLengthPropertyConstraint">
					<h4>sh:minLength, sh:maxLength</h4>
					<p>
						The properties <code>sh:minLength</code> and <code>sh:maxLength</code>
						restrict the string length of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						This can be applied to any type of literal and IRIs, but not for blank nodes.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum length. Default value is 0.</td>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum length. Default interpretation is unlimited.</td>
						</tr>
					</table>
					<div id="def-count-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The default value of <code>sh:minLength</code> is 0.
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the length of the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							of the object is either less than the specified minimum length or more than the specified maximum length, or if the object is a blank node.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractLengthPropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:minLength and sh:maxLength constraints">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
		rdfs:comment "Password must be between 8 and 10 characters long" ;
	] .

ex:PasswordExampleValidResource
	ex:password "password" .</pre>
				</section>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						The supported datatypes of these properties are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="AbstractMinExclusivePropertyConstraint">
							<td><code>sh:minExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code> (see also: <a href="../shacl-ref/#AbstractMinExclusivePropertyConstraint">Definition in SPARQL</a>)</td>
						</tr>
						<tr id="AbstractMinInclusivePropertyConstraint">
							<td><code>sh:minInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code> (see also: <a href="../shacl-ref/#AbstractMinInclusivePropertyConstraint">Definition in SPARQL</a>)</td>
						</tr>
						<tr id="AbstractMaxExclusivePropertyConstraint">
							<td><code>sh:maxExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code> (see also: <a href="../shacl-ref/#AbstractMaxExclusivePropertyConstraint">Definition in SPARQL</a>)</td>
						</tr>
						<tr id="AbstractMaxInclusivePropertyConstraint">
							<td><code>sh:maxInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code> (see also: <a href="../shacl-ref/#AbstractMaxInclusivePropertyConstraint">Definition in SPARQL</a>)</td>
						</tr>
					</table>
					<div id="def-count-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <span class="term">validation result</span> must also be produced if the object cannot be compared to the specified range.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the engine will produce an error.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<pre class="example" title="Shape with sh:minInclusive and sh:maxInclusive constraints">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minInclusive 1 ;
		sh:maxInclusive 10 ;
	] .

ex:NumericExampleValidResource
	ex:someProperty 7 .

ex:NumericExampleInvalidResource1
	ex:someProperty 11 .

ex:NumericExampleInvalidResource2
	ex:someProperty "a string" .</pre>
				</section>
				<section id="AbstractNodeKindPropertyConstraint">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> can be used to restrict the RDF node kind of all values of the given property.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td><code>sh:NodeKind</code></td>
							<td>Node kind (IRI, blank node, or literal) of all values</td>
						</tr>
					</table>
					<p>
						The values of <code>sh:nodeKind</code> must be instances of the class <code>sh:NodeKind</code>.
						The SHACL system vocabulary defines that <code>sh:NodeKind</code> has exactly 3 instances:
						<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code> (see also the <a href="#function-hasNodeKind">Appendix</a>).
					</p>
					<div id="def-nodeType-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the given node kind.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractNodeKindPropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:nodeKind constraint">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:nodeKind ex:IRI ;
	] .

ex:NodeKindShapeExampleValidResource
	ex:someProperty ex:SomeIRI .

ex:NodeKindShapeExampleInvalidResource
	ex:someProperty ex:SomeIRI ;
	ex:someProperty "A literal" .</pre>
				</section>
				<section id="AbstractPatternPropertyConstraint">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to validate whether all values of the given property match a given regular expression.
						The values of <code>sh:pattern</code> must be valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td><code>xsd:string</code></td>
							<td>Regular expression that all values must match</td>
						</tr>
					</table>
					<div id="def-nodeType-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							of the object does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractPatternPropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:pattern constraint">
ex:PatternExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:pattern "^Ali" ;
	] .

ex:PatternShapeExampleValidResource
	ex:someProperty "Alice" .

ex:PatternShapeExampleInvalidResource
	ex:someProperty "The Alice" .</pre>
				</section>
				<section id="AbstractValueClassPropertyConstraint">
					<h4>sh:valueClass</h4>
					<p>
						The property <code>sh:valueClass</code> can be used to restrict the <code>rdf:type</code> of all values of the given property.
						The values of <code>sh:valueClass</code> must be classes (instances of <code>rdfs:Class</code>).
						The main difference with <a href="#AbstractDirectValueTypePropertyConstraint"><code>sh:directValueType</code></a> is that <code>sh:valueClass</code> also includes subclasses of the type.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:valueClass</code></td>
							<td><code>rdfs:Class</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div id="def-nodeType-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if its <code>rdf:type</code> is equal to the type or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code>.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractValueClassPropertyConstraint">Definition in SPARQL</a>.</p>
					<pre class="example" title="Shape with sh:valueClass constraint">
ex:ValueClassExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueClass ex:ClassA ;
	] .
	
ex:InstanceOfClassA
	a ex:ClassA .

ex:ValueClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA .</pre>
				</section>
				<section id="AbstractValueShapePropertyConstraint">
					<h4>sh:valueShape</h4>
					<p>
						The property <code>sh:valueShape</code> can be used verify that all values of the given property must have a given shape.
						The value type of <code>sh:valueShape</code> is <code>sh:Shape</code>.
						If the value shapes are blank nodes, then their <code>rdf:type</code> triple can be omitted.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:valueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of all values</td>
						</tr>
					</table>
					<div id="def-valueShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:valueShape</code> 
							produces any error-level constraint violations.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractValueShapePropertyConstraint">Definition in SPARQL</a>.</p>
					<p class="issue" data-number="22" title="Recursion of sh:valueShape">
						It is not yet decided how to handle recursive shape definitions in sh:valueShape and similar constructs.
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> are supposed to validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example" title="Shape with sh:valueShape constraint">
ex:ValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueShape [
			a sh:Shape ;   # Optional
			sh:predicate [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .

ex:ValueShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				<section id="AbstractQualifiedValueShapePropertyConstraint">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a certain number values of the given property must have a given shape.
						The value type of <code>sh:qualifiedValueShape</code> is <code>sh:Shape</code>, and it needs to be accompanied by
						a <code>sh:qualifiedMinCount</code> or a <code>sh:qualifiedMaxCount</code> (both typed <code>xsd:integer</code>), or both.
						If the value shapes are blank nodes, then their <code>rdf:type</code> triple can be omitted.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of the specified values</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum number of values that must have the shape</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum number of values that can have the shape</td>
						</tr>
					</table>
					<div class="issue" data-number="83" title="Syntax of multiple qualified shape constraints">
						There is an ongoing debate how to best represent multiple qualified shape constraints for the same property.
					</div>
					<div id="def-valueShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of triples that have
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no error-level constraint violations is outside of the interval specified by <code>sh:qualifiedMinCount</code> and <code>sh:qualifiedMaxCount</code>.
							The interval defaults to <code>0</code> if the min count is not specified, and unlimited if the max count is not specified.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code> and <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<p>See also: <a href="../shacl-ref/#AbstractQualifiedValueShapePropertyConstraint">Definition in SPARQL</a>.</p>
					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example" title="Shape with sh:valueShape constraint">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .

ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>
			</section>
			
			<section id="property-constraints-inverseProperty">
				<h3>Inverse Property Constraints (sh:inverseProperty)</h3>
				<p class="todo">
					TODO: This section is quite similar to the one about sh:property, only in the inverse direction.
					Before writing all this down, we'd rather wait until the forward direction has stabilized.
					A quick example should suffice for now:
				</p>
				<pre class="example" title="Shape with an inverse property constraint">
ex:InversePropertyConstraintExampleShape
	a sh:Shape ;
	sh:inverseProperty [
		sh:predicate ex:someProperty ;  # e.g. "child"
		sh:minCount 1 ;
		rdfs:label "is someProperty of" ;  # e.g. "parent"
	] .</pre>
			</section>
		</section>

		<section id="other">
			<h2>Other Core Constraints</h2>
			<p>
				While the previous sections have introduced constraints that focused on a single property within a shape,
				this section introduces other constraint types that can be used with shapes.
			</p>
			<section id="not">
				<h3>sh:NotConstraint</h3>
				<p>
					SHACL supports a high-level negation constraint that can be used to verify that the <span class="term">focus node</span> does not have a given shape.
					This is comparable to a logical "not" operator.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Property</th>
						<th>Value Type</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><code>sh:shape</code></td>
						<td><code>sh:Shape</code></td>
						<td>The shape to negate</td>
					</tr>
				</table>
				<div id="def-andConstraint-text" class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						A <span class="term">validation result</span> must be produced if the <span class="term">focus node</span> produces no error-level
						validation results for the shape given via <code>sh:shape</code>. 
						The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code>.
					</div>
				</div>
				<p>See also: <a href="../shacl-ref/#NotConstraint">Definition in SPARQL</a>.</p>
				<p>
					The following example illustrates the use of <code>sh:NotConstraint</code> in a shape to verify
					that certain nodes cannot have any value of <code>ex:property</code>.
				</p>
				<pre class="example" title="Shape with a negation">
ex:NotExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:NotConstraint ;
		sh:shape [
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:minCount 1 ;
			] ;
		]
	] .

ex:InvalidInstance1
  	ex:property "Some value" .</pre>
			</section>
			<section id="and">
				<h3>sh:AndConstraint</h3>
				<p>
					SHACL supports a high-level syntax for conjunctive constraints that can be used to test whether the <span class="term">focus node</span> has all out of several shapes.
					This is comparable to a logical "and" operator.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Property</th>
						<th>Value Type</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><code>sh:shapes</code></td>
						<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
						<td>List of shapes to validate</td>
					</tr>
				</table>
				<div class="issue" data-number="76" title="Ordering of operands in AND/OR">
					The current specification of sh:AndConstraint and sh:OrConstraint does not yet reflect the resolution to ISSUE-76,
					that the order of operands does not matter.
				</div> 
				<div id="def-andConstraint-text" class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						A <span class="term">validation result</span> must be produced if the <span class="term">focus node</span> produces error-level
						validation results for at least one of the shapes in the <code>rdf:List</code> <code>sh:shapes</code>. 
						The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code>.
						Validation of the shapes in the <code>rdf:List</code> must happen from left to right, and the validation must stop as soon as it finds the first error.
					</div>
				</div>
				<p>See also: <a href="../shacl-ref/#AndConstraint">Definition in SPARQL</a>.</p>
				<p>
					The following example illustrates the use of <code>sh:AndConstraint</code> in a shape to verify
					that certain nodes have exactly one value of <code>ex:property</code>.
					This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
					the minimum count, and a blank node shape that further constrains the maximum count.
					As shown here, <code>sh:AndConstraint</code> can be used to implement a specialization mechanism between shapes. 
				</p>
				<pre class="example" title="Shape with a conjunction">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:constraint [
		a sh:AndConstraint ;
		sh:shapes (
			ex:SuperShape
			[
				sh:property [
					sh:predicate ex:property ;
					sh:maxCount 1 ;
				]
			]
		)
	] .


ex:ValidInstance1
	ex:property "One" .

# Invalid: more than one property
ex:InvalidInstance2
	ex:property "One" ;
	ex:property "Two" .</pre>
			</section>
			<section id="or">
				<h3>sh:OrConstraint</h3>
				<p>
					SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether the <span class="term">focus node</span> has at least one out of several shapes.
					This is comparable to a logical "or" operator.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Property</th>
						<th>Value Type</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><code>sh:shapes</code></td>
						<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
						<td>List of shapes to validate</td>
					</tr>
				</table>
				<div id="def-orConstraint-text" class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						A <span class="term">validation result</span> must be produced if the <span class="term">focus node</span> produces error-level
						validation result against all of the shapes in the <code>rdf:List</code> <code>sh:shapes</code>. 
						The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code>.
						Validation of the shapes in the <code>rdf:List</code> must happen from left to right, and the validation must stop as soon as it finds the first shape that produces no error-level validation results.
					</div>
				</div>
				<p>See also: <a href="../shacl-ref/#OrConstraint">Definition in SPARQL</a>.</p>
				<p>
					The following example illustrates the use of <code>sh:OrConstraint</code> in a shape to verify
					that certain nodes have at least one value of <code>ex:exampleProperty1</code>
					or at least one value of <code>ex:exampleProperty2</code>.
				</p>
				<pre class="example" title="Shape with a disjunction">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:OrConstraint ;
		sh:shapes (
			[
				sh:property [
					sh:predicate ex:exampleProperty1 ;
					sh:minCount 1 ;
				]
			]
			[
				sh:property [
					sh:predicate ex:exampleProperty2 ;
					sh:minCount 1 ;
				]
			]
		)
	] .
	
ex:OrConstraintExampleValidResource
	ex:exampleProperty1 ex:someValue .</pre>
			</section>
			<section id="xor">
				<h3>sh:XorConstraint</h3>
				<p>
					SHACL supports a high-level syntax for exclusive-or constraints that can be used to test whether the <span class="term">focus node</span> has exactly one out of several shapes.
					This is comparable to a logical "xor" operator.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Property</th>
						<th>Value Type</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><code>sh:shapes</code></td>
						<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
						<td>List of shapes to validate</td>
					</tr>
				</table>
				<div id="def-orConstraint-text" class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Using all shapes in the <code>rdf:List</code> <code>sh:shapes</code>, a <span class="term">validation result</span> must be produced if the number of   
						shapes where the <span class="term">focus node</span> produces error-level validation results is not equal to 1. 
						The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code>.
					</div>
				</div>
				<p>See also: <a href="../shacl-ref/#XorConstraint">Definition in SPARQL</a>.</p>
				<p>
					The following example illustrates the use of <code>sh:XorConstraint</code> in a shape to verify
					that certain nodes have either a value for <code>ex:fullName</code> or a combination of
					<code>ex:givenName</code> and <code>ex:familyName</code>.
				</p>
				<pre class="example" title="Shape with an Xor constraint">
ex:GivenAndFamilyNameXorFullNameShape
	a sh:Shape ;
	sh:constraint [
		a sh:XorConstraint ;
		sh:shapes (
		[
			sh:property [
				sh:predicate ex:givenName ;
				sh:minCount 1 ;
			] ;
			sh:property [
				sh:predicate ex:familyName ;
				sh:minCount 1 ;
			]
		]
		[
			sh:property [
				sh:predicate ex:fullName ;
				sh:minCount 1 ;
			]
		] )
	] .
	
ex:ValidInstance1
  	ex:givenName "John" ;
  	ex:familyName "Doe" .

ex:ValidInstance2
  	ex:fullName "John Doe" .

ex:ValidInstance3
	ex:givenName "John" ;
  	ex:fullName "John Doe" .

# Invalid: neither
ex:InvalidInstance1
	rdfs:label "This fulfills neither condition." .

# Invalid: both
ex:InvalidInstance2
	ex:givenName "John" ;
  	ex:familyName "Doe" ;
  	ex:fullName "John Doe" .</pre>
			</section>
			<section id="ClosedShape">
				<h3>Closed Shapes (sh:ClosedShapeConstraint)</h3>
				<p>
					The RDF data model offers a huge amount of flexibility.
					Any resource can in principle have values for any property.
					However, in some cases it makes sense to restrict which properties can be applied to resources.
					The SHACL core language includes a construct called <code>sh:ClosedShapeConstraint</code> that can be assigned to
					a shape via the property <code>sh:constraint</code> to indicate that valid resources must only have
					values for those properties that have been explicitly declared via <code>sh:property</code>.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Property</th>
						<th>Value Type</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><code>sh:ignoredProperties</code></td>
						<td><code>rdf:List</code> (members: <code>rdf:Property</code>)</td>
						<td>Optional list of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
					</tr>
				</table>
				<div id="def-ClosedShape-text" class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						A <span class="term">validation result</span> must be produced for each triple that has the <span class="term">focus node</span> as its
						<span class="term">subject</span> and a <span class="term">predicate</span> that is not explicitly enumerated as a <code>sh:predicate</code>
						of the <code>sh:property</code> constraints at the surrounding shape.
						If the argument <code>sh:ignoredProperties</code> is present then the properties enumerated in this list are also permitted.
						The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:root</code>,
						and the corresponding values of the triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
					</div>
				</div>
				<p>
					The core vocabulary includes an instance of <code>sh:ClosedShapeConstraint</code> called <code>sh:ClosedShape</code>
					that can be used in places where no other arguments such as <code>sh:ignoredProperties</code> are needed.
				</p>
				<p>See also: <a href="../shacl-ref/#ClosedShapeConstraint">Definition in SPARQL</a>.</p>
				<p>
					The following example illustrates the use of <code>sh:ClosedShapeConstraint</code> in a shape to verify
					that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
					The "ignored" properties <code>sh:nodeShape</code> and <code>rdf:type</code> would also be allowed.
				</p>
				<pre class="example" title="A closed shape">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:ClosedShapeConstraint ;
		sh:ignoredProperties (sh:nodeShape rdf:type) ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .
	
ex:ClosedShapeExampleValidResource
	ex:exampleProperty1 ex:someValue .
	
ex:ClosedShapeExampleInvalidResource
	ex:exampleProperty2 ex:someValue ;
	ex:someOtherProperty 42 .</pre>
			</section>
		</section>
			
		<section id="scopesAndFilters">
			<h2>Scopes and Filter Shapes</h2>
			<p>
				SHACL includes vocabulary to define <span class="term">scopes</span>, which can be used by a SHACL processor to select which focus nodes need to be validated against which shapes.
				The resulting collection of focus nodes can furthermore be narrowed down via so-called <span class="term">filter shapes</span>.
				Both concepts are illustrated by the following figure, and introduced in the following sub-sections.
			</p>
			<figure>
				<img src="images/SHACL-Validation-Process.png" />
				<figcaption>Illustration of the scoping and filtering process</figcaption>
			</figure>
			<section id="scopes">
				<h3>Scopes</h3>
				<p>
					SHACL supports three kinds of scopes:
				</p>
				<ul>
					<li><a href="#nodeShape"><b>Individual scopes</b></a> link a specific resource with a shape via <code>sh:nodeShape</code>.
					<li><a href="#scopeClass"><b>Class-based scopes</b></a> link all instances of a given class with a shape, using <code>sh:scopeClass</code> and <code>rdf:type</code>.</li>
					<li><a href="#scope"><b>General scopes</b></a> define a flexible mechanism to produce arbitrary focus nodes for a given graph.</li>
				</ul>
				
				<section id="nodeShape">
					<h4>Individual scopes (sh:nodeShape)</h4>
					<div class="issue" data-number="61" title="Direction of sh:nodeShape">
						There is an alternative proposal discussed that would reverse the direction of this, pointing from the shape to the nodes.
					</div>
					<p>
						Individual nodes can point to the shapes that they are supposed to be validated against using the property <code>sh:nodeShape</code>.
						The values of <code>sh:nodeShape</code> must be IRIs.
						This pattern is illustrated in the following example. 				
					</p>
					<pre class="example" title="Scope based on sh:nodeShape">
ex:ExampleShape
	a sh:Shape ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	sh:nodeShape ex:ExampleShape .</pre>
				</section>
				
				<section id="scopeClass">
					<h4>Class-based Scopes (sh:scopeClass and rdf:type)</h4>
					<p>
						RDF Schema and OWL provide a well-established framework to model domains in terms of classes and instances.
						A lot of existing data is already represented using these languages.
						The property <code>sh:scopeClass</code> can be used to link a <code>sh:Shape</code> with an <code>rdfs:Class</code>.
						The property <code>rdf:type</code> is used to determine which shapes a given node are expected to fulfill.
						The scope includes all instances of the <code>sh:scopeClass</code> and its subclasses, by following <code>rdfs:subClassOf</code> triples.
						<span class="todo">(TODO: specify whether these subClassOf triples are expected to be in the query graph and/or the shapes graph.)</span> 
						This pattern is illustrated in the following example.
					</p>
					<pre class="example" title="Scope based on rdf:type and sh:scopeClass">
ex:ExampleClass
	a rdfs:Class .

ex:ExampleShape
	a sh:Shape ;
	sh:scopeClass ex:ExampleClass ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	rdf:type ex:ExampleClass .</pre>
					<p>
						If the type class of an instance is also an instance of <code>sh:Shape</code> then the <code>sh:scopeClass</code> triple can be omitted and <code>rdf:type</code> may directly link a resource with its shapes.
						In this <span class="term">scope</span>, the IRIs of classes double as shape definitions, i.e. it is possible to directly link constraints to the IRI of a class.
						As syntactic sugar, the metaclass <code>sh:ShapeClass</code> can be used as a combination of <code>rdfs:Class</code> and <code>sh:Shape</code>.
						This pattern is illustrated in the following example.
					</p>
					<pre class="example" title="Scope based on rdf:type only">
ex:ExampleClassAndShape
	a rdfs:Class ;    # These two triples can be simplified via sh:ShapeClass
	a sh:Shape ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	rdf:type ex:ExampleClass .</pre>
				</section>
				
				<section id="scope">
					<h4>General scopes (sh:scope)</h4>
					<p>
						SHACL includes a generic mechanism to select focus nodes.
						A <code>sh:Shape</code> can point to one or more instances of <code>sh:Scope</code>.
						The core profile of SHACL includes several subclasses of <code>sh:Scope</code> that define a high-level vocabulary for common scope patterns.
						The full SHACL language also includes a generic mechanism based on executable languages such as SPARQL, elaborated in an <a href="#general-scopes">advanced section</a>.
					</p>
					<section id="PropertyScope">
						<h5>Property scopes (sh:PropertyScope)</h5>
						<p>
							The scope class <code>sh:PropertyScope</code> selects all subjects that have at least one value for a given property <code>sh:predicate</code>.
						</p>
						<p>See also: <a href="../shacl-ref/#PropertyScope">Definition in SPARQL</a>.</p>
						<p>
							The following example uses <code>sh:PropertyScope</code> to define a constraint	that shall apply to all resources that have any value for the property <code>ex:property</code>:
						</p>
						<pre class="example" title="Shape with sh:PropertyScope">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:PropertyScope ;
		sh:predicate ex:property ;
	] ;
	sh:constraint [
		...
	] .</pre>
					</section>
					<section id="InversePropertyScope">
						<h5>Inverse property scopes (sh:InversePropertyScope)</h5>
						<p>
							The scope class <code>sh:InversePropertyScope</code> selects all objects that appear in at least one triple with a given property <code>sh:predicate</code>.
						</p>
						<p>See also: <a href="../shacl-ref/#InversePropertyScope">Definition in SPARQL</a>.</p>
					</section>
					<section id="AllSubjectsScope">
						<h5>All subjects scopes (sh:AllSubjectsScope)</h5>
						<p>
							The scope class <code>sh:AllSubjectsScope</code> selects all subjects in the given graph.
						</p>
						<p>See also: <a href="../shacl-ref/#AllSubjectsScope">Definition in SPARQL</a>.</p>
						<p>
							The following example uses <code>sh:AllSubjectsScope</code> to define a constraint that shall apply to all subjects in the current graph:
						</p>
						<pre class="example" title="Shape with sh:AllSubjectsScope">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:AllSubjectsScope ;
	] ;
	sh:constraint [
		...
	] .</pre>
					</section>
					<section id="AllObjectsScope">
						<h5>All objects scopes (sh:AllObjectsScope)</h5>
						<p>
							The scope class <code>sh:AllObjectsScope</code> selects all objects in the given graph, unless they are literals.
						</p>
						<p>See also: <a href="../shacl-ref/#AllObjectsScope">Definition in SPARQL</a>.</p>
					</section>
				</section>
				
			</section>
			
			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					In some cases, constraints or shapes should not apply to all focus nodes, produced by a scope.
					For example, instances of the given class <code>ex:Person</code> that were <code>ex:bornIn</code>
					the country <code>ex:USA</code> may have a different legal drinking age than others.
					In order to support such use cases, SHACL includes the concept of <span class="term">filter shapes</span> that act as pre-conditions that all focus nodes need to fulfill before they are being validated.
					Formally, filter shapes eliminate entries from the collection of focus nodes selected by a shape's scopes, if the focus node produces an error-level validation result for the given filter shapes.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint only applies to resources that have a certain value for <code>ex:requiredProperty</code>. 
				</p>
				<pre class="example" title="Constraint with a filter shape">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:filterShape [
			a sh:Shape ; # Optional triple
			sh:property [
				sh:predicate ex:requiredProperty ;
				sh:hasValue ex:requiredValue ;
			]
		] ;
	] .

ex:FilteredShapeValidExampleInstance
	ex:someProperty ex:someValue ;
	ex:requiredProperty ex:requiredValue .</pre>
			<p>
				Alternatively, <code>sh:filterShape</code> can be defined for a whole shape, with the meaning
				that the filter applies to all constraints defined by the shape, as shown in the following example.
			</p>
			<pre class="example" title="Shape with a filter shape">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:filterShape [
		sh:property [
			sh:predicate ex:requiredProperty ;
			sh:hasValue ex:requiredValue ;
		]
	] ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
	] .

ex:FilteredShapeValidExampleInstance
	ex:someProperty ex:someValue ;
	ex:requiredProperty ex:requiredValue .</pre>
			</section>
		</section>
		
		<section id="results">
			<h2>Validation Results Vocabulary</h2>
			<p>
				The output of a SHACL constraint validation operation is a set of <span class="term">validation results</span>.
				SHACL includes an RDF vocabulary to represent such results together with
				structural information that may provide guidance on how to fix a violation, as well as
				human-readable messages.
			</p>
			<div class="issue" data-number="51" title="Result types">
				This vocabulary is likely going to change once the WG resolves ISSUE-51 and ISSUE-75.
			</div>
			<p>
				The following code snippet represents a syntactically correct result that may have been produced by a constraint validation engine:
			</p>
			<pre class="example" title="A constructed constraint violation">
ex:ExampleConstraintViolation
	a sh:Error ;
	sh:root ex:MyCurrentNode ;
	sh:subject ex:MyCurrentNode ;
	sh:predicate ex:someProperty ;
	sh:object ex:someInvalidValue ;
	sh:message "Incorrect value: expected something else here." .</pre>
			<section id="results-types">
				<h3>Types of Validation Results</h3>
				<p>
					A validation result is represented by a IRI or blank node that has exactly one asserted <code>rdf:type</code>.
					The <code>rdf:type</code> arc of a result must point to one of the subclasses of the ("abstract") base class <code>sh:Result</code>.
					The SHACL system vocabulary includes the following result types: 
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Validation&nbsp;Result&nbsp;Class</th>
						<th>Superclass</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:Info</code></td>
						<td><code>sh:Result</code></td>
						<td>An informative message, not a violation.</td>
					</tr>
					<tr>
						<td><code>sh:Warning</code></td>
						<td><code>sh:ConstraintViolation</code></td>
						<td>A non-critical constraint violation indicating a warning.</td>
					</tr>
					<tr>
						<td><code>sh:Error</code></td>
						<td><code>sh:ConstraintViolation</code></td>
						<td>A constraint violation indicating an error.</td>
					</tr>
					<tr>
						<td><code>sh:FatalError</code></td>
						<td><code>sh:Error</code></td>
						<td>
							An error that cannot be recovered and further validation may terminate immediately.
							Engines may decide to validate potentially fatal constraints first.
						</td>
					</tr>
				</table>
				<p>
					SHACL extensions may define additional result types, as long as they are rooted in
					<code>sh:Result</code>.
					The <code>rdfs:subClassOf</code> relationship between these types indicates specialization,
					e.g. <code>sh:FatalError</code> is a subclass of <code>sh:Error</code> meaning that every
					fatal error should also be regarded as an error.
				</p>
			</section>
			<section id="results-structure">
				<h3>Structural Result Metadata</h3>
				<p>
					SHACL validation results may include machine-readable metadata that points at
					the cause of the result.
				</p>
				<section id="results-structure-root">
					<h4>sh:root</h4>
					<p>
						Validation results may have a single value for the property <code>sh:root</code> to point to an
						IRI or blank node that has caused the result.
						If the result has been produced by a shape constraint, then the <code>sh:root</code> is usually the <span class="term">focus node</span>.
					</p>
				</section>
				<section id="results-structure-triple">
					<h4>sh:subject, sh:predicate and sh:object</h4>
					<p>
						Validation results are often caused by a single RDF triple, or a predicate in the context of a given subject or object.
						This information can be encoded via the properties <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>,
						each of which can have at most one value.
						<code>sh:predicate</code> can only be present if either <code>sh:subject</code> or <code>sh:object</code> have also been specified.
						If <code>sh:object</code> is unspecified, then the interpretation is that the error is caused by the subject/predicate combination.
						If <code>sh:subject</code> is unspecified, then the interpretation is that the error is caused by the object/predicate combination.
					</p>
				</section>
				<section id="results-structure-source">
					<h4>sh:sourceConstraint and sh:sourceShape</h4>
					<p>
						Validation results may point at one <code>sh:Constraint</code> that has caused
						the result, specified via the property <code>sh:sourceShape</code>,
						and at the <code>sh:Shape</code> defining the constraint, via <code>sh:sourceShape</code>.
					</p>
				</section>
				<section id="results-structure-detail">
					<h4>sh:detail</h4>
					<p>
						The property <code>sh:detail</code> may link a (parent) result with one or more other
						(child) results that provide further details about the cause of the (parent) result.
						Depending on the capabilities of the constraint validation engine, this may include failures of
						nested constraints that have been validated via <code>sh:valueShape</code>.
					</p>
				</section>
			</section>
			<section id="results-message">
				<h3>Human-readable Messages (sh:message)</h3>
				<p>
					Validation results may have values for the property <code>sh:message</code> to communicate
					additional textual details to humans.
					While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
				</p>
			</section>
			<section id="severity">
				<h3>Declaring the Severity of a Constraint (sh:severity)</h3>
				<p>
					Constraints can specify their severity level using the property <code>sh:severity</code>,
					which must point at one of the severity types.  <code>sh:Error</code> is the default if unspecified.
					Constraints based on templates use the <code>sh:severity</code> declared at the template itself unless overridden at the constraint.
					The following example clarifies this.
				</p>
				<pre class="example" title="Declaring the Severity using sh:severity">
ex:MyShape
	a sh:Shape ;
	sh:property [
		# Violations of either minCount and datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# Violation of maxCount are produced as errors (which is the default for sh:maxCount)
		sh:predicate ex:myProperty ;
		sh:maxCount 1 ;
	] ;
.</pre>
			</section>
		</section>
		
		<section id="general-constraints">
			<h2>General Shape Constraints (sh:constraint)</h2>
			<p>
				Note that the subsequent sections cover features of SHACL that go beyond the <span class="term">SHACL Core Profile</span>.
			</p>
			<p>
				The property <code>sh:constraint</code> provides the most general mechanism to associate a constraint with a shape.
				The values of this property must be <span class="term">constraints</span>, i.e. they MAY reference a <span class="term">focus node</span>.
				Note that the property <code>sh:property</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:PropertyConstraint</code>.
				The property <code>sh:inverseProperty</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:InversePropertyConstraint</code>.
			</p>
			<p>
				SHACL supports two types of general shape constraints:
			</p>
			<ul>
				<li>General shape constraints based on a high-level vocabulary (template)</li>
				<li>General shape constraints based on a native executable (such as a SPARQL query)</li>
			</ul>
			<p>
				The following example assumes that there is a high-level template called <code>myt:DisjointPropertiesConstraint</code> that takes two arguments
				<code>myt:property1</code> and <code>myt:property2</code>.
				The intent of that example is to state that the values of the properties <code>ex:father</code> and <code>ex:mother</code> must be disjoint.
			</p>
			<pre class="example">
@prefix myt: &lt;http://example.org/myTemplates#&gt; .

ex:GeneralTemplateConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		a myt:DisjointPropertiesConstraint ;
		myt:property1 ex:father ;
		myt:property2 ex:mother ;
	] .</pre>
			<p>
				The following example illustrates the definition of a <span class="term">constraint</span> based on a SPARQL query.
				The property <code>sh:sparql</code> is used to point at a SELECT query as explained in a later <a href="#sparql-constraints">section</a>.
				Note that the variable <code>?this</code> is used to reference the <span class="term">focus node</span>.
			</p>
			<pre class="example">
ex:GeneralSPARQLConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:message "The value of property2 cannot be smaller than the value of property1." ;
		sh:predicate ex:property2 ;
		sh:sparql """
			SELECT ?this (?this AS ?subject) (?value2 AS ?object)
			WHERE {
				?this ex:property1 ?value1 .
				?this ex:property2 ?value2 .
				FILTER (?value2 &lt; ?value1) .
			}
			""" ;
	] .</pre>
			<p>
				In the example above, SPARQL is provided as the only native executable.
				However, additional executables such as JavaScript may be provided based on other sets of properties like <code>ex:javaScript</code>.
			</p>
			<section id="graph-constraints">
				<h3>Graph-level ("global") Constraints</h3>
				<p>
					In some cases, constraints are not naturally associated with individual focus nodes, but need to be enforced upon a whole graph.
					The following example illustrates one way of representing such conditions, by associating a shape with the graph resource itself, via <code>sh:nodeShape</code>.
					The constraint expresses that the graph must contain at least one instance of a given class.
					Note that the constraint itself does not reference the <span class="term">focus node</span> <code>?this</code> at all.
				</p>
				<pre class="example" title="Graph-level Constraint">
&lt;http://example.org/exampleGraph&gt;
	a rdfs:Resource ;       # TODO: better would be sh:Graph if that's approved
	sh:nodeShape [
		sh:constraint [
			sh:message "There needs to be at least one instance of ex:SomeClass." ;
			sh:sparql """
				SELECT (ex:SomeClass AS ?this)
				WHERE {
					FILTER NOT EXISTS { ?any rdf:type ex:SomeClass } .
				} """
		]
	] .</pre>
				<p>
					Another common scenario is to enforce constraints on all usages of a given property, regardless of the specific subjects.
					This can be achieved through the scope template <code>sh:PropertyScope</code>.
					In the following example, the property <code>ex:globalProperty</code> is globally expected to have integer values
					and can only be used once per subject:
				</p>
				<pre class="example" title="Global property constraint">
ex:GlobalPropertyShape
	a sh:Shape ;
	sh:scope [
		a sh:PropertyScope ;
		sh:predicate ex:globalProperty ;
	] ;
	sh:property [
		sh:predicate ex:globalProperty ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
		rdfs:label "global property" ;
	] .
</pre>
			</section>
		</section>
		
		<section id="templates">
			<h2>Templates</h2>
			<p>
				Templates can be used to encapsulate and parameterize <span class="term">executable bodies</span> based on arguments.
				Constraint templates can be instantiated anywhere where a native constraint may appear (for example, at <code>sh:constraint</code>).
				Scope templates can be instantiated anywhere where a native scope may appear, at <code>sh:scope</code>.
				SHACL includes several templates that were deemed to be of general use, including the <a href="#shapeconstraints-property">property constraint templates</a>.
				Such templates form a high-level vocabulary that may be directly interpreted ("hard-coded") without reliance on their executable bodies.
			</p>
			<p>
				Constraint templates are represented as IRI nodes that are instances of the class <code>sh:ConstraintTemplate</code>.
				Scope templates are represented as IRI nodes that are instances of the class <code>sh:ScopeTemplate</code>.
				SHACL also includes a more general superclass <code>sh:Template</code> that may be used for other kinds of templates (rules, stored queries etc).
				Well-defined, non-abstract templates MUST provide at least one executable body property using a property such as <a href="#sparql-templates"><code>sh:sparql</code></a>.
				The following example illustrates the definition of a constraint template based on a SPARQL query.
			</p>
			<pre class="example" title="Constraint template based on SPARQL">
ex:ExampleTemplate
	a sh:ConstraintTemplate ;
	rdfs:subClassOf sh:TemplateConstraint ;
	rdfs:label "Example Template" ;
	rdfs:comment "Verifies that the given focus node (?this) has at least one value for the argument property (?argProperty)." ;
	sh:argument [
		sh:predicate ex:argProperty ;
		sh:valueClass rdf:Property ;
	] ;
	sh:labelTemplate "The property {?argProperty} must have at least one value" ;
	sh:sparql """
		SELECT ?this (?this AS ?subject) (?argProperty AS ?predicate) 
		WHERE {
			FILTER NOT EXISTS { ?this ?argProperty ?anyValue }
		}
		""" .</pre>
			<p>
				The following sections introduce the properties that such templates may have.
				A later <a href="#sparql-templates">section</a> provides additional details for SPARQL-based SHACL templates.
			</p>
			<section id="template-arguments">
				<h3>Template Arguments</h3>
				<p>
					The arguments of a template are linked via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>.
					The <code>rdf:type</code> triple of the argument can be omitted if it is a blank node with an incoming <code>sh:argument</code> triple.
				</p>
				<p>
					Each <code>sh:Argument</code> MUST have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs.
					<span id="def-local-name">The <span class="term">local name</span> of a IRI is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the IRI, not immediately preceeded by the first colon in the IRI.</span>
					The local names of the values of <code>sh:predicate</code> must fulfill the following conditions (to ensure a correct mapping from arguments into SPARQL variables is possible):
				</p>
				<ul>
					<li>The <span class="term">local name</span> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Argument</code> for the same template (and its transitive superclasses) that has a <code>sh:predicate</code> with the same <span class="term">local name</span></li>
				</ul>
				<p>
					An <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
				</p>
				<p>
					An <code>sh:Argument</code> may declare a default value via <code>sh:defaultValue</code>.
					For non-optional arguments, the engine must use the declared default value for template instances that do not define a value for this argument.
					Template instances can have at most one value for each argument predicate.
				</p>
				<p>
					An <code>sh:Argument</code> may declare one value for the property <code>sh:valueClass</code> or one value for
					<code>sh:datatype</code>, similar to their counterparts in property constraints.
					This can be used to communicate the expected value type of the argument in template instances.
					Some implementations MAY use this information to prevent the execution of a template with invalid arguments, and to signal errors.
				</p>
			</section>
			<section id="template-labelTemplate">
				<h3>sh:labelTemplate</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used to suggest how instances of the template shall be rendered to humans.
					The <code>sh:labelTemplate</code> must be a string that can reference the arguments using the syntax <code>{?varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the argument.
					These <code>{?...}</code> blocks SHOULD be substituted with the actual values used in the template instance.
				</p>
			</section>
			<section id="template-validation-functions">
				<h3>Templates with a sh:validationFunction</h3>
				<p>
					Constraint templates that are instances of <code>sh:PropertyValueConstraintTemplate</code> or
					<code>sh:InversePropertyValueConstraintTemplate</code> do not require an executable body (such a <code>sh:sparql</code>)
					if they instead point at a <code>sh:Function</code> via the property <code>sh:validationFunction</code>.
					These so called <span class="term">validation functions</span> MUST take an argument with the predicate <code>sh:value</code> as its first argument
					and return either <code>true</code> or <code>false</code>.
					This validation function MUST be used by a constraint validation engine to construct a procedure that iterates over all values of the (possibly inverse) property,
					and then runs a filter test using the function.  If the filter returns <code>false</code> then a validation result must be produced.
					Validation functions may take additional arguments, and the engine must fill them with the matching arguments from the surrounding template.
					The SHACL system vocabulary contains several examples of such validation functions, e.g. <code>sh:AbstractDatatypePropertyConstraint</code>.
				</p>
			</section>
		</section>
		
		<section id="general-scopes">
			<h2>General Scopes (sh:scope)</h2>
			<p>
				In addition to the scope classes introduced in the core section, such as <code>sh:PropertyScope</code>,
				SHACL provides facilities for anyone to define custom scopes.
				Scopes may either have a native executable body or be an instance of <code>sh:TemplateScope</code>.
				All this is analogous to how constraints work, but with the additional restrictions:
			</p>
			<ul>
				<li>All subjects of <code>sh:scope</code> triples must be IRIs</li>
				<li>The arguments of a scope template must not be blank nodes</li>
			</ul>
			<p class="todo">
				TODO: Maybe include an example of a user-defined scope template and how it is used.
			</p>
		</section>

		<section id="profiles">
			<h2>Profiles</h2>
			<p>
				A Profile is a set of templates.
				Profiles can be used to define controlled sub-dialects of SHACL, e.g. with desirable complexity.
				Tools may decide to only support certain profiles, for example so that they can hard-code and optimize certain algorithms.
				Since Profiles are entirely based on templates, <span class="term">native constraints and scopes</span> such as those in SPARQL are outside of their expressivity.
			</p>
			<p>
				The class <code>sh:Profile</code> is used to represent SHACL profiles.
				The properties <code>sh:constraintTemplate</code> and <code>sh:scopeTemplate</code> link a <code>sh:Profile</code> with the templates that are in the profile.
				The following example defines a profile consisting of the two SHACL templates for min/max cardinality and value shape,
				as well as their shared superclass (which defines the <code>sh:predicate</code> property) and their shared subclass
				<code>sh:PropertyConstraint</code> that is directly instantiated.
			</p>
			<pre class="example" title="Simple SHACL Profile">
ex:MyProfile
	a sh:Profile ;
	sh:constraintTemplate sh:AbstractPropertyConstraint ;
	sh:constraintTemplate sh:AbstractCountPropertyConstraint ;
	sh:constraintTemplate sh:AbstractValueShapePropertyConstraint ;
	sh:constraintTemplate sh:PropertyConstraint ;
	sh:scopeTemplate sh:PropertyScope .</pre>
			<p>
				In the example above, the profile includes only the properties from the enumerated template classes.
				Sibling template classes such as <code>sh:AbstractAllowedValuesPropertyConstraint</code> are outside of the profile,
				which means that <code>sh:allowedValues</code> would be out of scope for this profile.
			</p>
			<p>
				SHACL includes a profile called <code>sh:CoreProfile</code> that includes all <a href="#property-constraints">property constraint templates</a>
				as well as the logical operators such as <a href="#or">or</a> and <a href="#ClosedShape">closed shapes</a>. 
			</p>
			<p>
				Profiles can extend each other using the property <code>sh:extends</code>.
				Such profiles include all templates from the profiles that they (transitively) extend.
			</p>
		</section>

		<section id="operations">
			<h2>Supported Operations</h2>
			<p>
				This section enumerates the basic operations that complete SHACL engines SHOULD support.
				The specification does not prescribe how these operations are exposed to the user of a SHACL system.
				The following table provides an overview of the operations and how they depend on each other.
			</p>
			<table class="term-table" border="1" cellpadding="5">
				<tr>
					<th>Operation</th>
					<th>Depends&nbsp;On</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><a href="#operation-validateConstraint"><code>validateConstraint</code></a></td>
					<td></td>
					<td>Validates a single constraint</td>
				</tr>
				<tr>
					<td><a href="#operation-validateNodeAgainstShape"><code>validateNodeAgainstShape</code></a></td>
					<td><code>validateConstraint</code></td>
					<td>Validates a given node against a given shape</td>
				</tr>
				<tr>
					<td><a href="#operation-validateNode"><code>validateNode</code></a></td>
					<td><code>validateNodeAgainstShape</code></td>
					<td>Validates a given node against the shapes derived from the graph</td>
				</tr>
				<tr>
					<td><a href="#operation-validateGraph"><code>validateGraph</code></a></td>
					<td><code>validateNode</code>, <code>validateConstraint</code></td>
					<td>Validates all nodes in a graph</td>
				</tr>
			</table>
			<p>
				All operations produce <span class="term">validation results</span>.
				For the sake of this specification, we assume that the validation results are represented as instances of
				subclasses of <code>sh:Result</code> that are added to a <span class="term">result graph</span> which is known
				to each operation for the duration of its execution.
				Actual implementations may use different data structures and result formats and input and output to these operations.
			</p>
			<p class="todo">
				All operations have an implicit argument, which is a data set with a default named graph.
				Details of this need to be fleshed out, pending design decisions on general graph management.
			</p>
			<p>
				The SHACL specification supports an open architecture consisting of <a href="#execution-languages">Execution Languages</a>
				that serve as work-horses of the individual constraints.
				The constraint validation operations rely on functions provided by these <span class="term">execution languages</span>.
			</p>
			<section id="operation-validateConstraint">
				<h3>validateConstraint</h3>
				<p>
					This operation validates a single <span class="term">constraint</span> and produces <span class="term">validation results</span>. 
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>?constraint</code></td>
						<td><code>sh:Constraint</code></td>
						<td>The <span class="term">constraint</span> to validate</td>
					</tr>
					<tr>
						<td><code>?shape</code></td>
						<td><code>sh:Shape</code></td>
						<td>The <span class="term">shape</span> containing the constraint</td>
					</tr>
					<tr>
						<td><code>?focusNode</code></td>
						<td><code>rdfs:Resource</code></td>
						<td>The <span class="term">focus node</span></td>
					</tr>
				</table>
				<p>
					This operation assumes that the <code>?constraint</code> is either a <span class="term">native constraint</span>
					or a <span class="term">template constraint</span>.
					For template constraints, the algorithm will execute the constraint template itself plus all of its superclasses.
				</p>
				<p class="todo">
					The following algorithm needs to clarify under which condition a template instance is complete.
					It is complete when all non-optional arguments have been supplied.
					If a template is <code>sh:abstract</code> and takes at least one argument then it must only be
					executed if at least one argument has a value (or a default value) - this is needed for example
					for sh:minLength/sh:maxLength, both of which are optional.
				</p>
				<pre class="algorithm">
if (?constraint instanceOf sh:NativeConstraint)
	let el := an execution language where el.canExecuteConstraint(?constraint) = true
	el.executeConstraint(?constraint, null, ?shape, ?focusNode)
else
	forEach ?template := (?constraint rdf:type ?type . ?type rdfs:subClassOf* ?template)
		let el := an execution language where el.canExecuteConstraint(?constraint, ?template) = true
		el.executeConstraint(?constraint, ?template, ?shape, ?focusNode)</pre>
			</section>
			<section id="operation-validateNodeAgainstShape">
				<h3>validateNodeAgainstShape</h3>
				<p>
					This operation validates a single <span class="term">node</span> against all constraints associated with a given shape.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>?focusNode</code></td>
						<td><code>rdfs:Resource</code></td>
						<td>The <span class="term">focus node</span> to validate</td>
					</tr>
					<tr>
						<td><code>?shape</code></td>
						<td><code>sh:Shape</code></td>
						<td>The <span class="term">shape</span> that has the constraints.</td>
					</tr>
					<tr>
						<td><code>?minSeverity</code></td>
						<td><code>rdfs:Class</code></td>
						<td>The minimum severity class, e.g. <code>sh:Error</code> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<p>
					Algorithm in pseudo-code:
				</p>
				<pre class="algorithm">
if (validateNode(?focusNode, ?filterShape, sh:Error) produces the empty set for all declared sh:filterShapes of ?shape)
	forEach ?constraint := (?shape sh:constraint|sh:property|sh:inverseProperty|sh:argument ?constraint)
		if (declared sh:severity of ?constraint is at least ?minSeverity)
			if (validateNode(?focusNode, ?filterShape, sh:Error) produces the empty set for all declared sh:filterShapes of ?constraint)
				validateConstraint(?constraint, ?shape, ?focusNode)</pre>
			</section>
			<section id="operation-validateNode">
				<h3>validateNode</h3>
				<p>
					This operation validates a single <span class="term">node</span> against all shapes associated with it, based on in-graph mappings.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>?focusNode</code></td>
						<td><code>rdfs:Resource</code></td>
						<td>The <span class="term">focus node</span> to validate</td>
					</tr>
					<tr>
						<td><code>?minSeverity</code></td>
						<td><code>rdfs:Class</code></td>
						<td>The minimum severity class, e.g. <code>sh:Error</code> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<p>
					Algorithm in pseudo-code:
				</p>
				<pre class="algorithm">
forEach ?shape := getShapes(?focusNode)
	validateNodeAgainstShape(?focusNode, ?shape, ?minSeverity)</pre>
				<p>
					where the helper function <code>getShapes</code> produces a set of shapes as follows:
				</p>
				<pre class="algorithm">
forEach ?shape := (?focusNode sh:nodeShape ?shape)
	add(?shape) 

forEach ?type := (?focusNode rdf:type/rdfs:subClassOf* ?type)
	if (?type instanceof sh:Shape)
		add(?type)
	forEach ?shape := (?shape sh:scopeClass ?type)
		add(?shape)
		
forEach ?shape, ?scope := (?shape sh:scope ?scope)
	let el := an execution language where el.canExecuteScope(?scope) = true
	if (el.isNodeInScope(?scope, ?focusNode)
		add(?shape)</pre>
			</section>
			<section id="operation-validateGraph">
				<h3>validateGraph</h3>
				<p>
					This operation validates a whole graph against all shapes associated with its resources, based on in-graph scopes.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<td><code>?minSeverity</code></td>
						<td><code>rdfs:Class</code></td>
						<td>The minimum severity class, e.g. <code>sh:Error</code> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<p>
					Algorithm in pseudo-code (note that the algorithm as written here would be hopelessly inefficient if implemented literally - actual implementations can select shapes and their scopes together and then call <code>validateNodeAgainstShape</code> much more efficiently):
				</p>
				<pre>
forEach ?focusNode := collectNodes()
	validateNode(?focusNode, ?minSeverity)</pre>
				<p>
					where the helper function <code>collectNodes</code> produces a set of focus nodes as follows:
				</p>
				<pre class="algorithm">
forEach ?focusNode := (?focusNode sh:nodeShape ?anyShape)
	add(?focusNode) 

forEach ?focusNode := (?focusNode rdf:type ?anyClass) where ?anyClass instanceOf sh:Shape
	add(?focusNode)

forEach ?focusNode := (?focusNode rdf:type ?anyClass) where exists (?anyShape sh:scopeClass ?anyClass)
	add(?focusNode)

forEach ?scope := (?shape sh:scope ?scope)
	let el := an execution language where el.canExecuteScope(?scope) = true
	forEach ?focusNode := el.executeScope(?scope)
		add(?focusNode)</pre>
   			</section>
			<section id="execution-languages">
				<h3>Execution Languages</h3>
				<p>
					The SHACL operations assume a <span class="term">registry</span> of known execution languages, such as SPARQL.
					This registry SHOULD include one or more <span class="term">execution languages</span>, implemented via an interface with the following functions.
					The SHACL engine must select a suitable execution language from the registry for each constraint, function and scope that it encounters, using the provided <code>can..</code> functions.
					<span class="todo">Clarify what needs to happen if no suitable language is found: fail gracefully or fatal error.</span> 
				</p>
				<pre class="algorithm">
interface ExecutionLanguage {

	<a href="#canExecuteConstraint">canExecuteConstraint</a>() : boolean
	<a href="#executeConstraint">executeConstraint</a>() : void

	<a href="#canExecuteScope">canExecuteScope</a>() : boolean
	<a href="#executeScope">executeScope</a>() : RDF node[]
	<a href="#isNodeInScope">isNodeInScope</a>() : boolean

	<a href="#canExecuteFunction">canExecuteFunction</a>() : boolean
	<a href="#executeFunction">executeFunction</a>() : RDF node
}</pre>
				<section id="canExecuteConstraint">
					<h3>canExecuteConstraint</h3>
					<p>
						This operation tests whether the given execution language can execute a given constraint, returning either <code>true</code> or <code>false</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">?constraint</code></td>
							<td><code>sh:Constraint</code></td>
							<td>The <span class="term">constraint</span> to execute</td>
						</tr>
						<tr>
							<td><code>?template</code></td>
							<td><code>sh:ConstraintTemplate</code></td>
							<td>Optional, only given if <code>?constraint</code> is a template constraint. The <span class="term">template</span> to execute (possibly a super-class of the directly instantiated template).</td>
						</tr>
					</table>
				</section>
				<section id="executeConstraint">
					<h3>executeConstraint</h3>
					<p>
						This operation executes a given constraint and adds any results into the current results graph.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">?constraint</code></td>
							<td><code>sh:Constraint</code></td>
							<td>The <span class="term">constraint</span> to execute</td>
						</tr>
						<tr>
							<td><code>?template</code></td>
							<td><code>sh:ConstraintTemplate</code></td>
							<td>Optional, only given if <code>?constraint</code> is a template constraint. The <span class="term">template</span> to execute (possibly a super-class of the directly instantiated template).</td>
						</tr>
						<tr>
							<td><code>?shape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The <span class="term">shape</span> containing the constraint</td>
						</tr>
						<tr>
							<td><code>?focusNode</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The focus node.</td>
						</tr>
					</table>
					<p>
						Calling this function is only supported if a prior call to <code>canExecuteConstraint</code> has returned <code>true</code> for the same arguments.
					</p>
				</section>
				<section id="canExecuteScope">
					<h3>canExecuteScope</h3>
					<p>
						This operation tests whether the given execution language can execute a given scope, returning either <code>true</code> or <code>false</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?scope</code></td>
							<td><code>sh:Scope</code></td>
							<td>The <span class="term">scope</span> to execute (may be a template scope)</td>
						</tr>
					</table>
				</section>
				<section id="executeScope">
					<h3>executeScope</h3>
					<p>
						This operation gets all nodes from a given scope.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?scope</code></td>
							<td><code>sh:Scope</code></td>
							<td>The <span class="term">scope</span> (may be a template scope)</td>
						</tr>
					</table>
				</section>
				<section id="isNodeInScope">
					<h3>isNodeInScope</h3>
					<p>
						This operation tests whether a given focus node is within a given scope, returning either <code>true</code> or <code>false</code>.
						<code>isNodeInScope</code> must return true for exactly the nodes that are produced by <code>executeScope</code> with the same scope argument.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?focusNode</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The <span class="term">focus node</span> to test</td>
						</tr>
						<tr>
							<td><code>?scope</code></td>
							<td><code>sh:Scope</code></td>
							<td>The <span class="term">scope</span> to test (may be a template scope)</td>
						</tr>
					</table>
				</section>
				<section id="canExecuteFunction">
					<h3>canExecuteFunction</h3>
					<p>
						This operation tests whether the given execution language can execute a given function, returning either <code>true</code> or <code>false</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?function</code></td>
							<td><code>sh:Function</code></td>
							<td>The <span class="term">function</span> to execute (must be a IRI).</td>
						</tr>
					</table>
				</section>
				<section id="executeFunction">
					<h3>executeFunction</h3>
					<p>
						This operation executes a given function with a list of arguments and returns a result node or an error.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?function</code></td>
							<td><code>sh:Function</code></td>
							<td>The <span class="term">function</span> to execute (must be a IRI).</td>
						</tr>
						<tr>
							<td><code>?arg1</code>, <code>?arg2</code>, ...</td>
							<td>RDF node</td>
							<td>The arguments.</td>
						</tr>
					</table>
				</section>
			</section>
			<section id="defaultValueType">
				<h2>Validation of shapes graphs and the sh:defaultValueType property</h2>
				<div class="issue" data-number="70" title="Special treatment of blank node types">
					This paragraph is one possible resolution to ISSUE-70.
					The proposal has not been discussed in the WG yet.
				</div>
				<p>
					The SHACL system vocabulary itself is using shapes, allowing SHACL constraint validation to be executed on shapes graphs, e.g. to validate the syntax of shape definitions.
					However, some system properties such as <code>sh:property</code>, <code>sh:filterShape</code> and <code>sh:argument</code> may have untyped blank nodes as their values.
					If, for example, a value of <code>sh:property</code> is a blank node that does not have any <code>rdf:type</code>, then the assumption is that the blank node has type <code>sh:PropertyConstraint</code>.
					Unless these implicit triples are present in the query graph, constraint validation will not apply the constraints defined for <code>sh:PropertyConstraint</code>.
				</p>
				<p>
					If an engine intends to validate the syntax of a SHACL shapes graph itself, it should (temporarily) add the missing <code>rdf:type</code> triples.
					The SHACL system vocabulary includes some helper triples using the predicate <code>sh:defaultValueType</code> to specify the default <code>rdf:type</code> for certain properties.
					For example, the default value type of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
					These triples can be queried by a pre-processor to construct the missing type triples for the affected blank nodes.
					SHACL includes a template <code>sh:DefaultValueTypeRule</code> which encapsulates a SPARQL query that can be used for that purpose:
				</p>
				<pre class="query">
CONSTRUCT {
	?blankNode a ?defaultValueType .
}
WHERE {
	?predicate sh:defaultValueType ?defaultValueType .
	?anySubject ?predicate ?blankNode .
	FILTER (isBlank(?blankNode) &amp;&amp; NOT EXISTS { ?blankNode a ?anyType }) .
}</pre>
			</section>
		</section>
		
		<section id="functions">
			<h2>Functions</h2>
			<p>
				SHACL <span class="term">functions</span> define operations that produce an RDF node based on arguments.
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<p>
				Functions must be declared as instances of the class <code>sh:Function</code>.
				Well-defined, non-abstract functions MUST provide at least one executable body property such as <a href="#sparql-functions"><code>sh:sparql</code></a> so that one of the registered <span class="term">execution languages</span> return <code>true</code> for <code>canExecutionFunction()</code>.
				The following example illustrates the definition of a <span class="term">function</span> based on a SPARQL query.
			</p>
			<pre class="example" title="SHACL function with a SPARQL body">
# Example call: ex:exampleFunction(4, 3) returns 7
ex:exampleFunction
	a sh:Function ;
	rdfs:comment "Computes the sum of its two arguments ?arg1 and ?arg2." ;
	sh:returnType xsd:integer ;
	sh:argument [
		sh:predicate sh:arg1 ;
		sh:datatype xsd:integer ;
		rdfs:comment "The first operand" ;
	] ;
	sh:argument [
		sh:predicate sh:arg2 ;
		sh:datatype xsd:integer ;
		rdfs:comment "The second operand" ;
	] ;
	sh:sparql """
		SELECT (?arg1 + ?arg2 AS ?result)
		WHERE {
		}
		""" .</pre>
			<p>
				The following sections introduce the properties that such functions may have.
				A later <a href="#sparql-functions">section</a> provides additional details for SPARQL-based SHACL functions.
			</p>
			<section id="function-arguments">
				<h3>Function Arguments</h3>
				<p>
					The arguments of a function are linked to its <code>sh:Function</code> via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>.
					The <code>rdf:type</code> triple of the argument can be omitted if it is a blank node with an incoming <code>sh:argument</code> triple.
					Arguments are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?arg1, ?arg2)</code>.
				</p>
				<p>
					Each <code>sh:Argument</code> MUST have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs, and follow the same restrictions outlined for <a href="#template-arguments">Template Arguments</a>.
					Arguments are "inherited" from the superclasses of the function.
					For example if a superclass already declares <code>sh:arg1</code> then subclasses may only define <code>sh:arg2</code> etc.
				</p>
				<p id="function-arguments-ordering">
					The ordering of function arguments (e.g. for printing in SPARQL strings) is determined by their index.
					For each function, the indices must be 0, 1, 2 etc.  The index of each declared <code>sh:Argument</code>
					is determined as follows:
				</p>
				<ol>
					<li>The index of the built-in argument predicates <code>sh:arg1</code>, <code>sh:arg2</code> etc is their numeric name part minus 1, e.g. <code>sh:arg1</code> has index 0.</li>
					<li>The index of other argument predicates is the value of the property <code>sh:index</code> at the surrounding <code>sh:Argument</code>.</li>
					<li>The default index for all other cases is the number of other arguments. This means that non-built-in arguments without a <code>sh:index</code> will be placed at the end of the order.</li>
				</ol>
				<p>
					Each <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
					If an argument has been declared optional, then all succeeding arguments must also be declared optional.
				</p>
				<p>
					Similar to <a href="#property-constraints">Property Constraints</a>, each <code>sh:Argument</code> may declare one value for the property <code>sh:datatype</code> or one value for the property <code>sh:valueClass</code>.
					This can be used to communicate the expected value type of the argument in function calls.
					Some implementations MAY use this information to prevent the execution of a function with invalid arguments, and to signal errors.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					the engine how to cast a native value into an RDF value type.
				</p>
			</section>
			<section id="function-cachable">
				<h3>sh:cachable</h3>
				<p>
					A <code>sh:Function</code> may have a property <code>sh:cachable</code> set to <code>true</code>.
					Functions that are marked as cachable MUST always return the same value for the same combination of arguments, regardless of the query graphs.
					Engines can use this information to cache and reuse previous function calls without repeatedly executing their body.
				</p>
			</section>
		</section>

		<section id="entailment">
			<h3>Entailment</h3>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be actviated on the graph that is queried.
				However, the property <code>sh:entailment</code> can be used to instruct a SHACL engine to ensure that a given entailment is activated.
				The values of <code>sh:entailment</code> must be IRIs, with common use cases covered by [[!sparql11-entailment]].
				The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.
			</p>
			<p>
				If the engine is not capable of supporting the given entailment regime, then it MUST produce a <code>sh:FatalError</code>.
				Standard-compliant SHACL implementations are not required to support any entailment regimes.
			</p>
		</section>

		<section id="sparql">
			<h2>SPARQL-based Execution (sh:sparql)</h2>
			<p>
				The property <code>sh:sparql</code> is used to link constraints, templates and functions with an executable body in SPARQL.
				The values of <code>sh:sparql</code> must be string literals that can be parsed into syntactically valid SPARQL queries.
				Prior to parsing, a SHACL engine MUST add all prefix declarations from the defining graph into the beginning of the string.
				This means that the values of <code>sh:sparql</code> do not have to explicitly state any <code>@prefix</code> declarations for the prefixes used in the SPARQL query.
			</p>
			<p>
				The following sections provide details on how <code>sh:sparql</code> is interpreted for
				<a href="#sparql-constraints">constraints</a>, <a href="#sparql-templates">templates</a> and <a href="#sparql-functions">functions</a>.
			</p>
			<section id="sparql-constraints">
				<h3>SPARQL-based Constraints</h3>
				<p>
					The SPARQL queries linked to a <span class="term">constraint</span> via <code>sh:sparql</code> must be of the query form <code>SELECT</code>.
				</p>
				<section id="sparql-constraints-prebound">
					<h4>Pre-bound Variables in SPARQL Constraints (?this, ?shapesGraph, ?currentShape)</h4>
					<p>
						When SPARQL constraints are executed then the engine will pre-bind values for the following variables
						with special meaning.
						The effect of this pre-binding is that all occurrences of these variables in the top-level query will have the provided
						values, similar to inserting a SPARQL VALUES clause into the beginning of the query, but also supporting blank nodes.
					</p>
					<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
						We need a suitable formal definition of what pre-binding means - the statement above with VALUES may not be entirely correct.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Variable</th>
							<th>Interpretation</th>
						</tr>
						<tr>
							<td><code>?this</code></td>
							<td>
								The <span class="term">focus node</span>.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">?shapesGraph</code></td>
							<td>
								The named graph containing the Shape definitions (and possibly other data).
								Can be used as in <code>GRAPH ?shapesGraph { ... }</code> to query shapes, constraints
								and complex arguments such as <code>rdf:Lists</code>.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">?currentShape</code></td>
							<td>
								The currently validated shape.  Typically used in conjunction with <code>?shapesGraph</code>.
							</td>
						</tr>
					</table>
					<div class="issue" data-number="47" title="Access to ?shapesGraph">
						There is no consensus yet if and under which conditions SPARQL queries can access the shapes graph.
					</div>
				</section>
				<section id="sparql-constraints-variables">
					<h4>Mapping of Result Variables to Validation Results</h4>
					<p>
						Each row of the result set produced by a SELECT query must be converted into one validation result resource.
						The properties of those resources are derived by the following rules, through a combination of result variables and by looking at properties linked to the constraint itself.
						In the following table, the <span class="term">host resource</span> is assumed to be the native constraint or template that has the executed <code>sh:sparql</code> query as one of its properties.
						The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Production Rules</th>
						</tr>
						<tr>
							<td><code>rdf:type</code></td>
							<td>
								<ol>
									<li>For template constraints, the value of <code>sh:severity</code> of the constraint node</li>
									<li>The value of <code>sh:severity</code> of the <span class="term">host resource</span></li>
									<li><code>sh:Error</code> as default</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:root</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?this</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:subject</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?subject</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:predicate</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?predicate</code></li>
									<li>The value of <code>sh:predicate</code> of the <span class="term">host resource</span></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:object</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?object</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:message</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?message</code></li>
									<li>
										The values of <code>sh:message</code> of the <span class="term">host resource</span>.
										These values may reference any variable from the SELECT result variables via <code>{?varName}</code>.
										If the constraint is a template constraint, then the template's argument variables can also be used.
										The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
									</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceConstraint</code></td>
							<td>
								<ol>
									<li>The <span class="term">constraint</span></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceShape</code></td>
							<td>
								<ol>
									<li>The <span class="term">shape</span></li>
								</ol>
							</td>
						</tr>
					</table>
					<p>
						The following example illustrates a constraint that flags warnings for all subjects that have a <code>rdfs:label</code> with the language tag <code>"de"</code>.
					</p>
					<pre class="example" title="Label constraint based on SPARQL SELECT">
ex:ExampleLabelShape
	a sh:Shape ;
	sh:constraint ex:ExampleLabelConstraint .

ex:ExampleLabelConstraint
	a sh:NativeConstraint ;
	sh:message "Deutsch is verboten" ;
	sh:predicate rdfs:label ;
	sh:severity sh:Warning ;
	sh:sparql """
		SELECT ?this ?object
		WHERE {
			?this rdfs:label ?object .
			FILTER (lang(?object) = "de") .
		}
		""" .

ex:Resource1
	rdfs:label "Eins"@de ;
	rdfs:label "Zwei"@de ;
	rdfs:label "Trois"@fr .</pre>
					<p>
						Output created by the example shape above validated against <code>ex:Resource1</code> would be:
					</p>
					<pre class="example" title="Label constraint example result output">
[
	a sh:Warning ;
	sh:subject ex:Resource1 ;
	sh:predicate rdfs:label ;
	sh:object "Eins"@de ;
	sh:message "Deutsch is verboten" ;
	sh:sourceConstraint ex:ExampleLabelConstraint ;
	sh:sourceShape ex:ExampleLabelShape ;
] .
[
	a sh:Warning ;
	sh:subject ex:Resource1 ;
	sh:predicate rdfs:label ;
	sh:object "Zwei"@de ;
	sh:message "Deutsch is verboten" ;
	sh:sourceConstraint ex:ExampleLabelConstraint ;
	sh:sourceShape ex:ExampleLabelShape ;
] .</pre>
				</section>
				<section id="sparql-constraints-annotations">
					<h4>Injecting Annotation Properties into Validation Results</h4>
					<p>
						It is possible to inject additional <span class="term">annotation properties</span> into the resources created for each row of the SELECT result sets.
						Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the host node.
						The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Property</th>
							<th>Value type</th>
							<th>Count</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>sh:annotationProperty</code></td>
							<td><code>rdf:Property</code></td>
							<td><code>1 (mandatory)</code></td>
							<td>The annotation property that shall be set</td>
						</tr>
						<tr>
							<td><code>sh:annotationVarName</code></td>
							<td><code>xsd:string</code></td>
							<td><code>0..1</code></td>
							<td>The name of the SPARQL variable to take the values from</td>
						</tr>
						<tr>
							<td><code>sh:annotationValue</code></td>
							<td></td>
							<td><code>0..unlimited</code></td>
							<td>Constant nodes that shall be used as values</td>
						</tr>
					</table>
					<p>
						If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the engine must copy the bindings for the given variable into the constructed validation results for the same row.
					</p>
					<p>
						The values of <code>sh:annotationProperty</code> MUST NOT be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
					</p>
					<p>
						Here is a slightly complex example, illustrating the use of result annotations.
					</p>
					<pre class="example" title="Constraint with an annotation">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:constraint [
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:predicate ex:property2 ;
		sh:sparql """
				SELECT ?subject (?first AS ?object) ?message ?time
				WHERE {
					?this ex:property1 ?first .
					?subject ex:property2 ?first .
					FILTER isBlank(?value) .
					BIND (CONCAT("The ", "message.") AS ?message) .
					BIND (NOW() AS ?time) .
				}
			""" ;
	] .
	
ex:ExampleRootResource
	sh:nodeShape ex:ShapeWithPathViolationExample ;
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
					<p>
						Which produces the following error resource:
					</p>
					<pre class="example" title="Constraint example result output">
[
	a sh:Error ;
	sh:root ex:ExampleRootResource ;
	sh:subject ex:ExampleValueResource ;
	sh:predicate ex:property2 ;
	sh:object ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:constraint above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
				</section>
			</section>
			<section id="sparql-scopes">
				<h3>SPARQL-based Scopes</h3>
				<p>
					The SPARQL queries linked to a <span class="term">scope</span> via <code>sh:sparql</code> MUST be of the query form <code>SELECT</code>, or a fragment that produces a valid <code>SELECT</code> query if wrapped by <code>SELECT ?this WHERE { ... }</code>.
					The SELECT queries MUST project to the result variable <code>?this</code>.
					The results of execution consists of all distinct bindings for the variable <code>?this</code>.
				</p>
				<p>
					The SELECT queries MUST also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This constraint makes sure that engines can validate whether a given shape applies to a given focus node as part of the <a href="#operation-validateNode">validateNode</a> operation.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based scope that produces all persons born in the USA:
				</p>
				<pre class="example" title="SPARQL-based scope example">
ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		sh:sparql """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	sh:constraint ...</pre>
			</section>
			<section id="sparql-templates">
				<h3>SPARQL-based Templates</h3>
				<p>
					If a <code>sh:Template</code> has a value for <code>sh:sparql</code>, then the corresponding instances need to follow the same execution rules as outlined for <a href="#sparql-constraints">SPARQL-based Constraints</a> and <a href="#sparql-constraints">SPARQL-based Scopes</a>.
					The only difference is that the SPARQL queries need to be executed with additional <span class="term">pre-bound</span> variables, derived from the arguments of the template.
					The names of those variables must match the <a href="#def-local-name"><span class="term">local name</span></a> of the argument predicates, including the arguments defined by any (transitive) superclasses of the template.
					For example, if an argument is represented with the predicate <code>ex:myArgument</code> then the variable <code>?myArgument</code> must be <span class="term">pre-bound</span> with the value of the argument in the template instance.
				</p>
				<p>
					If a <code>sh:PropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="code">
SELECT ?this (?this AS ?subject) ?predicate ?object {+ other variables used in sh:message}
WHERE {
	?this ?predicate ?object .
	FILTER (!{validationFunction}(?object, {+ other matching arguments})) .
}</pre>
				<p>
					If a <code>sh:InversePropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="code">
SELECT ?this ?subject ?predicate (?this AS ?object) {+ other variables used in sh:message}
WHERE {
	?subject ?predicate ?this .
	FILTER (!{validationFunction}(?subject, {+ other matching arguments})) .
}</pre>
			</section>
			<section id="sparql-functions">
				<h3>SPARQL-based Functions</h3>
				<p>
					If a <code>sh:Function</code> has a value for <code>sh:sparql</code>, then a SPARQL-based execution engine SHOULD
					execute the provided SPARQL query on the current data set.
					In this SPARQL query, the engine needs to <span class="term">pre-bind</span> variables based on the provided arguments of the function call.
					The SPARQL query must be of type ASK or SELECT.
					For ASK queries, the function's return value is the result of the ASK query execution.
					For SELECT queries, the function's return value is the first binding of the first result variable in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one row.
				</p>
				<p>
					Some execution engines may ignore the specified <code>sh:sparql</code> query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified <code>sh:sparql</code> query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the <code>sh:sparql</code> query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>
		
		<section id="terms" class="appendix">
			<h2>Glossary of Key Concepts</h2>
			<section id="term-Shape">
				<h3>Shape</h3>
				<ul>
					<li>A <span class="term">Shape</span> is represented by an RDF node belonging to the class <code>sh:Shape</code>.</li>
					<li>Can have zero or more <span class="term">constraints</span>.</li>
					<li>Can have zero or more <span class="term">scopes</span> that select the nodes that the shape applies to.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that the shape applies to.</li>
				</ul>
			</section>
			<section id="term-Constraint">
				<h3>Constraint</h3>
				<ul>
					<li>A <span class="term">Constraint</span> is represented by an RDF node belonging to the class <code>sh:Constraint</code>.</li>
					<li>Are either <span class="term">native constraints</span> (e.g. based on a SPARQL query) or <span class="term">template constraints</span>.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that constraint applies to.</li>
					<li>Are validated against nodes in an RDF graph (or dataset).</li>
				</ul>
			</section>
			<section id="term-Validation">
				<h3>Constraint Validation</h3>
				<ul>
					<li><span class="term">Validation</span> of <span class="term">Constraints</span> checks for the presence or absence of certain triples in an RDF graph (or dataset)</li>
					<li>Produces results, including informational results, warnings, and errors.</li> 
				</ul>
			</section>
			<section id="term-FocusNode">
				<h3>Focus Node</h3>
				<ul>
					<li>A <span class="term">Focus Node</span> is an RDF node in a graph that is passed into the <span class="term">validation</span> of a constraint.</li>
					<li>Represented using the variable <code>?this</code> in SPARQL.</li>
				</ul>
			</section>
			<section id="term-Scope">
				<h3>Scope</h3>
				<ul>
					<li>A <span class="term">Scope</span> is a declarative mechanism to select <span class="term">Focus Nodes</span> from a given graph.</li>
					<li>There are individual scopes (<code>sh:nodeShape</code>), class-based scopes (<code>sh:scopeClass</code>, <code>rdf:type</code>) and general scopes (<code>sh:scope</code>).</li>
					<li>General scopes may be backed by a SPARQL query or a template.</li>
				</ul>
			</section>
			<section id="term-FilterShape">
				<h3>Filter Shape</h3>
				<ul>
					<li>A <span class="term">Filter Shape</span> defines constraints that potential focus nodes need to fulfill before they are validated.</li>
					<li>A node passes a filter shape when the validation of the shape does not lead to error-level results.</li>
				</ul>
			</section>
			<section id="term-Template">
				<h3>Template</h3>
				<ul>
					<li>A <span class="term">Template</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used for Constraints or Scopes.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
			<section id="term-Function">
				<h3>Function</h3>
				<ul>
					<li>A <span class="term">Function</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used in SPARQL queries.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
		</section>
		
	</body>
</html>
