<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "ED",
				shortName:  "shacl",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Dimitris Kontokostas",
						url:        "http://aksw.org/DimitrisKontokostas",
						company:    "University of Leipzig",
						companyURL: "http://informatik.uni-leipzig.de/",
						w3cid:      58399
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "//www.w3.org/2014/data-shapes/",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status"
			};
		</script>
		<!-- script src="https://www.w3.org/scripts/jquery/2.1/jquery.min.js"></script--> 
		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 12em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 12em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #aca; }
			pre.example-results:before { color: #797; content: "Example results"; width: 12em; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of RDF graphs.
				SHACL groups these descriptions and constraints into "shapes", which specify conditions that apply at a given RDF node.
				Shapes provide a high-level vocabulary to identify predicates and their associated cardinalities, datatypes and other constraints.
				Additional constraints can be associated with shapes using SPARQL.
				The vocabulary of SHACL has been designed to support similar extension languages besides SPARQL.
				These extension languages can also be used to define new high-level vocabulary terms.
				SHACL shapes can be used to communicate information about data structures associated with some process or interface, generate or validate data, or drive user interfaces.
				This document defines the SHACL language and its underlying semantics.
			</p>	
		</section>

		<section id="sotd">
		</section>
		<section class='introductory'>
		  <h2>Revision History</h2>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes/commits/gh-pages/shacl/index.html">Git repository</a>.
			</p>
			<ul>
				<li><b>2016-05-12</b>: sh:and,or,not now also apply to property/inverseProperty constraints (<a href="http://www.w3.org/2014/data-shapes/track/issues/135">ISSUE-135</a>)</li>
				<li><b>2016-05-12</b>: Remove sh:abstract  (<a href="http://www.w3.org/2014/data-shapes/track/issues/78">ISSUE-78</a>)</li>
				<li><b>2016-05-09</b>: SPARQL query at sh:derivedValues must now be proper SELECT queries, to allow PREFIX declarations</li>
				<li><b>2016-05-06</b>: Deleted sh:directType (<a href="http://www.w3.org/2014/data-shapes/track/issues/123">ISSUE-123</a>)</li>
				<li><b>2016-04-22</b>: Switched from graph-based prefixes to sh:prefix (this is a proposal only!) (<a href="http://www.w3.org/2014/data-shapes/track/issues/105">ISSUE-105</a>)</li>
				<li><b>2016-04-20</b>: Significant rework of the advanced sections, based on metamodel Proposal 3 (<a href="http://www.w3.org/2014/data-shapes/track/issues/95">ISSUE-95</a>)</li>
				<li><b>2016-04-18</b>: sh:stem definition</li>
				<li><b>2016-04-18</b>: Renamed sh:sourceTemplate to sh:sourceConstraintComponent</li>
				<li><b>2016-04-18</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-04-15</b>: Allowing multi-occurrence of constraint parameters <a href="http://www.w3.org/2014/data-shapes/track/issues/133">ISSUE-133</a></li>
				<li><b>2016-04-10/16/18</b>: Updated text for <a href="http://www.w3.org/2014/data-shapes/track/issues/144">ISSUE-144</a></li>
				<li><b>2016-04-10</b>: Fixed SPARQL query of sh:minExclusive <a href="http://www.w3.org/2014/data-shapes/track/issues/145">ISSUE-145</a></li>
				<li><b>2016-04-08</b>: Updated the definition and use of sh:hasShape <a href="http://www.w3.org/2014/data-shapes/track/issues/131">ISSUE-131</a></li>
				<li><b>2016-04-08</b>: Renamed sh:notEquals to sh:disjoint <a href="http://www.w3.org/2014/data-shapes/track/issues/136">ISSUE-136</a></li>
				<li><b>2016-04-07</b>: Added section on Invalid Shapes Graphs for <a href="http://www.w3.org/2014/data-shapes/track/issues/134">ISSUE-134</a></li>
				<li><b>2016-03-25</b>: rearrange cleanup sections 2 and 4, better definition of shape validation</li>
				<li><b>2016-03-25</b>: entailment regime - fix the graph IRI issue</li>
				<li><b>2016-03-25</b>: $shapesGraph warnings</li>
				<li><b>2016-03-22</b>: Cleaned up generic mechanism to define constraint components applied to 3.1</li>
				<li><b>2016-03-21</b>: SHACL does not assume that the data graph is an RDF dataset</li>
				<li><b>2016-03-21</b>: updated some definitions for shapes, scopes and filters</li>
				<li><b>2016-03-21</b>: Re-organized the sections on the various constraint properties, introducing the term constraint component</li>
				<li><b>2016-03-21</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-03-14</b>: Added three new node kinds as resolved (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-03-12</b>: Added issue warning regarding recursion</li>
				<li><b>2016-03-04</b>: Simplified the definition of sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-02-24</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-02-19</b>: Clarified that support for <code>$shapesGraph</code> is optional (<a href="http://www.w3.org/2014/data-shapes/track/issues/47">ISSUE-47</a>)</li>
				<li><b>2016-02-19</b>: Clarified that the SHACL graph URI includes the # (<a href="http://www.w3.org/2014/data-shapes/track/issues/129">ISSUE-129</a>)</li>
				<li><b>2016-02-18</b>: Removed reference to the proposed class <code>sh:QCC</code>(<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-12</b>: Added a paragraph on the limits of the core vocabulary, highlighting how rdf:Lists can be handled by the extension mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/119">ISSUE-119</a>)</li>
				<li><b>2016-02-10</b>: Added <code>sh:partition</code>. (<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-05</b>: Removed value type constraints on various constraint properties such as sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/117">ISSUE-117</a>)</li>
				<li><b>2016-01-29</b>: Clarified that validation results must be based on the data graph only. (<a href="http://www.w3.org/2014/data-shapes/track/issues/118">ISSUE-118</a>)</li>
				<li><b>2016-01-25</b>: Clarified direction of property path. Remove comment about consistency. (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-22</b>: Switched closed shapes syntax to sh:closed (<a href="http://www.w3.org/2014/data-shapes/track/issues/115">ISSUE-115</a>)</li>
				<li><b>2016-01-21</b>: Limit definition of shapes that are also classes to the shapes graph (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-19</b>: Describe scoping of shapes that are also classes (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-18</b>: Stated starting point for recursion (<a href="http://www.w3.org/2014/data-shapes/track/issues/22">ISSUE-22</a>)</li>
				<li><b>2016-01-18</b>: Clarified the meaning of filter shapes (<a href="http://www.w3.org/2014/data-shapes/track/issues/49">ISSUE-49</a>)</li>
				<li><b>2016-01-11</b>: Deleted operations section (<a href="http://www.w3.org/2014/data-shapes/track/issues/108">ISSUE-108</a>)</li>
				<li><b>2016-01-11</b>: Added derived properties (<a href="http://www.w3.org/2014/data-shapes/track/issues/97">ISSUE-97</a>)</li>
				<li><b>2016-01-11</b>: Dropped sh:ShapeClass (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>), elaborated on possible sh:scopeClass rule</li>
				<li><b>2016-01-10</b>: Added sh:order (<a href="http://www.w3.org/2014/data-shapes/track/issues/100">ISSUE-100</a>) and sh:group (<a href="http://www.w3.org/2014/data-shapes/track/issues/114">ISSUE-114</a>)</li>
				<li><b>2016-01-10</b>: Introduced sh:datatypeIn and sh:classIn, deleted sh:text (<a href="http://www.w3.org/2014/data-shapes/track/issues/104">ISSUE-104</a>)</li>
				<li><b>2016-01-09</b>: Syntax simplifications: Switched to sh:not, sh:and, sh:or, sh:equals, sh:notEquals, sh:lessThan, sh:lessThanOrEquals (<a href="http://www.w3.org/2014/data-shapes/track/issues/103">ISSUE-103</a>)</li>
				<li><b>2015-12-02</b>: Fixed <a href="https://github.com/w3c/data-shapes/issues/9">minor mistake in spec - ex:unsinged</a>.</li>
				<li><b>2015-11-20</b>: Switched from rdfs:label/rdfs:comment at property constraints to sh:name/sh:description (ISSUE-112)</li>
				<li><b>2015-11-06</b>: Renamed sh:nodeShape to sh:scopeNode, clarified that its triples are expected in shapes graph (ISSUE-61)</li>
				<li><b>2015-10-30</b>: Deleted sh:cachable, removed the option for sh:sparql to be a query fragment in sh:scope</li>
				<li><b>2015-10-29</b>: Improved wording in the definition of sh:in.</li>
				<li><b>2015-10-28</b>: Separated definitions of sh:qualifiedMinCount and sh:qualifiedMaxCount</li>
				<li><b>2015-10-22</b>: Define sh:minLength, sh:maxLength, sh:qualifiedMinCount, and sh:qualifiedMaxCount without reference to default values</li>
				<li><b>2015-10-22</b>: Replaced ex:bornIn with ex:residentIn in Section 2.2</li>
				<li><b>2015-10-16</b>: Added sh:SPARQLConstraint and sh:SPARQLScope (part of ISSUE-98)</li>
				<li><b>2015-10-16</b>: Renamed sh:valueClass to sh:class, sh:allowedValues to sh:in, sh:directValueType to sh:directType (part of ISSUE-98)</li>
				<li><b>2015-10-15</b>: Define sh:minCount and sh:maxCount without reference to default values</li>
				<li><b>2015-10-15</b>: Use real-world names in examples 3, 4 and 5</li>
				<li><b>2015-10-15</b>: Changed SPARQL definition of sh:AllObjects, implementing resolution to ISSUE-90</li>
				<li><b>2015-10-09</b>: Added sh:flags and sh:uniqueLang</li>
				<li><b>2015-09-23</b>: Multiple minor stylistic edits and corrections</li>
				<li><b>2015-09-21</b>: Added button to show or hide SPARQL definitions (thanks to Simon)</li>
				<li><b>2015-09-18</b>: Deleted <code>sh:XorConstraint</code> as resolved, renamed <code>sh:Error</code> to <code>sh:Violation</code></li>
				<li><b>2015-09-17</b>: Added missing definition of <code>sh:class</code>, editorial changes, renamed sh:ClosedShape to sh:Closed, added sh:sourceTemplate</li>
				<li><b>2015-09-15</b>: Restructured Part 2, with new examples, integrated SPARQL binding and rewritten Operations section</li>
				<li><b>2015-09-14</b>: Added SPARQL definitions for each constraint type, added description of sh:hasShape function</li>
				<li><b>2015-09-11</b>: Restructured constraint section, cleaned up results vocabulary</li>
				<li><b>2015-09-10</b>: Added sh:shapesGraph property (<a href="http://www.w3.org/2014/data-shapes/track/issues/44">ISSUE-44</a>)</li>
				<li><b>2015-09-09</b>: Rewritten introduction, dropped Profile section, word-smithing on sh:class</li>
				<li><b>2015-09-04</b>: Applied resolution to <a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a></li>
				<li><b>2015-09-03</b>: Many editorial changes, restructured section 5 (scopes and filters) into section 2 (Shapes)</li>
				<li><b>2015-09-01</b>: Minor changes and clarifications</li>
				<li><b>2015-08-24</b>: Added section on sh:defaultValueType (<a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a>)</li>
				<li><b>2015-08-21</b>: Added support for validation functions (<a href="http://www.w3.org/2014/data-shapes/track/issues/79">ISSUE-79</a>)</li>
				<li><b>2015-08-14</b>:
					Added qualified cardinality restrictions (<a href="http://www.w3.org/2014/data-shapes/track/issues/72">ISSUE-72</a>),
					added sh:ignoredProperties to sh:ClosedShape (<a href="http://www.w3.org/2014/data-shapes/track/issues/58">ISSUE-58</a>),
					editorial improvements to terminology, added Glossary to appendix
				</li>
				<li><b>2015-08-07</b>: Extended the use of sh:severity to template constraints, split sh:source into sh:sourceConstraint and sh:sourceShape, renamed sh:root to sh:focusNode</li>
				<li><b>2015-07-31</b>: Added sh:text as the union of xsd:string and rdf:langString</li>
				<li><b>2015-07-30</b>: Integrated sh:InversePropertyScope and sh:AllObjects</li>
				<li><b>2015-07-24</b>: Added details of XSD-like facets (<a href="http://www.w3.org/2014/data-shapes/track/issues/64">ISSUE-64</a>)</li>
				<li>
					<b>2015-07-17</b>: Rewritten scope and filter mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/62">ISSUE-62</a>),
					suggestion for generalized execution language interface (<a href="http://www.w3.org/2014/data-shapes/track/issues/60">ISSUE-60</a>)
				</li>
				<li><b>2015-07-13</b>: Replaced Appendix with references to SHACL-REF document</li>
				<li><b>2015-07-03</b>: Editorial fixes, started revision history</li>
			</ul>
		</section>
		<section class="introductory">
			<h2>Document Outline</h2>
			<p>
				The introduction includes a <a href="#terminology">Terminology</a> section that may also serve as a quick overview of the language.
			</p>
			<p>
				The sections 2 - 5 cover the <span class="term">SHACL Core Profile</span> and may be read independently from the later sections.
			</p>
			<p>
				The sections 6 onwards are about the advanced features of the SHACL language, including SPARQL-based constraint components, scopes and functions.
			</p>
			<p>
				The examples in this document use Turtle [[!turtle]].
				The reader should be familiar with basic RDF concepts [[!rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[!sparql11-overview]].			<p>
			</p>
		</section>


	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				This document specifies SHACL (Shapes Constraint Language), a language for describing and constraining RDF graphs.
				This section introduces SHACL with an overview of the key terminology and an example to illustrate basic concepts.
			</p>
			<section id="terminology">
				<h3>Terminology</h3>
				<p>
					Throughout this document, the following terminology is used.
				</p>
				<p class="todo">
					THIS SECTION IS HEAVILY UNDER CONSTRUCTION.
				</p>
				<div class="def" id="rdf-terminology">
					<div class="term-def-header">Basic RDF Terminology</div>
					<div>
						This document uses the terms 
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph"><dfn data-lt="graph|graphs">RDF graph</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple"><dfn data-lt="triple|triples">RDF triple</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri"><dfn data-lt="IRI|IRIs">IRI</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal"><dfn data-lt="literal|literals">literal</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node"><dfn data-lt="blank node|blank nodes">blank node</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-node"><dfn data-lt="node|nodes">node</dfn></a> of an RDF graph,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term"><dfn>RDF term</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-subject"><dfn data-lt="subject|subjects">subject</dfn></a>,
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-predicate"><dfn data-lt="predicate|predicates">predicate</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-object"><dfn data-lt="object|objects">object</dfn></a> of RDF triples
						as defined in RDF 1.1 Concepts and Abstract Syntax [[!rdf11-concepts]].
						SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF datasets</a>.
						SHACL makes no assumptions about any inferences supported by the graph.
						This means that a SHACL implementation is only concerned about triples present in the graphs that it receives as input.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">(Property) Value</div>
					<div>
						The <dfn data-lt="value|property value|property values">values</dfn> of a property <code>p</code> for a <a>node</a> <code>n</code> in a <a>graph</a> are the
						<a>objects</a> of the <a>triples</a> in the <a>graph</a> that have <code>n</code> as <a>subject</a> and <code>p</code> as <a>predicate</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Class</div>
					<div>
						A <dfn data-lt="class|classes">class</dfn> is a <a>IRI</a> or <a>blank node</a> representing a set of <a>nodes</a>.
						SHACL makes no assumption whether a class has certain values for the <code>rdf:type</code> property.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Subclass, SHACL superclass</div>
					<div>
						A <a>class</a> <code>Sub</code> is a <dfn data-lt="subclasses|subclass|SHACL subclasses|SHACL subclas">subclass</dfn> of another <a>class</a> <code>Super</code>
						if there is a path of <code>rdfs:subClassOf</code> <a>triples</a> from <code>Sub</code> to <code>Super</code>
						equivalent to the SPARQL property path [[!sparql11-query]] <code>?Sub rdfs:subClassOf+ ?Super</code>.
						The term <dfn data-lt="superclass|superclasses|SHACL superclass|SHACL superclasses|">superclass</dfn> is referring to the same relationship in reverse order.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Type</div>
					<div>
						The <dfn data-lt="type|types|SHACL type|SHACL types">types</dfn> of a <a>node</a> are its <a>values</a> of <code>rdf:type</code>
						as well as the <a>superclasses</a> of these <a>values</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Instance</div>
					<div>
						A <a>node</a> is an <dfn data-lt="instance|instances|SHACL instance|SHACL instances">SHACL instance</dfn> of a <a>class</a> if one of its
						<a>types</a> is the given <a>class</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Validation, Report, Result, Violation, Failure</div>
					<div>
						SHACL defines what it means for a <a>graph</a>, referred to as the <a>data graph</a>, to conform to a <a>graph</a> containing SHACL shapes, referred to as the <a>shapes graph</a>.
						The process of checking conformance is referred to as <dfn data-lt="validation|validate|validates|validated">validation</dfn>.
						The output of the validation process is a <dfn id="validation report|report">validation report</dfn> including
						<dfn id="validation result|result">validation results</dfn> such as informational results, warnings and violations.
						A validation process may also lead to a <dfn>failure</dfn>, if the validation could not be completed.
						<!-- span class="term">Validation</span> of <span class="term">constraints</span> checks for the presence or absence of certain triples in an RDF graph (or dataset).-->
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Data Graph</div>
					<div>
						The <dfn>data graph</dfn> is the <a>graph</a> of <a>triples</a> that are validated against the <a>shapes graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Shapes Graph</div>
					<div>
						The <dfn>shapes graph</dfn> is the graph in the SHACL language that defines <a>shapes</a> and <a>constraints</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Focus Node</div>
					<div>
						A <a>node</a> in the <a>data graph</a> that is defined by the <a>scope</a> is called the <dfn data-lt="focus node|focus nodes">focus node</dfn>.
						Depending on the selected <a>scope</a>, focus nodes are identified by the presence of a matching <code>rdf:type</code> <a>value</a>, as <a>triples</a> with a given <a>predicate</a>, or by other means.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Scope</div>
					<div>
						A <dfn data-lt="scope|scopes">scope</dfn> is a <a>node</a> in the <a>shapes graph</a> 
						that provides a declarative mechanism to select <a>focus nodes</a> from the <a>data graph</a>.
						SHACL supports various types of scopes such as "all <a>SHACL instances</a> of class X" or "all result nodes of a given SPARQL query".
					</div>
					<!-- ul>
						<li>There are node scopes (<code>sh:scopeNode</code>), class-based scopes (<code>sh:scopeClass</code>, <code>rdf:type</code>) and general scopes (<code>sh:scope</code>).</li>
						<li>A general scope may be defined by either a SPARQL query or a parameterizable scope type.</li>
					</ul-->
				</div>
				<div class="def">
					<div class="term-def-header">Shape</div>
					<div>
						A <dfn data-lt="shape|shapes">shape</dfn> is a <a>node</a> in the <a>shapes graph</a>
						that represents a collection of <a>constraints</a>, <a>scopes</a> and <a>filter shapes</a>.
						During <a>validation</a>, shapes are used to select which <a>focus nodes</a> need to be validated against which <a>constraints</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint</div>
					<div>
						A <dfn data-lt="constraint|constraints">constraint</dfn> is a <a>node</a> in the <a>shapes graph</a>
						that provides declarative instructions on how to <a>validate</a> a given <a>focus node</a>.
						Constraints may have <a>filter shapes</a> that narrow down the applicable <a>scope</a>.
						SHACL supports <dfn>SPARQL-based constraints</dfn> or <dfn data-lt="parameterizable constraint">parameterizable constraints</dfn>.
						Parameterizable constraints may consist of <a>values</a> of multiple properties such as <code>sh:minCount</code> and <code>sh:nodeKind</code>, each of which describe different validation instructions.
						A <dfn>property constraint</dfn> is a parameterizable constraint that is about a given property of the <a>focus node</a>.
						Such property constraints may also have non-validating properties (such as names and default values) that do not lead to <a>validation results</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint Component, Parameter, Context, Validator</div>
					<div>
						A <dfn>constraint component</dfn> represents a part of a <a>parameterizable constraint</a>
						that is identified by one or more property values called <dfn data-lt="parameter">parameters</dfn>.
						For example, <code>sh:minCount</code> is a parameter of the component <code>sh:MinCountConstraintComponent</code>.
						The <dfn>context</dfn> of a constraint component defines for which constraint types the parameters can be used.
						For each of these contexts, constraint components declare <dfn data-lt="validator">validators</dfn> that encapsulate execution instructions such as SPARQL SELECT or ASK queries. 
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Filter Shape</div>
					<div>
						A <dfn data-lt="filter shape|filter shapes">filter shape</dfn> defines constraints that <a>focus nodes</a> need to fulfill prior to <a>validation</a>.
						A <a>node</a> passes a filter shape when the <a>validation</a> against the <a>shape</a> does not lead to <a>validation results</a> with severity <code>sh:Violation</code> or a failure.
					</div>
				</div>
			</section>

			<section id="conventions">
				<h3>Document Conventions</h3>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
				</table>
				<p>
					Throughout the document, color-coded boxes containing RDF in Turtle markup will appear.
				</p>
				<pre class="example-shapes">
# This box represents an input shapes graph

# Triples that can be ommitted are marked as grey e.g.
<span class="triple-can-be-skipped">&lt;s&gt; &lt;p&gt; &lt;o&gt; .</span></pre>

				<pre class="example-data">
# This box represents an input data graph.
# When highlighting is used in the examples:

# Elements highlighted in blue are focus nodes that
# are selected by shape <a href="#shapes">scopes and filters</a>
<span class="focus-node-selected">ex:Bob</span> a ex:Person .

# Elements highlighted in red are focus nodes that fail <a href="#validation">validation</a>
<span class="focus-node-error">ex:Alice</span> a ex:Person .</pre>

				<pre class="example-results">
# This box represents an output results graph</pre>

				<p>
					SHACL Definitions appear in blue boxes:
				</p>
				<div class="def def-sparql">
					<div class="def-header">SPARQL or TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains SPARQL or textual definitions. </pre>
				</div>

			</section>

			<section>
				<h3>SHACL Example</h3>
				<p>
					SHACL can, for example, be used to check whether all the nodes in a data graph that have a type link to <code>foaf:Person</code> have a single value for <code>foaf:mbox</code>, and that that value is an IRI.
					SHACL can also be used to check whether a particular node in a data graph, say the node <code>ex:bug1</code>, has at least one
					value for <code>ex:reportedBy</code> and all such values have an <code>rdf:type</code> link to <code>foaf:Person</code>.
				</p>
				<p>
					The simplest interface to a SHACL processor has two inputs:
				</p>
				<ul>
					<li>A <span class="term">data graph</span> that contains the data that is to be validated</li>
					<li>A <span class="term">shapes graph</span> containing shape definitions and other information that can be utilized to determine what validation is to be done</li>
				</ul>
				<p>
					For example, one might use SHACL to determine whether data graphs that contain information about issues and users conform to the following constraints:
				</p>
				<ul>
					<li>each issue is in either an unassigned or an assigned state, and</li>
					<li>each issue has a reporter and each such reporter has precisely one name (which is a string) and one or more mailboxes (which are IRIs).</li>
				</ul>
				<p>
					A shapes graph that defines these constraints has two shapes.
					The first, <code>ex:IssueShape</code> contains the two constraints on issues.
					The second, <code>ex:UserShape</code>, contains the two constraints on reporters.
					<code>ex:IssueShape</code> contains scope information which in this case says that its constraints apply to all nodes that have an <code>rdf:type</code> link to
					either <code>ex:Issue</code> directly or to a (transitive) subclass of <code>ex:Issue</code> following <code>rdf:subClassOf</code> triples.
				</p>
				<pre class="example-shapes">
ex:IssueShape
	a sh:Shape ;
	sh:scopeClass ex:Issue;
	sh:property [
		sh:predicate ex:state ;
		sh:in (ex:unassigned ex:assigned) ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:reportedBy ;
		sh:valueShape ex:UserShape ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:UserShape
	a sh:Shape ;
	sh:property [
		sh:predicate foaf:name ;
		sh:datatype xsd:string ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate foaf:mbox ;
		sh:nodeKind sh:IRI ;
		sh:minCount 1 ;
	] .</pre>
				<p>
					We can use the shape definitions above to skim through some of the key terminology used by SHACL.
					The <span class="term">shape</span> <code>ex:UserShape</code> has two <span class="term">constraints</span>,
					linked to the shape using the property <code>sh:property</code>.
					These constraints are of a specific type of constraints called <span class="term">property constraints</span>.
					Each of these property constraints is about a given property only, specified via the property <code>sh:predicate</code>.
					Each of the constraints also group together multiple <span class="term">constraint components</span>,
					which restrict specific aspects of the property values.
					These constraint components are identified by their <span class="term">parameters</span>.
					In the second property constraint of <code>ex:UserShape</code>, two constraint components are used.
					One of them is represented by the parameter <code>sh:nodeKind</code> and the other is represented by the parameter <code>sh:minCount</code>.
				</p>
				<p>
					The following data graph might be validated against the shapes graph from above.
				</p>
				<pre class="example-data">
inst:Issue1
	a ex:Issue ;
	ex:state ex:unassigned ;
	ex:reportedBy inst:User2 .

inst:User2
	a foaf:Person ;
	foaf:name "Bob Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .

inst:Issue3
	a ex:Issue ;
	ex:state ex:unsigned ;
	ex:reportedBy inst:User4 .

inst:User4
	a foaf:Person ;
	foaf:name "Bob Smith", "Robert Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .</pre>
				<p>
					The SHACL validation would validate <code>inst:Issue1</code> and <code>inst:Issue3</code> in the data graph against <code>ex:IssueShape</code> in the shapes graph
					because these nodes satisfy the scope of <code>ex:IssueShape</code>.
					Since <code>ex:UserShape</code> has no scope definition, from the <code>ex:UserShape</code> alone we cannot determine its focus nodes.
					However, the <code>sh:valueShape</code> statement in <code>ex:IssueShape</code> states
					that any node that is an object of a triple with the predicate <code>ex:reportedBy</code>
					and with a subject that is in the scope of <code>ex:IssueShape</code> must comply with <code>ex:UserShape</code>.
					Therefore, SHACL validation would also validate <code>inst:User2</code> and <code>inst:User4</code> against <code>ex:UserShape</code>.
				</p>
				<p>
					Validating these nodes would determine that <code>inst:Issue1</code> satisfies all constraints in <code>ex:IssueShape</code>
					and <code>inst:User2</code> satisfies all constraints in <code>ex:UserShape</code>.
					It would also determine that <code>inst:Issue3</code> violates the constraint on values for <code>ex:state</code>, because <code>ex:unsigned</code> is not in the list of allowed values (the correct value is <code>ex:unassigned</code>),
					and also violates the constraint on values for <code>ex:reportedBy</code>, because <code>inst:User4</code> violates the <code>ex:UserShape</code> constraint on the maximum number of values for <code>foaf:name</code>.
				</p>
			</section>
			
			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS</h3>
				<p>
					SHACL uses RDF and RDFS vocabulary (in particular <code>rdf:type</code>, <code>rdfs:Class</code>, <code>rdfs:subClassOf</code>, <code>rdf:Property</code>, <code>rdf:List</code>,
					<code>rdf:langLiteral</code>, and <code>rdfs:Resource</code>) and concepts (notably classes, instances, and subclasses).
					However, SHACL does not always use this vocabulary or these concepts in exactly the way that they are formally defined in RDF and RDFS [[!rdf11-mt]].				
				</p>
				<p>
					When determining subclass and instance relationships SHACL only uses the transitive closure of <code>rdfs:subClassOf</code>,
					without requiring in particular the RDF axioms, the RDFS meaning of <code>rdfs:Resource</code>, the reflexivity of <code>rdfs:subClassOf</code>,
					the effect of subproperties of <code>rdfs:subClassOf</code>, and the effects of <code>rdfs:domain</code> and <code>rdfs:range</code>.
				</p>
				<p>
					Note that <code>rdfs:subClassOf</code> transitivity is only used when SHACL explicitly determines type and subclass relationships in the shapes graph and the data.
					Elsewhere, only triples that are explicitly present in the shapes graph or the data are considered.
					For example, SHACL property constraints on <code>rdf:type</code> and <code>rdfs:subClassOf</code> only utilize triples that are explicitly in the data.
					Similarly, subproperties of <code>rdfs:label</code> and <code>rdfs:commment</code> and subclasses of <code>rdf:List</code> are not recognized in the shapes graph.
				</p>
				<p>
					These design decisions mean that SHACL processors do not have to natively support full RDFS inferencing.
					However, SHACL implementations may operate on RDF graphs that include entailments - either pre-computed before being submitted to a SHACL processor or performed on the fly as part of SHACL processing.
					To support on the fly processing of entailments, SHACL includes the property <a href="#entailment"><code>sh:entailment</code></a> to indicate what inferencing is required by a given shapes graph.
					SHACL implementations may, but are not required to, support entailment regimes.
				</p>
			</section>
			
			<section id="shacl-sparql">
				<h3>Relationship between SHACL and SPARQL</h3>
				<p>
					This specification uses parts of SPARQL 1.1 in the normative definition of the semantics of the SHACL Core constraints and scopes.
					However, SPARQL is not required for the implementation of the SHACL Core language.
				</p>
				<p>
					SPARQL variables using <code>$</code> marker represent external values that must be <a href="#pre-binding">pre-bound</a> in the query before execution.
				</p>
				<p>
					In some places, the specification assumes that the provided SPARQL engines are preserving the identity of blank nodes,
					so that repeated invocations of queries consistently identify and communicate the same blank nodes.
				</p>
				<p>
					The definition of some constraints requires or is simplified through access to the shapes graph during query execution.
					SHACL validation engines MAY <a href="#pre-binding">pre-bind</a> the variable <code>$shapesGraph</code> to provide access to the shapes graph.
					Access to the shapes graph is not a requirement for supporting the SHACL core language.
					The variable <code>$shapesGraph</code> can also be used in user-defined <a href="#sparql-constraints">SPARQL constraints</a> and <a href="#constraint-components">SPARQL-based constraint components</a> .
					However, such constraints may not be interoperable across different SHACL validation engines or not applicable to remote RDF datasets.
				</p>
				<p>
					Some SHACL constraints are defined with the use of the <a href="#hasShape"><code>sh:hasShape</code></a> function.
					SHACL additionally introduces mechanisms to define constraints, scopes and new functions in SPARQL.
					Implementations that cover only the the SHACL Core features are not required to implement these mechanisms or the <code>sh:hasShape</code> function.
				</p>
				<div class="syntaxmenu">
					<p>The button below can be used to show or hide the SPARQL definitions.</p>
					<form>
						<p>
							<input id="hide-sparql" onclick="$('.def-sparql').css('display', 'none'); $('#hide-sparql').css('display', 'none'); $('#show-sparql').css('display', '');" type="button" value="Hide SPARQL Definitions" />
							<input id="show-sparql" onclick="$('.def-sparql').css('display', '');     $('#show-sparql').css('display', 'none'); $('#hide-sparql').css('display', '');" style="display:none" type="button" value="Show SPARQL Definitions" />
						</p>
					</form>
				</div>
			</section>
			
			<!--section id="namespaces">
				<h3>Namespaces</h3>
				<p>

				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e. it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g. via <code>owl:imports</code> SHOULD include the <code>#</code>. 
				</p>
			</section-->

			<section id="conformance">
				<p>
					<span class="todo">TODO: We still need to mark non-normative sections.</span>
				</p>
			</section>
			
		</section>
		
		<div style="padding-top: 30px"> <!-- ALH: really??? -->
			<h1 id="part1" style="font-size: 160%; font-weight: bold">Part 1: Core Features</h1>
		</div>

		<section id="shapes">
			<h2>Shapes</h2>
			<p>
				Shapes are <a>SHACL instances</a> of the class <code>sh:Shape</code> and define one or more <span class="term"><a href="#shape-constraints">constraints</a></span> that a set of <span class="term">focus nodes</span> can be validated against.
				The set of focus nodes may be defined explicitly in a shape using <span class="term"><a href="#scopes">scopes</a></span> and <span class="term"><a href="#filterShape">filter shapes</a></span>, or provided by the validation engine as defined in later sections. <!-- DK: TODO: check consistent terminology later-->
				Shape scopes define the selection criteria for the focus nodes.
				Shapes with scopes MAY additionally provide <span class="term">filter shapes</span>.
				Filter shapes further refine the focus nodes to the ones that conform to a set of filter shapes.

				The following figure provides a workflow of the scoping and filtering process.
				SHACL validation engines MAY alter the order of the depicted steps as long as the returned validation results  are correct.
				<!--DK: TODO check term correct -->

			</p>
			<figure>
				<img src="images/SHACL-Validation-Process.png" />
				<figcaption>Illustration of the scoping and filtering process</figcaption>
			</figure>

			<section id="scopes">
				<h3>Scopes</h3>
				<p>
					Scopes define the set of focus nodes for a shape and SHACL includes six scope types:
				</p>
				<ul>
					<li><a href="#scopeNode"><b>Node scopes</b></a> define a specific RDF node as scope.</li>
					<li><a href="#scopeClass"><b>Class-based scopes</b></a> define the scope as the set of all <a>SHACL instances</a></a> of a class.</li>
					<li><a href="#PropertyScope"><b>Property scopes</b></a></li>
					<li><a href="#InversePropertyScope"><b>Inverse property scopes</b></a></li>
					<li><a href="#AllSubjectsScope"><b>All subjects scopes</b></a></li>
					<li><a href="#AllObjectsScope"><b>All objects scopes</b></a></li>
				</ul>
				<p>
					The SHACL language also defines a <a href="#sparql-scopes">general scoping mechanism based on SPARQL</a>.
				</p>
				<p>
					When multiple scopes are provided in a shape, the scope of a shape is the union of all focus nodes produced by these scopes.
					Focus nodes produced by scopes might not exist in the data graph.
				</p>
				
				<section id="scopeNode">
					<h4>Node scopes (sh:scopeNode)</h4>
					<p>
						Node scopes are defined with the 	<code>sh:scopeNode</code> predicate.
						The value of a node scope can be an IRI or a Literal.
						<!-- TODO: " that SHOULD exist in the data graph" do we need SHOULD here? and why is this different that other scopes-->
						<!-- TODO: change examples and visually differentiate the shapes graph from the data graph-->
					</p>

					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:scopeNode ex:Alice .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:Bob a ex:Person .</pre>
				</section>
				
				<section id="scopeClass">
					<h4>Class-based Scopes (sh:scopeClass)</h4>
					<p>
						Shapes class scopes are defined with the <code>sh:scopeClass</code> predicate.
						The value of a class scope is an IRI that is assumed to be an <a>SHACL instance</a> of <code>rdfs:Class</code>.
						Whether the IRI is indeed a <a>SHACL instance</a> of <code>rdfs:Class</code> or where this definition exists is not material to the SHACL implementaiton
					</p>
					<p>
						A shape with a class-based scope selects all focus nodes that are <a>SHACL instances</a> of the class IRI.
					</p>
					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:scopeClass ex:Person .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
<span class="focus-node-selected">ex:Bob</span> a ex:Person .
ex:NewYork a ex:Place .</pre>

					In this example, ex:Alice and ex:Bob are selected scopes. Note that, according to the <a>SHACL instance</a> definition, all the <code>rdfs:subClassOf</code> declarations must exist in the data graph.
					However, the <code>ex:Person a rdfs:Class</code> triple is not required to exist in either graphs.

					<pre class="example-data">
ex:Doctor rdfs:subClassOf ex:Person .
<span class="focus-node-selected">ex:Who</span> a ex:Doctor .</pre>
The selected scope is ex:Who.

					<section id="implicit-scopeClass">
						<h4>Implicit Class Scopes</h4>
						<p>
							Shapes and classes are independent concepts in SHACL.
							In many applications, classes and shapes are separate resources and are therefore given different IRIs.
							However, some application designers may find it more convenient to tightly couple class and shape information and use the same IRI for both.
						</p>
						<p>
							If, in the shapes graph, a shape is a <a>SHACL instance</a> of both <code>sh:Shape</code> and <code>rdfs:Class</code>
							the shape must get an implicit class scope of the class IRI and the <code>sh:scopeClass</code> triple MAY be omitted.
						</p>
						<pre class="example-shapes">
ex:Person
	<b>a rdfs:Class</b>, sh:Shape ;
	<span style="color: grey;">sh:scopeClass ex:Person .  #this triple can be omitted</span></pre>
					</section>
				</section>
				
				<section id="PropertyScope">
					<h5>Property scopes (sh:PropertyScope)</h5>
					<p>
						A <span class="term">property scope</span> for property <code>p</code> is defined as the set of subjects in the data graph that appear in a triple with <code>p</code> as a predicate.
					</p>

					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this $p ?any .
}</pre>
					</div>
					<p>
						A shape defines a <span class="term">property scope</span> with the <code>sh:scope</code> predicate and object an RDF node <code>r</code> of type <code>sh:PropertyScope</code>.
						The RDF node <code>r</code> must provide exactly one value for <code>p</code> with the <code>sh:predicate</code> property.
					</p>
					<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:PropertyScope ;
		sh:predicate ex:knows ;
	] .</pre>

						<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
ex:Bob ex:livesIn ex:NewYork .</pre>
				</section>
				<section id="InversePropertyScope">
					<h5>Inverse property scopes (sh:InversePropertyScope)</h5>
					<p>
						An <span class="term">inverse property scope</span> for property <code>p</code> is defined as the set of objects in the data graph that appear in a triple with <code>p</code> as a predicate.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?any $p ?this .
}</pre>
					</div>
					<p>
						A shape defines an <span class="term">inverse property scope</span> with the <code>sh:scope</code> predicate and object an RDF node <code>r</code> of type <code>sh:InversePropertyScope</code>.
						The RDF node <code>r</code> must provide exactly one value for <code>p</code> with the <code>sh:predicate</code> property.
					</p>

					<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:InversePropertyScope ;
		sh:predicate ex:knows ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn ex:NewYork .</pre>
				</section>
				<section id="AllSubjectsScope">
					<h5>All subjects scopes (sh:AllSubjectsScope)</h5>
					<p>
						An <span class="term">all subjects scope</span> is defined as the set of all subjects that appear in triples in the data graph.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this ?anyPredicate ?anyObject .
}</pre>
					</div>
					<p>
						A shape defines an <span class="term">all subjects scope</span> with the <code>sh:scope</code> predicate and object an RDF node of type <code>sh:AllSubjectsScope</code>.
					</p>
					<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:AllSubjectsScope ;
	] .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
<span class="focus-node-selected">ex:Bob</span> ex:livesIn ex:NewYork .</pre>

				</section>
				<section id="AllObjectsScope">
					<h5>All objects scopes (sh:AllObjectsScope)</h5>
					<p>
						An <span class="term">all objects scope</span> is defined as the set of all objects that appear in triples in the data graph.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?anySubject ?anyPredicate ?this .
}</pre>
					</div>

					<p>
						A shape defines an <span class="term">all objects scope</span> with the <code>sh:scope</code> predicate and object an RDF node of type <code>sh:AllObjectsScope</code>.
					</p>

					<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:AllObjectsScope ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn <span class="focus-node-selected">ex:NewYork</span> .</pre>
				</section>
			</section>
			
			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					A filter shape can either further refine the scope of a focus node or can refine the target of a constraint.
					For example, focus nodes selected based on their <code>rdf:type</code> <code>ex:Person</code> can be further refined to those that were <code>ex:residentIn</code>
					the country <code>ex:USA</code>.
					To support such use cases, SHACL includes the concept of <span class="term">filter shapes</span> that act as pre-conditions that focus nodes need to fulfill before they are being validated.
					Formally, filter shapes eliminate a focus node selected by a shape's scopes when the focus node produces a validation result with severity <a href="#results-severity"><code>sh:Violation</code></a> of the given filter shape.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint on <code>ex:email</code> is filtered to include only <code>ex:Person</code>s that are <code>ex:member</code>s of <code>ex:W3c</code>.
				</p>
				<pre class="example-shapes">
ex:ExampleFilteredShape
	a sh:Shape ;
	sh:scopeClass ex:Person ;
	sh:filterShape [
		<span style="color: grey;">a sh:Shape ; # Optional triple</span>
		sh:property [
			sh:predicate ex:member ;
			sh:hasValue ex:W3c ;
		]
	] ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
	] .</pre>

<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person ;
	ex:member ex:W3c ;
	ex:email &lt;mailto:alice@example.org&gt; .
<span class="focus-node-selected">ex:John</span> a ex:Person ;
	ex:member ex:W3c .
ex:Bob a ex:Person ;
	ex:member ex:Acme .</pre>

				<pre class="example-results">
[  a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:John ;
	sh:subject ex:John ;
	sh:predicate ex:email ;
	sh:message "sh:minCount for ex:email is '1'." ;
	sh:sourceConstraintComponent sh:MinCountConstraintComponent ; 
] . </pre>

				<p>
					The following example shows a <code>sh:filterShape</code> that is defined on specific constraints, instead of the whole shape.
				</p>

				<pre class="example-shapes">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Person ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
		sh:filterShape [
			sh:property [
				sh:predicate ex:member ;
				sh:hasValue ex:W3c ;
			]
		] ;
	] .
</pre>


				<span class="todo">TODO: say about filters when they are evaluated from sh:valueShape?</span><br/>
				<span class="todo">TODO: say anything about filters and severities?</span><br/>
				<!--
				DK: I think we can omit all these, we have a formal definition of how validation works later
				<p>
					Filters always contribute to the meaning of a shapes.
					This includes both the computation of scopes and when shapes are directly referenced via <code>sh:valueShape</code>.
					In general, a filter shape acts like the test condition of an <code>IF-THEN</code> statement.
					For example, suppose some optional property has a default value.
					Then a shape might express the constraint that <code>IF</code> the property is present <code>THEN</code> its value must be equal to the default value.
					In this case the filter would test for the presence of the property and the constraint would test that its value was equal to the
					default value.
				</p>
				<p>
					When a SHACL processor validates a focus node against a shape, it begins by validating any filters associated with the shape via 
					<code>sh:filterShape</code>.
					If any of the filters produce a violation then the processor interprets this as indicating that none of the constraints
					of the shape are applicable to the focus node and no violations for the shape are reported.
					Conversely, if none of the filters produce a violation then the processor proceeds to evaluate the constraints and reports any 
					violations produced by them.
				</p>
				<p>
					Similarly, when a SHACL processor validates a focus node against a constraint, it begins by validating any filters
					associated with the constraint via <code>sh:filterShape</code>.
					If any of the filters produce a violation then the processor interprets this as indicating that the constraint
					is not applicable to the focus node and no violations for the constraint are reported.
					Conversely, if none of the filters produce a violation then the processor proceeds to evaluate the constraint and reports any 
					violations produced by it.
				</p>
				-->
			</section>
			<section id="shape-constraints">
				<h3>Constraints</h3>
				<p>
					A shape defines one or more constraints and <code>sh:Constraint</code> is the superclass of all constraint types.
					The SHACL core language defines the following three <span class="term">constraint types</span>:
				</p>
				<ul>
					<li>
						<code>sh:PropertyConstraint</code> is the class of constraints that specify conditions
						that must be met with respect to triples with the focus node as a subject and a particular property as a predicate.
					</li>
					<li>
						<code>sh:InversePropertyConstraint</code> is the class of constraints that specify conditions
						that must be met with respect to triples with the focus node as an object and a particular property as a predicate.
					</li>
					<li>
						<code>sh:NodeConstraint</code> is the class of constraints that specify conditions
						that must be met with respect to triples with the focus node as a subject.
					</li>
				</ul>
				<p>
					Additional types of constraints can be added using the extension mechanism,
					either <a href="#sparql-constraints">SPARQL-based constraints</a> or
					<a href="#constraint-components">SPARQL-based constraint components</a>.
				</p>
				<p>
					Shapes link to their constraints via the following properties:
				</p>
				<ul>
					<li>
						<code>sh:property</code> links shapes to <span class="term">property constraints</span>.
						The <span class="term">default value type</span> of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
					</li>
					<li>
						<code>sh:inverseProperty</code> links shapes to <span class="term">inverse property constraints</span>.
						The <span class="term">default value type</span> of <code>sh:inverseProperty</code> is <code>sh:InversePropertyConstraint</code>.
					</li>
					<li>
						<code>sh:constraint</code> links shapes to any type of <span class="term">constraints</span>, in particular <span class="term">node constraints</span> and <span class="term">SPARQL-based constraints</span> (which are an advanced topic).
						The <span class="term">default value type</span> of <code>sh:constraint</code> is <code>sh:NodeConstraint</code>.
					</li>
				</ul>
				<p>
					The values of sh:property, sh:inverseProperty, and sh:constraint must be IRIs
					or blank nodes.  The values of sh:property and sh:inverseProperty must be the
					subject of precisely one triple with property sh:predicate, whose object must
					be an IRI.
				</p>
				<p id="default-value-types">
					All three properties have a <a href="#defaultValueType"><span class="term">default value type</span></a> and thus, the <code>rdf:type</code> triple can be omitted.
					<span class="term">Instances</span> of constraint types can be reused across the same shape or different shapes.
					However, all constraint types are pairwise disjoint and no more than one property of <code>sh:property</code>, <code>sh:inverseProperty</code> and <code>sh:constraint</code> can link to the same RDF node within the same <span class="term">shapes graph</span>.
				</p>
				<p>
					Constraints may contain
					<a href="#nonValidation">non-validating</a> properties (such as <code>sh:description</code>) or
					<span class="term">parameters</span> of <span class="term">constraint components</span> (e.g. <code>sh:minCount</code>).
					<span class="term">Constraint components</span> define one or more parameter properties and validation instructions
					(such as those implemented as SPARQL queries) that can be used to perform the validation for the given focus node and parameter values.
					The relationship between a <span class="term">constraint component</span> and the <span class="term">constraint types</span>
					that it can be used with is called the <span class="term">context</span> of the component.
					For example, the <span class="term">context</span> of the component defining the <code><a href="#ClosedConstraintComponent">sh:closed</a></code> property is <code>sh:NodeConstraint</code>.
					This means that the property <code>sh:closed</code> can only be used in <a>SHACL instances</a> of <code>sh:NodeConstraint</code>.
					The catalog of constraint components in the Core of SHACL is defined in <a href="#constraints">section 3</a>.
				</p>
				<p> 
					The following examples illustrate two ways of using (property) constraints.
					The first example uses a blank node:
				</p>
				<pre class="example-shapes">
ex:InlinePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:name "some property" ;
		sh:description "Description of the role of ex:someProperty (in the context of the constraint)" ;
		sh:minCount 1 ;
		sh:class ex:SomeClass ;
	] .</pre>
				<p>
					The second example defines a constraint as an IRI node, allowing it to be more easily referenced and shared across multiple shapes:
				</p>
				<pre class="example-shapes">
ex:StandAlonePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property ex:StandAloneConstraint .

ex:StandAloneConstraint
	a sh:PropertyConstraint ;
	sh:predicate ex:someProperty ;
	sh:defaultValue ex:SomeInstance ;
	sh:minCount 1 ;
	sh:class ex:SomeClass .</pre>
				<p>
					Parameters of constraint components that only have one parameter type (such as <code>sh:class</code>)
					may be used multiple times within the same constraint node.
					In the following example this technique is used to restrict the values of a property to be both
					<code>ex:Customer</code> and <code>ex:MalePerson</code>.
				</p>
				<pre class="example-shapes">
ex:ShapeWithTwoClasses
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:class ex:Customer ;
		sh:class ex:MalePerson ;
	] .</pre>
			</section>
		</section>

		<section id="validation">
			<h2>Validation and Graphs</h2>
			<p>
				A SHACL validation engine takes two RDF graphs as input, a <span class="term"><a href="#shapes-graph">shapes
				graph</a></span> and a
				<span class="term"><a href="#data-graph">data graph</a></span>, and validates the <span class="term">data graph</span>
				against the <span class="term">shapes graph</span> as described herein.
			</p>

			<div id="def-validation" class="def def-text">
				<div class="def-header">VALIDATION DEFINITION</div>
				<div class="def-text-body">
					<ul>
						<li>A <span class="term">node</span> validates against a <span class="term">shape</span> iff
							either it does not validate against some filter of the shape
							or none of the constraints in the shape produce a validation result with severity <span class="term">sh:Violation</span> for the node.
						</li>
						<li>A <span class="term">data graph</span> validates against a <span class="term">shape</span> iff
							each node that is in any of the scopes of the shape validates against the shape.
						</li>
						<li>A <span class="term">data graph</span> validates against a <span class="term">shapes graph</span> iff
							the data graph validates against each shape in the shapes graph.
						</li>
					</ul>
				</div>
			</div>

			<p>
				The validation process returns a <span class="term"><a href="#results-graph">results graph</a></span> containing all validation results.
				By default, the results graph contains validation results of all <a href="#results-severity">severity</a> levels
				but the user can request validation results with a custom minimum severity (i.e. <code>sh:Warning</code>).
				According to the definition of validation, a results graph may contain validation results but as long as none is of severity <code>sh:Violation</code> the data graph is considered valid.
				For simpler validation scenarios, SHACL validation engines should provide an additional validation interface that returns only <span class="term">VALID</span> or <span class="term">INVALID</span>.
			<p>
				During validation, the <span class="term">data graph</span> and the <span class="term">shapes graph</span> must remain unchanged, i.e. both graphs at the end of the validation must be identical to the graph at the beginning of validation.
			</p>
			<p>
				A SHACL validation engine MUST implement all constructs in the core of SHACL (Sections 2, 3, 5).
				A SHACL engine MAY not implement the other parts of SHACL.
				<br/><span class="todo">TODO sections 2 and 5 are implied by definition</span>
			</p>

			<section id="shapes-graph">
				<h3>Shapes Graph</h3>
				<p>
					The <span class="term">shapes graph</span> contains shape definitions that a data graph can be tested against.
					Shape definitions can be reusable validation components.
					For example, a set of shapes can target data under a specific schema (i.e. SKOS) and validate different data graphs that use this schema.
					It is considered as a best practice to modularize shape definitions into separate graphs and import them at validation time.
					Importing multiple shapes graphs can be achieved with the predicate predicate <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a>.
					SHACL validation engines SHOULD transitively follow all <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a> to other graphs and use the resulting union graph as shapes graph to the validation process.
				</p>
				<p>
					In addition to shape definitions, the shapes graph may contain additional information for the validation engine such as <a href="#entailment">entailment</a> directives, namespace declarations,
					<span class="todo">TODO ns declarations is an open issue, others?</span>
				</p>
				<section id="shapes-graph-invalid">
					<h4>Invalid Shapes Graphs</h4>

					<span class="todo">TODO This section is subject to removal after we <a href="https://www.w3.org/2014/data-shapes/wiki/Proposals#Topic_3:_splitting_sh:constraint">refactor sh:constraint</a> </span>
					<p>
						SHACL validation engines MUST reject shapes graphs that are invalid, according to the following rules and the rules in the other sections of this document.
						No validation results must be produced, but instead a system error reported by other means.
					</p>
					<p>
						The values of <code>sh:constraint</code> may be <a>SHACL instances</a> of any subclass of <code>sh:Constraint</code>.
						If a SHACL validation engine encounters a value of <code>sh:constraint</code> that it does not know how to handle
						(e.g. because it does not support a certain extension language), it MAY produce an error or a warning, but MAY also silently ignore such constraints.
					</p>
				</section>
			</section>
			<section id="data-graph">
				<h3>Data Graph</h3>
				<p>
					The <span class="term">data graph</span> contains the RDF data that a SHACL engine can validate.
					SHACL treats it as a general RDF graph and makes no assumption if it is e.g. an RDF dataset, an in memory graph or a named graph in a remote SPARQL endpoint.
					<!-- TODO: say something about datasets / $shapesGraph -->
				</p>
				<p>
					The data graph SHOULD include all the ontology axioms related to the data and especially all the <code>rdfs:subClassOf</code> triples in order for SHACL to correctly identify class scopes and core SHACL constraints.
					If such triples are missing, the validation could report false violations or miss to report some violations.
				</p>
				<p>
					A data graph can autonomously suggest one or more shapes graph to a SHACL validation engine with the predicate <code>sh:shapesGraph</code>.
					Every value of this property is an IRI representing a shapes graph that should be used to validate the data graph.
					A SHACL validation engine MAY use such suggestions to determine which shapes graph to use for validating a data graph.
				</p>
				<p>
					In the following example, a tool may use the union of <code>ex:graph-shapes1</code> and <code>ex:graph-shapes2</code> graphs (and their <code>owl:imports</code>) as the <span class="term">shapes graph</span> when validating the given graph.
				</p>

							<pre class="example-shapes">
[] sh:shapesGraph ex:graph-shapes1 ;
	sh:shapesGraph ex:graph-shapes2 .</pre>
			</section>

			<section id="results-graph">
				<h3>Results Graph</h3>
				<span class="todo">TODO talk about the results in a higher level than sec 5</span>
			</section>
		</section>

		<section id="constraints">
			<h2>Core Constraint Components</h2>
			<p>
				The following sections define the constraint components built into the SHACL Core.
				Compliant SHACL validation engines MUST support all of these constraint components.
			</p>
			<p>
				The choice of constraint components that are defined by the SHACL Core was made based on
				the requirements collected by the [[shacl-ucr]] document.
				Special attention was paid to the balance between trying to cover as many common use cases as possible
				and keeping the size of the core language manageable.
				Not all use cases (such as describing constraints on members of an <code>rdf:List</code>) can be expressed by the Core Vocabulary alone.
				Instead, SHACL provides extension mechanisms as described in the second part of this specification.
				It is expected that reusable libraries of SHACL extensions will be maintained by third parties.
			</p>
			<p>
				Note that the textual definitions of the constraint components refer to the <a href="#results">Validation Results Vocabulary</a>
				introduced in a later section.
				Each constraint component is identified by a IRI that is referenced in the validation results via <code>sh:sourceConstraintComponent</code>.
			</p>
			<p>
				Many constraint components can be used in multiple contexts, e.g. both in a <span class="term">property constraint</span> context
				and an <span class="term">inverse property constraint</span> context.
				The textual description of each component refers to the concept of <dfn data-lt="value node">value nodes</dfn>
				which is defined as follows, including rules for the creation of validation results:
			</p>
			<ul>
				<li>
					For <span class="term">property constraints</span> the <span class="term">value nodes</span> are the objects of the triples that have the <span class="term">focus node</span> as subject and the given property as predicate.
					Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value node as its <code>sh:object</code>.
				</li>
				<li>
					For <span class="term">inverse property constraints</span> the <span class="term">value nodes</span> are the subjects of the triples that have the <span class="term">focus node</span> as object and the given property as predicate.
					Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:object</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value node as its <code>sh:subject</code>.
				</li>
				<li>
					For <span class="term">node constraints</span> the <span class="term">value nodes</span> are the individual <span class="term">focus nodes</span>, forming a set of exactly one node.
				</li>
			</ul>
			<p>
				The SPARQL definitions in this section may only be written for one of the three possible contexts, for brevity.
				Corresponding queries can be formulated for the other cases (such as the inverse direction) easily.
				The SPARQL definitions also assume the variable bindings and result variable mapping rules detailed in the
				<a href="#sparql-constraints">section on SPARQL-based Constraints</a>.
				In a nutshell, the variable <code>$this</code> represents the currently validated focus node.
				In <code>sh:PropertyConstraint</code>s and <code>sh:InversePropertyConstraint</code>s,
				the value of the variable <code>$predicate</code> is the value of <code>sh:predicate</code>
				in the constraint.
			</p>
			<p>
				Note that the parameter tables in each of the following sections have a column called Value Type which indicates the expected
				type of the parameter values for documentation purposes, without enforcing any formal restrictions.
			</p>
			<p>
				The SPARQL definitions in this section also assume the existence of a built-in SPARQL function <a href="#hasShape"><code>sh:hasShape</code></a>.
			</p>
			<p>
				The following table summarizes the parameters used by the core constraint components.
				The table clarifies whether these parameters can be used as part of a
				<code>sh:NodeConstraint</code> (NC, to apply to the focus node itself),
				a <code>sh:PropertyConstraint</code> (PC, to apply to all values of a given property),
				or a <code>sh:InversePropertyConstraint</code> (IPC, to apply to all inverse values of a given property).
			</p>
			<table class="term-table">
				<tr>
					<th>Parameters</th>
					<th>NC</th>
					<th>PC</th>
					<th>IPC</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td>
						<a href="#ClassConstraintComponent"><code>sh:class</code></a> and
						<a href="#ClassInConstraintComponent"><code>sh:classIn</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Type, based on <code>rdf:type</code></td>
				</tr>
				<tr>
					<td>
						<a href="#ClosedConstraintComponent"><code>sh:closed</code></a>
					</td>
					<td>&#9745;</td>
					<td></td>
					<td></td>
					<td>Only allow the declared properties</td>
				</tr>
				<tr>
					<td>
						<a href="#DatatypeConstraintComponent"><code>sh:datatype</code></a> and
						<a href="#DatatypeInConstraintComponent"><code>sh:datatypeIn</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Datatype, for literals</td>
				</tr>
				<tr>
					<td><a href="#DisjointConstraintComponent"><code>sh:disjoint</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Property without overlapping values</td>
				</tr>
				<tr>
					<td><a href="#EqualsConstraintComponent"><code>sh:equals</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Property with equal values</td>
				</tr>
				<tr>
					<td><a href="#HasValueConstraintComponent"><code>sh:hasValue</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>A specific required value</td>
				</tr>
				<tr>
					<td><a href="#InConstraintComponent"><code>sh:in</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Enumeration of allowed values</td>
				</tr>
				<tr>
					<td><a href="#LessThanConstraintComponent"><code>sh:lessThan</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Must have lesser values than another property</td>
				</tr>
				<tr>
					<td><a href="#LessThanOrEqualsConstraintComponent"><code>sh:lessThanOrEquals</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Must have lesser or equal values than another property</td>
				</tr>
				<tr>
					<td><a href="#MinCountConstraintComponent"><code>sh:minCount</code></a>, <a href="#MaxCountConstraintComponent"><code>sh:maxCount</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Minimum and maximum cardinality</td>
				</tr>
				<tr>
					<td><a href="#MinLengthConstraintComponent"><code>sh:minLength</code></a>, <a href="#MaxLengthConstraintComponent"><code>sh:maxLength</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Minimum and maximum string length</td>
				</tr>
				<tr>
					<td><a href="#MaxExclusiveConstraintComponent"><code>sh:maxExclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Maximum exclusive value (&gt;)</td>
				</tr>
				<tr>
					<td><a href="#MaxInclusiveConstraintComponent"><code>sh:maxInclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Maximum inclusive value (&gt;=)</td>
				</tr>
				<tr>
					<td><a href="#MinExclusiveConstraintComponent"><code>sh:minExclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Minimum exclusive value (&lt;)</td>
				</tr>
				<tr>
					<td><a href="#MinInclusiveConstraintComponent"><code>sh:minInclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Minimum inclusive value (&lt;=)</td>
				</tr>
				<tr>
					<td><a href="#NodeKindConstraintComponent"><code>sh:nodeKind</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Node kind (IRI, blank node, or literal) of all values</td>
				</tr>
				<tr>
					<td>
						<a href="#NotConstraintComponent"><code>sh:not</code></a>,
						<a href="#AndConstraintComponent"><code>sh:and</code></a> and
						<a href="#OrConstraintComponent"><code>sh:or</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Logical operators on shapes</td>
				</tr>
				<tr>
					<td><a href="#PatternConstraintComponent"><code>sh:pattern</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Regular expression string matching</td>
				</tr>
				<tr>
					<td><a href="#StemConstraintComponent"><code>sh:stem</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>IRIs must start with the given string</td>
				</tr>
				<tr>
					<td><a href="#UniqueLangConstraintComponent"><code>sh:uniqueLang</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>No duplicate language tags</td>
				</tr>
				<tr>
					<td><a href="#ValueShapeConstraintComponent"><code>sh:valueShape</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Nested shape of all values</td>
				</tr>
				<tr>
					<td><a href="#QualifiedValueShapeConstraintComponent"><code>sh:qualifiedValueShape</code>, <code>sh:qualifiedMinCount</code>, <code>sh:qualifiedMaxCount</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Nested shape of a given minimum/maximum number of values</td>
				</tr>
			</table>

			<section id="constraints-value-type">
				<h3>Value Type Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they define restrictions
					on the type of the nodes.
				</p>
				<p class="issue" data-number="141" title="How to represent mixed datatype-or-class ranges">
					It is an open issue how to best represent properties that may either take a literal or a non-literal.
				</p>
				<section id="ClassConstraintComponent">
					<h4>sh:class</h4>
					<p>
						The property <code>sh:class</code> can be used to verify that each <span class="term">value node</span> is a <a>SHACL instance</a> of a given type.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClassConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:class</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if it has an <code>rdf:type</code> value that is the given type or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code> triples in the <a>data graph</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* $class } .
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:class ex:ClassA ;
	] .</pre>

					<pre class="example-data">
ex:InstanceOfClassA
	a ex:ClassA .

ex:ClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA .</pre>
				</section>
				<section id="ClassInConstraintComponent">
					<h4>sh:classIn</h4>
					<p>
						The property <code>sh:classIn</code> can be used to verify that each <span class="term">value node</span> is a <a>SHACL instance</a> of a type from a given list.
						The values of <code>sh:classIn</code> must be lists of resources.
						<code>sh:classIn</code> is a generalization of <code>sh:class</code> allowing users to state that the values must have at least one out of several types.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClassInConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:classIn</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>List of types of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if it has an <code>rdf:type</code> value that is one of the types from the list or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code> in the <a>data graph</a>.
							Each type from the list is tested using the same logic as <code>sh:class</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isLiteral(?value) || NOT EXISTS {
			GRAPH $shapesGraph {
				$classIn (rdf:rest*)/rdf:first ?class .
			}
			FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* ?class }
		})
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassInExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:classIn ( ex:ClassA ex:ClassB ) ;
	] .</pre>

					<pre class="example-data">
ex:InstanceOfClassA
	a ex:ClassA .

ex:InstanceOfClassB
	a ex:ClassB .

ex:ClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA ;
	ex:someProperty ex:InstanceOfClassB .</pre>
				</section>
				<section id="DatatypeConstraintComponent">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all <span class="term">value nodes</span>.
						The values of <code>sh:datatype</code> must be resources representing datatypes, such as <code>xsd:string</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DatatypeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Datatype of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is not a literal, or is a literal with a mismatching datatype.
							A literal matches a datatype if the literal's datatype has the same IRI.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		{
			FILTER isLiteral(?value) .
		} .
		BIND (datatype(?value) AS ?valueDatatype) .
		FILTER (?valueDatatype = $datatype) .
	}
}</pre>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatype property constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatype xsd:string ;
	] .</pre>

					<pre class="example-data">
ex:DatatypeShapeExampleValidResource
	ex:someProperty "Some value" .

ex:DatatypeShapeExampleInvalidResource
	ex:someProperty "Value with language tag"@en ;
	ex:someProperty 42 .</pre>
				</section>
				<section id="DatatypeInConstraintComponent">
					<h4>sh:datatypeIn</h4>
					<p>
						The property <code>sh:datatypeIn</code> can be used to restrict the datatype of all <span class="term">value nodes</span>.
						The values of <code>sh:datatypeIn</code> must be lists of resources representing datatypes, such as <code>xsd:string</code>.
						<code>sh:datatypeIn</code> is a generalization of <code>sh:datatype</code> allowing users to state that the values must have one out of several datatypes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DatatypeInConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>Allowed datatypes of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is not a literal, or is a literal with a mismatching datatype.
							A literal matches if the literal's datatype is member of the provided datatypes list.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isLiteral(?value) || NOT EXISTS {
			GRAPH $shapesGraph {
				$datatypeIn (rdf:rest*)/rdf:first ?datatype .
			} 
			BIND (datatype(?value) AS ?valueDatatype) .
			FILTER (?valueDatatype = $datatype) .
		})
	}
}</pre>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatypeIn property constraint">
ex:DatatypeInExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatypeIn ( xsd:string rdf:langString ) ;
	] .</pre>

					<pre class="example-data">
ex:DatatypeInShapeExampleValidResource
	ex:someProperty "Value with language tag"@en ;
	ex:someProperty "Some string value" .

ex:DatatypeInShapeExampleInvalidResource
	ex:someProperty 42 .</pre>
				</section>
				<section id="NodeKindConstraintComponent">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> is used to restrict the RDF node kind of each <span class="term">value node</span>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NodeKindConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td><code>sh:NodeKind</code></td>
							<td>Node kind (IRI, blank node, literal or combinations of these) of all value nodes</td>
						</tr>
					</table>
					<p>
						The values of <code>sh:nodeKind</code> must be <a>SHACL instances</a> of the class <code>sh:NodeKind</code>.
						The SHACL system vocabulary defines that <code>sh:NodeKind</code> has exactly six possible values:
						<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code> as well as the
						following values that represent combinations of the former three, i.e. either-or:
						<code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code> and <code>sh:IRIOrLiteral</code>.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that does not match the given node kind.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		FILTER ((isIRI(?value) &amp;&amp; $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
				(isLiteral(?value) &amp;&amp; $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
				(isBlank(?value)   &amp;&amp; $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:nodeKind ex:IRI ;
	] .</pre>

					<pre class="example-data">
ex:NodeKindShapeExampleValidResource
	ex:someProperty ex:SomeIRI .

ex:NodeKindShapeExampleInvalidResource
	ex:someProperty ex:SomeIRI ;
	ex:someProperty "A literal" .</pre>
				</section>
			</section>

			<section id="constraints-count">
				<h3>Cardinality Constraint Components</h3>
				<p>
					The constraint components in this section can be applied to either a property constraint or an inverse property
					constraints, to represent restrictions on the number of values that the focus node may have for these properties.
				</p>
				<section id="MinCountConstraintComponent">
					<h4>sh:minCount</h4>
					<p>
						The property <code>sh:minCount</code> restricts the number of triples involving the <span class="term">focus node</span> and a given predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinCountConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum cardinality. If the value is 0 then this constraint is always satisfied and so may be omitted.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of
							<span class="term">value nodes</span> is less than the value of <code>sh:minCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &lt; $minCount)
}</pre>
					</div>
					<pre class="example-shapes">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
				<section id="MaxCountConstraintComponent">
					<h4>sh:maxCount</h4>
					<p>
						The property <code>sh:maxCount</code> restricts the number of triples involving the <span class="term">focus node</span> and a given predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxCountConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum cardinality. If this parameter is omitted then there is no limit on the number of triples.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of
							<span class="term">value nodes</span> is greater than the value of <code>sh:maxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &gt; $maxCount))
}</pre>
					</div>
					<pre class="example-shapes">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:maxCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
			</section>
			
			<section id="constraints-range">
				<h3>Value Range Constraint Components</h3>
				<p>
					The following constraint components represent range restrictions on node that are comparable
					via operators such as <code>&lt;</code> and <code>&gt;</code>.
				</p>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						The supported datatypes of these properties are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<p>
						<span class="component-class">Constraint Components:</span> <code>sh:MinExclusiveConstraintComponent</code>, <code>sh:MinInclusiveConstraintComponent</code>, <code>sh:MaxExclusiveConstraintComponent</code>, <code>sh:MaxInclusiveConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="MinExclusiveConstraintComponent">
							<td><code>sh:minExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code></td>
						</tr>
						<tr id="MinInclusiveConstraintComponent">
							<td><code>sh:minInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code></td>
						</tr>
						<tr id="MaxExclusiveConstraintComponent">
							<td><code>sh:maxExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code></td>
						</tr>
						<tr id="MaxInclusiveConstraintComponent">
							<td><code>sh:maxInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <span class="term">validation result</span> must also be produced if the node cannot be compared to the specified range.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the validation engine will produce a validation result.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<p>
						The following SPARQL definition covers <code>sh:minExclusive</code> - the other variations can be derived by replacing the <code>&gt;</code> operator.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	BIND (?value &gt; $minExclusive AS ?result) .
	FILTER (!?result || !bound(?result)) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minInclusive 1 ;
		sh:maxInclusive 10 ;
	] .</pre>

					<pre class="example-data">
ex:NumericExampleValidResource
	ex:someProperty 7 .

ex:NumericExampleInvalidResource1
	ex:someProperty 11 .

ex:NumericExampleInvalidResource2
	ex:someProperty "a string" .</pre>
				</section>
			</section>

			<section id="constraints-string">
				<h3>String-based Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they are representing
					restrictions on the string representation of certain nodes.
				</p>
				<section id="MinLengthConstraintComponent">
					<h4>sh:minLength</h4>
					<p>
						The property <code>sh:minLength</code> restricts the string length of <span class="term">value nodes</span>.
						This can be applied to any type of literal and IRIs, but not for blank nodes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinLengthConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum length. If the value is 0 then there is no restriction on the string length but this constraint is still violated if the node is a blank node.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is less than the specified minimum length, or if the node is a blank node.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &lt; $minLength) .
}</pre>
					</div>
				</section>
				<section id="MaxLengthConstraintComponent">
					<h4>sh:maxLength</h4>
					<p>
						The property <code>sh:maxLength</code> restrict the string length of <span class="term">value nodes</span>
						This can be applied to any type of literal and IRIs, but not for blank nodes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxLengthConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum length. If this constraint is omitted then there is no restriction on the string length and no requirement that the node is a literal or IRI.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is greater than the specified maximum length, or if the node is a blank node.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &gt; $minLength) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
		rdfs:comment "Password must be between 8 and 10 characters long" ;
	] .</pre>

					<pre class="example-data">
ex:PasswordExampleValidResource
	ex:password "password" .</pre>
				</section>
				<section id="PatternConstraintComponent">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to validate whether all <span class="term">value nodes</span> match a given regular expression.
						The values of <code>sh:pattern</code> must be valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:PatternConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td><code>xsd:string</code></td>
							<td>Regular expression that all value nodes must match</td>
						</tr>
						<tr>
							<td><code>sh:flags</code></td>
							<td><code>xsd:string</code> (optional)</td>
							<td>An optional string of flags, interpreted as in <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL 1.1 REGEX</a></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							If <code>sh:flags</code> is present then this must be interpreted according to the SPARQL REGEX function. 
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || IF(bound($flags), !regex(str(?value), $pattern, $flags), !regex(str(?value), $pattern))) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PatternExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:pattern "^Ali" ;
		sh:flags "i" ;       # Ignore case
	] .</pre>
					<pre class="example-data">
ex:PatternShapeExampleValidResource
	ex:someProperty "alice" .

ex:PatternShapeExampleInvalidResource
	ex:someProperty "The Alice" .</pre>
				</section>
				<section id="StemConstraintComponent">
					<h4>sh:stem</h4>
					<p>
						The property <code>sh:stem</code> validates whether all <span class="term">value nodes</span> are IRIs and the IRI starts with a given string value.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:StemConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:stem</code></td>
							<td><code>xsd:string</code></td>
							<td>String value that an IRI must start with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is not an IRI or the <a href="https://www.w3.org/TR/sparql11-query/#func-str">string representation</a> of the IRI value does not <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#func-strstarts">start with</a> the given string.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isIRI(?value) || !STRSTARTS(str(?value), $stem) ) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PatternExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:w3cHomepage ;
		sh:stem "https://www.w3.org/People/" ;
	] .</pre>
					<pre class="example-data">
ex:Alice ex:w3cHomepage &lt;https://www.w3.org/People/Alice&gt; .
<span class="focus-node-error">ex:Bob</span> ex:w3cHomepage &lt;https://example.com/People/Bob&gt; .
<span class="focus-node-error">ex:Carol</span> ex:w3cHomepage "https://www.w3.org/People/Carol" .</pre>
				</section>
				<section id="UniqueLangConstraintComponent">
					<h4>sh:uniqueLang</h4>
					<p>
						The property <code>sh:uniqueLang</code> can be set to <code>true</code> to specify that no pair of value nodes may use the same language tag.
						The values of <code>sh:uniqueLang</code> must be <code>xsd:boolean</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:UniqueLangConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:uniqueLang</code></td>
							<td><code>xsd:boolean</code></td>
							<td><code>true</code> to activate this constraint</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:uniqueLang</code> is set to <code>true</code> then a <span class="term">validation result</span> must be produced for each non-empty language tag that is
							used by at least two <span class="term">value nodes</span>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ($this AS ?subject) $predicate
WHERE {
	{
		FILTER ($uniqueLang) .
	}
	$this $predicate ?value .
	BIND (lang(?value) AS ?lang) .
	FILTER (bound(?lang) &amp;&amp; ?lang != "") . 
	FILTER EXISTS {
		$this $predicate ?otherValue .
		FILTER (?otherValue != ?value &amp;&amp; ?lang = lang(?otherValue)) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:UniqueLangExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:uniqueLang true ;
	] .</pre>

					<pre class="example-data">
ex:UniqueLangShapeExampleValidResource
	ex:someProperty "Me" ;
	ex:someProperty "Me"@en ;
	ex:someProperty "Moi"@fr .

ex:UniqueLangShapeExampleInvalidResource
	ex:someProperty "Me"@en ;
	ex:someProperty "Myself"@en .</pre>
				</section>
			</section>
			
			<section id="constraints-property-pairs">
				<h3>Property Pair Constraint Components</h3>
				<p>
					The constraint components in this section restrict the sets of values represented by
					the <code>sh:predicate</code> used in the property constraint, and another property
					that is specified as the value of the respective parameter such as <code>sh:equals</code>.
				</p>
				<p class="issue" data-number="136" title="Naming of property pair constraint components">
					The names of the following properties have been the source of confusion and may get renamed.
				</p>
				<section id="EqualsConstraintComponent">
					<h3>sh:equals</h3>
					<p>
						<code>sh:equals</code> constrains a pair of properties so that the sets of values of both properties at a given focus node must be equal.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:EqualsConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:equals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Property to compare with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced
							for each value of <code>sh:predicate</code> that does not exist as value of <code>sh:equals</code> and
							for each value of <code>sh:equals</code> that does not exist as value of <code>sh:predicate</code>
							at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the corresponding values of the existing triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	{
		$this $predicate ?object .
		FILTER NOT EXISTS {
			$this $equals ?object .
		}
	}
	UNION
	{
		$this $equals ?object .
		FILTER NOT EXISTS {
			$this $predicate ?object .
		}
	}
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:equals</code> in a shape to verify
						that certain nodes must have the same set of values for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:EqualExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:equals ex:givenName ;
	] .</pre>
					<pre class="example-data">
ex:ValidInstance1
	ex:firstName "John" ;
	ex:givenName "John" .</pre>
				</section>
				<section id="DisjointConstraintComponent">
					<h3>sh:disjoint</h3>
					<p>
						<code>sh:disjoint</code> constrains a pair of properties so that the sets of values of both properties at a given focus node must not share any values.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DisjointConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:disjoint</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each value of <code>sh:predicate</code>
							that also exists as value of <code>sh:disjoint</code> at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $disjoint ?object .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:disjoint</code> in a shape to verify
						that certain nodes must not share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<pre class="example-shapes">
ex:DisjointExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:disjoint ex:altLabel ;
	] .</pre>
					<pre class="example-data">
ex:ValidInstance1
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

ex:InvalidInstance1
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .</pre>
				</section>
				<section id="LessThanConstraintComponent">
					<h3>sh:lessThan</h3>
					<p>
						<code>sh:lessThan</code> constrains a pair of properties so that the values of the first property must be smaller than the values of the second property at a given focus node.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThan</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate</code>
							and <code>sh:lessThan</code> at the given <span class="term">focus node</span>, where
							the first value is not less than the second value, based on SPARQL's <code>&lt;</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value of <code>sh:predicate</code> as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThan ?object2 .
	FILTER (!(?object &lt; ?object2)) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:lessThan</code> in a shape to verify
						that all values of <code>ex:startDate</code> must "before" the values of <code>ex:endDate</code>.
					</p>
					<pre class="example-shapes">
ex:LessThanExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:startDate ;
		sh:lessThan ex:endDate ;
	] .</pre>
				</section>
				<section id="LessThanOrEqualsConstraintComponent">
					<h3>sh:lessThanOrEquals</h3>
					<p>
						<code>sh:lessThanOrEquals</code> constrains a pair of properties so that the values of the first property must be smaller than or equal to the values of the second property at a given focus node.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanOrEqualsConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThanOrEquals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate</code>
							and <code>sh:lessThanOrEquals</code> at the given <span class="term">focus node</span>, where
							the first value is not less than or equal to the second value, based on SPARQL's <code>&lt;=</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value of the first predicate as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThanOrEquals ?object2 .
	FILTER (!(?object &lt;= ?object2)) .
}</pre>
					</div>
				</section>
			</section>				
	
			<section id="constraints-logical">
				<h3>Logical Constraint Components</h3>
				<p>
					The constraint components implement the common logical operators <span class="term">and</span>,
					<span class="term">or</span> and <span class="term">not</span>.
				</p>
				<p class="issue" data-number="135" title="Should sh:and/sh:or/sh:not support constraints too">
					There is a proposal to generalize the following components to also allow their values to be constraints, not just shapes.
				</p>
				<section id="NotConstraintComponent">
					<h3>sh:not</h3>
					<p>
						SHACL supports a high-level negation constraint that can be used to verify that the <span class="term">focus node</span> does not have a given shape.
						This is comparable to a logical "not" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NotConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:not</code></td>
							<td><code>sh:Shape</code></td>
							<td>The shape to negate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span> that produces no validation results with severity <code>sh:Violation</code> for the shape given via <code>sh:not</code>.
							A <span class="term">failure</span> must be reported if the validation of the shape produces a failure.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for node constraints)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	BIND (sh:hasShape($this, $not, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || ?hasShape) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:not</code> in a shape to verify
						that certain nodes cannot have any value of <code>ex:property</code>.
					</p>
					<pre class="example-shapes">
ex:NotExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:not [
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:minCount 1 ;
			] ;
		]
	] .</pre>
					<pre class="example-data">
ex:InvalidInstance1
  	ex:property "Some value" .</pre>
				</section>
				<section id="AndConstraintComponent">
					<h3>sh:and</h3>
					<p>
						SHACL supports a high-level syntax for conjunctive constraints that can be used to test whether the <span class="term">focus node</span> has all out of several shapes.
						This is comparable to a logical "and" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:AndConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:and</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the shapes in the <code>sh:and</code> list produces a validation result with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for node constraints)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$and rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(!?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:and</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:and</code> in a shape to verify
						that certain nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
						the minimum count, and a blank node shape that further constrains the maximum count.
						As shown here, <code>sh:and</code> can be used to implement a specialization mechanism between shapes. 
					</p>
					<pre class="example-shapes">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:constraint [
		sh:and (
			ex:SuperShape
			[
				a sh:Shape ;
				sh:property [
					sh:predicate ex:property ;
					sh:maxCount 1 ;
				]
			]
		)
	] .</pre>

<pre class="example-data">
ex:ValidInstance1
	ex:property "One" .

# Invalid: more than one property
ex:InvalidInstance2
	ex:property "One" ;
	ex:property "Two" .</pre>
				</section>
				<section id="OrConstraintComponent">
					<h3>sh:or</h3>
					<p>
						SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether the <span class="term">focus node</span> has at least one out of several shapes.
						This is comparable to a logical "or" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:OrConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:or</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the shapes in the <code>sh:or</code> list produces no validation results with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for node constraints)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$or rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count = 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:or</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:or</code> in a shape to verify
						that certain nodes have at least one value of <code>ex:exampleProperty1</code>
						or at least one value of <code>ex:exampleProperty2</code>.
					</p>
					<pre class="example-shapes">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:or (
			[
				sh:property [
					sh:predicate ex:exampleProperty1 ;
					sh:minCount 1 ;
				]
			]
			[
				sh:property [
					sh:predicate ex:exampleProperty2 ;
					sh:minCount 1 ;
				]
			]
		)
	] .</pre>

					<pre class="example-data">
ex:OrConstraintExampleValidResource
	ex:exampleProperty1 ex:someValue .</pre>
				</section>
			</section>
	
			<section id="constraints-shape">
				<h3>Shape-based Constraint Components</h3>
				<p>
					The constraint components in this section can be used to represent complex restrictions
					based on applying shape definitions on the property values. 
				</p>
				<section id="ValueShapeConstraintComponent">
					<h4>sh:valueShape</h4>
					<p>
						The property <code>sh:valueShape</code> can be used verify that all values of the given property must have a given shape.
						The value type of <code>sh:valueShape</code> is <code>sh:Shape</code>, but the <code>rdf:type</code> triple of those shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ValueShapeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:valueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where validating the value node against the shape specified by <code>sh:valueShape</code> 
							produces any validation results with severity <code>sh:Violation</code>.
							A <span class="term">failure</span> must be produced if the validation of any <span class="term">value node</span> has produced a failure.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object ?failure
WHERE {
	$this $predicate ?object .
	BIND (sh:hasShape(?object, $valueShape, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || !?hasShape) .
}</pre>
					</div>
					<p class="issue" data-number="22" title="Treatment of recursive shape definitions">
						According to resolution <a href="https://www.w3.org/2015/12/16-shapes-minutes.html#resolution04">2015.12.16/04</a> shapes graphs with dependency loops are invalid and suitable limitations of this will be explored.
						Until issue 22 is closed, definitions regarding recursion are not endorsed by the WG.
					</p>
					<p>
						A shape may refer to itself directly or indirectly via <code>sh:valueShape</code>, <code>sh:filterShape</code>, etc.
						Such a shape is said to be <em>recursive</em>.
						The meaning of non-recursive shapes is always well-founded.
						In contrast, the meaning of a recursive shape may not be well-founded.
						As a starting point, the SHACL specification only defines the meaning of non-recursive shapes.
						However, there are use-cases where recursion is valuable, either for its inherent expressive power or because it makes the
						intension of shapes clearer.
						The Working Group will therefore explore conditions under which recursive shapes can be assigned a well-defined meaning and will
						relax the restrictions on recursion accordingly. 
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> will validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example-shapes">
ex:ValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueShape [
			a sh:Shape ;   # Optional
			sh:predicate [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .</pre>

					<pre class="example-data">
ex:ValueShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				<section id="QualifiedValueShapeConstraintComponent">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<div class="issue" data-number="92" title="Relationship of QCRs with Partitions">
						Feature at risk:
						There is an ongoing proposal (see sh:partition) that strongly overlaps with the QCRs proposed here.
						The WG may decide to support only one of these options, but not both.
					</div>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a certain number  of values of the given property must have a given shape.
						The value type of <code>sh:qualifiedValueShape</code> is <code>sh:Shape</code>, and it needs to be accompanied by
						a <code>sh:qualifiedMinCount</code> or a <code>sh:qualifiedMaxCount</code> (both typed <code>xsd:integer</code>), or both.
						The <code>rdf:type</code> of the value shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:QualifiedValueShapeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of the specified values</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum number of values that must have the shape. If this constraint is omitted then there is no minimum number of values required. </td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum number of values that can have the shape. If this constraint is omitted then there is no maximum number of values required.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMinCount</div>
						<div class="def-text-body">
							Let <code>C</code> be the number of <span class="term">value nodes</span> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no validation results with severity <code>sh:Violation</code>.
							A <span class="term">failure</span> must be produced if the validation of any of the value nodes produces a failure.
							A <span class="term">validation result</span> must be produced if <code>C</code>
							is less than the specified <code>sh:qualifiedMinCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMinCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &lt; $qualifiedMinCount) .
}</pre>
					</div>
					<p>
						Note that in the SPARQL query above, we assume that the <code>SUM</code> operation fails
						if one of the values of <code>?s</code> is not a number.
						This mechanism is used by the error handling, which sets <code>?s</code> to the string <code>'error'</code>
						whenever one of the individual <code>sh:hasShape</code> calls fails.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMaxCount</div>
						<div class="def-text-body">
							Let <code>C</code> be the number of <span class="term">value nodes</span> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no validation results with severity <code>sh:Violation</code>.
							A <span class="term">failure</span> must be produced if the validation of any of the value nodes produces a failure.
							A <span class="term">validation result</span> must be produced if <code>C</code>
							is greater than the specified <code>sh:qualifiedMaxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMaxCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; $qualifiedMaxCount) .
}</pre>
					</div>
					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example-shapes">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>
				<section id="PartitionConstraintComponent">
					<h4>sh:partition</h4>
					<div class="issue" data-number="92" title="Under Development">
						This section is one proposal to resolve ISSUE-92.
					</div>
					<p>
						In some cases a given property may be multi-valued and it may be required that the set of values
						be partitioned into two or more subsets, each of which satisfies certain constraints.
					</p>
					<p>
						For example, suppose that in the Library of Congress BIBFRAME (<code>bf:</code>) Cultural Heritage vocabulary each person (<code>bf:Person</code>) must be identified by 
						(<code>bf:identifiedBy</code>) exactly one identifier from <code>id.loc.gov</code> and may have another identifier
						from <code>viaf.org</code>. No other identifiers are allowed. Thus the set of all identifiers is partitioned into
						two subsets, the first of which contains exactly one member and the second of which contains zero or one members.
						The following example shows a snippet of some valid BIBFRAME data.
					</p>
					<pre class="example-data" title="Valid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> .</pre>
					<p>
						The following example shows a snippet of some invalid BIBFRAME data.
					</p>
					<pre class="example-data" title="Invalid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> ;
	bf:identifiedBy "this is a mistake" . # should be an error</pre>
					<p>
						Qualified cardinality constraints provide a basis for expressing this type of partitioning requirement, but using them imposes a burden on the shapes author. In the BIBFRAME example the author would need to express the requirement that the set of all identifiers that are from neither <code>id.loc.gov</code> nor <code>viaf.org</code> is empty, i.e. it has a maximum cardinality of 0. Clearly, as more subsets of values are involved, the burden on the author increases.
						The <code>sh:partition</code> constraint makes it easier to express this type of requirement than it would be to use 
						multiple qualified cardinality constraints.
						In effect, <code>sh:partition</code> chains together a sequence of qualified cardinality constraints and removes the set of context nodes matched by each from further consideration. If every context node gets matched in this process, then
						the <code>sh:partition</code> constraint reports no violations. Otherwise, any context nodes remaining are reported as
						violations of the constraint.
						The BIBFRAME example constraint is expressed as follows.
					</p>
					<pre class="example-shapes" title="BIBFRAME constraint expressed using sh:partition">
ex:BibframeShape a sh:Shape ;
	sh:property [
		sh:predicate bf:identifiedBy ;
		sh:partition (
			[sh:minCount 1; sh:maxCount 1; sh:pattern "^http://id.loc.gov/"]
			[sh:maxCount 1; sh:pattern "^https://viaf.org/"]
		)
] .</pre>
					<p>
						The value of the <code>sh:partition</code> constraint parameter MUST be an <code>rdf:List</code> that contains zero or more resources. 
						Each resource in the list defines conditions on a subset of the context nodes and MAY contain the following parameters:
					</p>
					<ul>
						<li>zero or one <code>sh:minCount</code>. This defines the minimum cardinality of the corresponding subset.</li>
						<li>zero or one <code>sh:maxCount</code>. This defines the maximum cardinality of the corresponding subset.</li>
						<li>any combination of parameters associated with node validation constraints. A node validation constraint
							is any constraint defined by a boolean function on nodes. 
							These include the built-in constraints defined by <code>sh:nodeKind</code>, <code>sh:partition</code>,
							<code>sh:minExclusive</code>, etc.
							The corresponding subset consists of those remaining nodes for which the boolean function is <code>true</code>.</li>
					</ul>
					<p>
						Note that a resource that contains no parameters matches all nodes. Such a resource is useful as the last member of the list where it acts as a default matching rule in the case where nodes that do not match any of the preceeding constraints are allowed. 
						Note also that a qualified cardinality constraint defined using <code>sh:qualifiedValueShape</code>,
						<code>sh:qualifiedMinCount</code>, and <code>sh:qualifiedMaxCount</code> is equivalent to a <code>sh:partition</code> constraint that contains two resources with the first one containing the corresponding parameters and the last one being the default matching rule that matches any set of nodes.
					</p>
					<p>
						Each member of the list is used by the SHACL processor to match a subset of the context nodes.
						The SHACL processor matches as many nodes as possible and then compares the result with the specified
						minimum and maximum cardinalities if specified. This is referred to as a <em>greedy</em> matching algorithm.
						Greedy pattern matching is commonly used with textual regular expressions.
						Nodes that match are removed from further matching. Thus the set of all context nodes becomes partitioned by 
						the matching algorithm. The following paragraphs define this algorithm more precisely.
					</p>
					<p>
						Let D be a data graph and let F be a focus node in D. Let S be a shapes graph, let T be a shape in S, 
						and let C be a <code>sh:partition</code> constraint in T. 
						Let N be the set of context nodes for C in D at F. Recall that N depends on how C is related to T. 
					</p>
					<ul>
						<li>If (T, <code>sh:constraint</code>, C) is in S then N consists of just the node F.</li>
						<li>If (T, <code>sh:property</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (F, P, X) is in D.</li>
						<li>If (T, <code>sh:inverseProperty</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (X, P, F) is in D.</li>
					</ul>
					<p>
						Let the value of the <code>sh:partition</code> parameter be the list (Q<sub>1</sub>, ..., Q<sub>n</sub>) of resources.
						The SHACL validator MUST perform the following steps to validate the constraint C at F.
					</p>
					<ol>
						<li>Let R denote the set of remaining context nodes. Initialize R to N.</li>
						<li>Repeat the following for Q = Q<sub>1</sub>, ..., Q<sub>n</sub>
						<ol>
							<li>Let P be the conjunction of all the node validation constraints in Q.</li>
							<li>Compute R' to be the set of all nodes in R that satisfy P, i.e. R' = {X in R | P(X) = true}</li>
							<li>If Q contains a minimum cardinality m<sub>min</sub> and the number of nodes in R' is less than m<sub>min</sub>,
							i.e. m<sub>min</sub> > #R', then report a constraint violation and exit the loop.</li>
							<li>If Q contains a maximum cardinality m<sub>max</sub> and the number of nodes in R' is greater then m<sub>max</sub>,
							i.e. m<sub>max</sub> &lt; #R', then report a constraint violation and exit the loop.</li>
							<li>Remove R' from R, i.e. set R = R \ R'.</li>
						</ol>
						</li>
						<li>If R is non-empty and no violations have been reported yet then report a violation.</li>
					</ol>
					<p>
						Note that the order of resources within the list is significant. 
						In general, if the members of the list are reordered then different context node sets will be matched
						and different violation results will be reported.
					</p>
				</section>
			</section>
			
			<section id="constraints-others">
				<h3>Other Constraint Components</h3>
				<p>
					This section enumerates core constraint components that did not fit into the other categories.
				</p>
				<section id="ClosedConstraintComponent">
					<h3>sh:closed, sh:ignoredProperties</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any resource can in principle have values for any property.
						However, in some cases it makes sense to restrict which properties can be applied to resources.
						The SHACL core language includes a property called <code>sh:closed</code> that can be assigned to
						a shape via the property <code>sh:constraint</code> to indicate that valid resources must only have
						values for those properties that have been explicitly declared via <code>sh:property</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClosedConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:closed</code></td>
							<td><code>xsd:boolean</code></td>
							<td>Set to <code>true</code> to close the shape</td>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td><code>rdf:List</code> (members: <code>rdf:Property</code>)</td>
							<td>Optional list of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
						</tr>
					</table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:closed</code> is <code>true</code> then
							a <span class="term">validation result</span> must be produced for each triple that has the <span class="term">focus node</span> as its
							<span class="term">subject</span> and a <span class="term">predicate</span> that is not explicitly enumerated as a <code>sh:predicate</code>
							of the <code>sh:property</code> constraints at the surrounding shape.
							If the parameter <code>sh:ignoredProperties</code> is present then the properties enumerated in this list are also permitted.
							The produced <span class="term">validation result</span> must have the corresponding values of the triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<p>
						The core vocabulary includes an instance of <code>sh:NodeConstraint</code> called <code>sh:Closed</code>
						that can be used in places where no other parameters such as <code>sh:ignoredProperties</code> are needed.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ?predicate ?object
WHERE {
	{
		FILTER $closed .
	}
	$this ?predicate ?object .
	FILTER (NOT EXISTS {
		GRAPH $shapesGraph {
			$currentShape sh:property/sh:predicate ?predicate .
		}
	} &amp;&amp; (!bound($ignoredProperties) || NOT EXISTS {
		GRAPH $shapesGraph {
			$ignoredProperties rdf:rest*/rdf:first ?predicate .
		}
	}))
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:closed</code> in a shape to verify
						that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
						The "ignored" property <code>rdf:type</code> would also be allowed.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:closed true ;
		sh:ignoredProperties (rdf:type) ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .</pre>

					<pre class="example-data">
ex:ClosedShapeExampleValidResource
	ex:exampleProperty1 ex:someValue .

ex:ClosedShapeExampleInvalidResource
	ex:exampleProperty2 ex:someValue ;
	ex:someOtherProperty 42 .</pre>
					<p>
						The next example illustrates a more compact syntax using the built-in instance <code>sh:Closed</code>.
						In this form, no ignored properties can be specified.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint sh:Closed ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .</pre>
				</section>
				<section id="HasValueConstraintComponent">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify
						that the <span class="term">focus node</span> has a given RDF node among the values of the given
						predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:HasValueConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>any</td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the <code>sh:hasValue</code> is not among the <span class="term">value nodes</span>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	FILTER NOT EXISTS {
		$this $predicate $hasValue .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .</pre>

					<pre class="example-data">
ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
				</section>
				<section id="InConstraintComponent">
					<h4>sh:in</h4>
					<p>
						The property <code>sh:in</code> exclusively enumerates the value nodes that a property may have.
						When specified, each value of the given property must be a member of the specified list.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:InConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Contexts:</span> <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:in</code></td>
							<td><code>rdf:List</code></td>
							<td>Enumeration of allowed values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:in</code> must be well-formed <code>rdf:List</code>s.
							The members of that <code>rdf:List</code> must not be blank nodes.
							A <span class="term">validation result</span> must be produced for every <span class="term">value node</span>
							that is not a member of the given list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		GRAPH $shapesGraph {
			$in (rdf:rest*)/rdf:first ?value .
		}
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:AllowedValuesExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:in ( ex:Value1 ex:Value2 ex:Value3 ) ;
	] .</pre>

					<pre class="example-data">
ex:InExampleValidResource
	ex:someProperty ex:Value2 .</pre>
				</section>
			</section>
				
			<section id="nonValidation">
				<h4>Non-Validating Constraint Characteristics</h4>
				<p>
					While the previous sections introduced properties that represent validation conditions,
					this section covers properties that are ignored by SHACL validation engines.
					The use of these properties is entirely optional and not subject to formal interpretation contracts.
					They may be used for purposes such as form building, predictable printing of RDF files, etc.
				</p>
				<p id="name">
					Property constraints may have one or more values for <code>sh:name</code> to provide human-readable labels for the property in the scope where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					For example, if a form displays a resource that is in the scope of a given shape, and the shape defines a <code>sh:property</code> constraint with an <code>sh:name</code>, then the tool SHOULD use the provided name.
					Similarly, property constraints may have an <code>sh:description</code> to provide a description of the property in the given context.
					Both <code>sh:name</code> and <code>sh:description</code> may have multiple values, but SHOULD only have one value per language tag.
				</p>
				<p id="order">
					Property constraints may have one value for the property <code>sh:order</code> to indicate the relative order of the property constraint for purposes such as form building.
					The values of <code>sh:order</code> must be decimals.
					<code>sh:order</code> is not used for validation purposes.
					If present, the recommended use of <code>sh:order</code> is to sort the property constraints in an ascending order, for example so that
					properties with smaller order are placed above (or to the left) of properties with larger order.
				</p>
				<p id="group">
					Property constraints may link to an <a>SHACL instance</a> of the class <code>sh:PropertyGroup</code> using the property <code>sh:group</code> to indicate that
					the constraint belongs to a group of related property constraints.
					Each group may have additional triples that serve application purposes, such as an <code>rdfs:label</code> for form building.
					Groups may also have an <code>sh:order</code> property to indicate the relative ordering of groups within the same form.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but MAY be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code> or <code>sh:class</code> of the same constraint.
				</p>
				<p>
					The following example illustrates the use of these various features together.
				</p>
				<pre class="example-shapes">
ex:PersonFormShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:locality ;
		sh:name "locality" ;
		sh:description "The suburb, city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-US ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] .

ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .

ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .</pre>
				<p>
					A form building application may use the information above to display information as follows:
				</p>
				<div style="background: #f3f3f3; padding: 8px">
					<div style="font-size: 18px; color: #0000a0"><b>Name</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>first name:</b></td>
							<td>John</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>last name:</b></td>
							<td>Doe</td>
						</tr>
					</table>
					<div style="font-size: 18px; padding-top: 6px; color: #0000a0"><b>Address</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>street address:</b></td>
							<td>123 Silverado Ave</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>locality:</b></td>
							<td>Cupertino</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>zip code:</b></td>
							<td>54321</td>
						</tr>
					</table>
				</div>
			</section>
		</section>

		<section id="results">
			<h2>Validation Results Vocabulary</h2>
			<p>
				The output of a SHACL constraint validation process is a set of <span class="term">validation results</span>.
				SHACL includes an RDF vocabulary to represent such results together with
				structural information that may provide guidance on how to fix a violation, as well as
				human-readable messages.
			</p>
			<p>
				The validation results produced by a standards-compliant SHACL validation engine MUST be the product of validation of the <span class="term">data graph</span> only.
				Some engines MAY also report errors in the <span class="term">shapes graph</span>, but those errors MUST NOT be mixed with the data validation results using the same results vocabulary.
			</p>
			<p>
				The following code snippet represents a syntactically correct result that may have been produced by a constraint validation engine:
			</p>
			<pre class="example-results">
ex:ExampleConstraintViolation
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:MyCurrentNode ;
	sh:subject ex:MyCurrentNode ;
	sh:predicate ex:someProperty ;
	sh:object ex:someInvalidValue ;
	sh:message "Incorrect value: expected something else here." .</pre>
			<p>
				Validation results must be <a>SHACL instances</a> of the class <code>sh:ValidationResult</code>.
				Its superclass <code>sh:AbstractResult</code> defines the properties described in the following sub-sections.
				SHACL implementations may produce <a>SHACL instances</a> of other subclasses of <code>sh:AbstractResult</code>, for example
				to report successfully completed constraint checks or accumulated results.
			</p>
			<section id="results-focus-node">
				<h4>sh:focusNode</h4>
				<p>
					Validation results may have a single value for the property <code>sh:focusNode</code> to point to an
					IRI or blank node that has caused the result.
					This represents the <span class="term">focus node</span> that was validated when the validation result was produced.
				</p>
			</section>
			<section id="results-triple">
				<h4>sh:subject, sh:predicate and sh:object</h4>
				<p>
					Validation results are often caused by a single RDF triple, or a predicate in the context of a given subject or object.
					This information can be encoded via the properties <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>,
					each of which can have at most one value.
					<code>sh:predicate</code> can only be present if either <code>sh:subject</code> or <code>sh:object</code> have also been specified.
					If <code>sh:object</code> is unspecified, then the interpretation is that the result is caused by the subject/predicate combination.
					If <code>sh:subject</code> is unspecified, then the interpretation is that the result is caused by the object/predicate combination.
				</p>
			</section>
			<section id="results-source">
				<h4>sh:sourceConstraint, sh:sourceShape and sh:sourceConstraintComponent</h4>
				<p>
					Validation results may link to one <code>sh:Constraint</code> that has caused
					the result, specified via the property <code>sh:sourceConstraint</code>,
					and at the <code>sh:Shape</code> defining the constraint, via <code>sh:sourceShape</code>.
					Validation results may link to the <span class="term">constraint component</span> that caused the result
					via <code>sh:sourceConstraintComponent</code>.
				</p>
			</section>
			<section id="results-detail">
				<h4>sh:detail</h4>
				<p>
					The property <code>sh:detail</code> may link a (parent) result with one or more other
					(child) results that provide further details about the cause of the (parent) result.
					Depending on the capabilities of the constraint validation engine, this may include failures of
					nested constraints that have been evaluated via <code>sh:valueShape</code>.
				</p>
			</section>
			<section id="results-message">
				<h3>sh:message</h3>
				<p>
					Validation results may have values for the property <code>sh:message</code> to communicate
					additional textual details to humans.
					While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
				</p>
			</section>
			<section id="results-severity">
				<h3>sh:severity</h3>
				<p>
					Each validation result must have exactly one of the following values for the property <code>sh:severity</code>.
				</p>
				<table class="term-table">
					<tr>
						<th>Severity</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:Info</code></td>
						<td>An informative message, not a violation.</td>
					</tr>
					<tr>
						<td><code>sh:Warning</code></td>
						<td>A non-critical constraint violation indicating a warning.</td>
					</tr>
					<tr>
						<td><code>sh:Violation</code></td>
						<td>A constraint violation that should be fixed.</td>
					</tr>
				</table>
			</section>
			<section id="severity">
				<h3>Declaring the Severity of a Constraint</h3>
				<p>
					Constraints can specify their severity level using the property <code>sh:severity</code>,
					which must link to one of the severity types.  <code>sh:Violation</code> is the default if unspecified.
					Constraints based on <a href="#constraint-components">constraint components</a> use the <code>sh:severity</code> declared at the component IRI unless overridden at the constraint.
					The following example clarifies this.
				</p>
				<pre class="example-shapes">
ex:MyShape
	a sh:Shape ;
	sh:property [
		# Violations of either minCount and datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# The default severity for sh:maxCount is sh:Violation
		sh:predicate ex:myProperty ;
		sh:maxCount 1 ;
	] ;
.</pre>
			</section>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="part2" style="font-size: 160%; font-weight: bold">Part 2: Advanced Features</h1>
			<p>
				Part 1 of this specification introduced features that are built into the Core of SHACL.
				The goal of this Core was to provide a high-level vocabulary for common use cases to describe shapes.
				However, SHACL also provides mechanisms to go beyond the Core vocabulary and represent constraints and scopes with greater flexibility.
				These mechanisms are described in the following sections.
			</p>
		</div>
		
		<section id="sparql-constraints">
			<h2>SPARQL-based Constraints</h2>
			<p>
				The property <code>sh:constraint</code> provides the most general mechanism to associate a constraint with a shape.
				The values of this property must be <a>SHACL instances</a> of the class <code>sh:Constraint</code>.
			</p>
			<p>
				SHACL supports two general types of constraints:
			</p>
			<ul>
				<li>Constraints based on a high-level vocabulary (<a href="#constraint-components">constraint components</a>), relying on a reusable SPARQL query in the background</li>
				<li>Constraints directly based on a SPARQL query</li>
			</ul>
			<p>
				The following sub-sections are about the latter.
			</p>
			<section id="sparql-constraints-syntax">
				<h3>Syntax of SPARQL-based Constraints</h3>
				<p>
					<code>sh:SPARQLConstraint</code> is a subclass of <code>sh:Constraint</code> and is the class of all SPARQL-based constraints.
					SPARQL-based constraints must have exactly one value for the property <code>sh:sparql</code>.
					The SPARQL queries linked to a <span class="term">constraint</span> via <code>sh:sparql</code> must be string literals that can be parsed into legal SPARQL 1.1 queries	of the query form <code>SELECT</code>.
				</p>
				<p class="issue" data-number="105" title="Defined prefixes">
					There is an ongoing discussion about whether and how to inject prefixes into SPARQL queries,
					so the following paragraph may change.
				</p>
				<p id="sparql-prefixes">
					Before parsing the values of <code>sh:sparql</code>, a SHACL processor must prepend <a href="https://www.w3.org/TR/sparql11-query/#rPrefixDecl"><code>PREFIX</code></a> declarations
					for all namespace prefixes declared via the property <code>sh:prefix</code> in the current <span class="term">shapes graph</span>.
					The subjects of <code>sh:prefix</code> triples must be IRIs, which become the <code>IRIREF</code> in the <code>PREFIX</code> declaration.
					The objects of <code>sh:prefix</code> triples must be string literals, which become the <code>PNAME_NS</code> in the <code>PREFIX</code> declaration.
					For the example shapes graph below, a SHACL processor would produce the line <code>PREFIX ex: &lt;http://example.com/ns#&gt;</code>.
					No such <code>PREFIX</code> must be generated if the SPARQL string already contains a <code>PREFIX</code> statement for the same <span class="term">prefix</span> at the top-level query
					(ignoring prefixes from nested SELECT queries).
					The SHACL processor must produce an <span class="term">error</span> if the <span class="term">shapes graph</span> contains multiple <code>sh:prefix</code> triples with the same object.
					Since the use of <code>sh:prefix</code> triples may lead to conflicts, it is recommended to only use them in closed and controlled environments or for well-established prefixes.
					In the rest of this document, the <code>sh:prefix</code> statements may have been omitted for brevity.
				</p>
				<p>
					The following example illustrates the definition of a <span class="term">SPARQL-based constraint</span>.
				</p>
				<pre class="example-data">
ex:ValidCountry a ex:Country ;
	ex:germanLabel "Spanien"@de .
  
<span class="focus-node-error">ex:InvalidCountry</span> a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<pre class="example-shapes" id="example-sparql-constraint">
&lt;http://example.com/ns#&gt; sh:prefix "ex" .

ex:LanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:constraint [
		a sh:SPARQLConstraint ;
		sh:message "Values must be literals with German language tag." ;
		sh:sparql """
			SELECT $this ($this AS ?subject) (ex:germanLabel AS ?predicate) (?value AS ?object)
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .</pre>
				<p>
					The scope of the shape above includes all <a>SHACL instances</a> of <code>ex:Country</code>.
					For those RDF nodes (represented by the variable <code>$this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
					and verifies that they are literals with a German language code.
					The validation results for the aforementioned data graph is shown below:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:InvalidCountry ;
	sh:subject ex:InvalidCountry ;
	sh:predicate ex:germanLabel ;
	sh:object "Spain"@en ;
	sh:sourceShape ex:LanguageExampleShape ;
	...
]
</pre>
				<p>
					The SPARQL query returns result set rows for all bindings of <code>?value</code> that violate the constraint.
					A validation result is produced for each row in that result set, following the <a href="#sparql-constraints-variables">mapping rules</a> explained later:
					Each validation result will have <code>$this</code> as the <code>sh:focusNode</code> and <code>sh:subject</code>,
					<code>ex:germanLabel</code> as <code>sh:predicate</code> and the violating value as <code>sh:object</code>.
				</p>
				<!--p>
					In the example above, it is assumed that the existing SHACL validation engine is capable of evaluating constraints using SPARQL.
					Additional executable languages such as JavaScript may be provided based on other sets of properties like <code>ex:javaScript</code>,
					but that is outside of the scope of this specification.
				</p-->
			</section>
			<section id="sparql-constraints-prebound">
				<h4>Pre-bound Variables in SPARQL Constraints ($this, $shapesGraph, $currentShape)</h4>
				<p>
					The following table enumerates variables that have special meaning in SPARQL constraints.
					When SPARQL constraints are executed, the validation engine should pre-bind values for these variables.
					A definition of <span class="term">pre-binding</span> can be found in the <a href="#pre-binding">Appendix</a>.
				</p>
				<table class="term-table">
					<tr>
						<th>Variable</th>
						<th>Interpretation</th>
					</tr>
					<tr>
						<td><code>$this</code></td>
						<td>
							The <span class="term">focus node</span>.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$shapesGraph</code></td>
						<td>
							Can be used to query the shapes graph as in <code>GRAPH $shapesGraph { ... }</code>.
							If the shapes graph is a named graph in the same dataset as the data graph then it is the IRI of the shapes graph in the dataset.
							Not all SHACL validation engines need to support this variable.
							Processors that do not support <code>$shapesGraph</code> MUST report an error if they encounter a query that references this variable.
							Use of <code>GRAPH $shapesGraph { ... }</code> should be handled with extreme caution.
							It may result in constraints that are not interoperable across different SHACL validation engines and that may not run on remote RDF datasets.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$currentShape</code></td>
						<td>
							The currently validated shape.  Typically used in conjunction with <code>$shapesGraph</code>.
							The same support policies as for <code>$shapesGraph</code> apply for this variable.
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-variables">
				<h4>Mapping of Result Variables to Validation Results</h4>
				<p>
					If one of the rows of the result set produced by a SELECT query contains the binding <code>true</code>
					for the variable <code>?failure</code>, then the validation engine must signal an error.
				</p>
				<p>
					Otherwise, each row of the result set produced by a SELECT query must be converted into one validation result resource.
					The properties of those resources are derived by the following rules, through a combination of result variables and the properties linked to the constraint itself.
					The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Production Rules</th>
					</tr>
					<tr>
						<td><code>sh:severity</code></td>
						<td>
							<ol>
								<li>The value of <code>sh:severity</code> of the constraint node</li>
								<li>For <span class="term">constraint components</span>, the value of <code>sh:severity</code> of the constraint component resource</li>
								<li><code>sh:Violation</code> as default</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:focusNode</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>$this</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:subject</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?subject</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:predicate</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?predicate</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:object</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?object</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:message</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>?message</code></li>
								<li>
									The values of <code>sh:message</code> of the subject of the <code>sh:sparql</code> triple.
									These values may reference any variable from the SELECT result variables via <code>{?varName}</code>.
									If the constraint is based on a <a href="constraint-components">constraint component</a>, then the component's parameter variables can also be used.
									The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
								</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceConstraint</code></td>
						<td>
							<ol>
								<li>The <span class="term">constraint</span> that was validated against</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceShape</code></td>
						<td>
							<ol>
								<li>The <span class="term">shape</span> that was validated against</li>
							</ol>
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-annotations">
				<h4>Injecting Annotation Properties into Validation Results</h4>
				<p>
					It is possible to inject additional <span class="term">annotation properties</span> into the validation result resources created for each row of the SELECT result sets.
					Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the subject holding the <code>sh:sparql</code> triple.
					The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Value type</th>
						<th>Count</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:annotationProperty</code></td>
						<td><code>rdf:Property</code></td>
						<td><code>1&nbsp;(mandatory)</code></td>
						<td>The annotation property that shall be set</td>
					</tr>
					<tr>
						<td><code>sh:annotationVarName</code></td>
						<td><code>xsd:string</code></td>
						<td><code>0..1</code></td>
						<td>The name of the SPARQL variable to take the values from</td>
					</tr>
					<tr>
						<td><code>sh:annotationValue</code></td>
						<td></td>
						<td><code>0..unlimited</code></td>
						<td>Constant nodes that shall be used as default values</td>
					</tr>
				</table>
				<p>
					For each row of a SELECT result set, a SHACL processor must walk through the declared result annotations.
					The mapping from result annotations to SPARQL variables uses the following rules:
				</p>
				<ol>
					<li>If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the validation engine must look for the variable named after the <code>sh:annotationVarName</code></li>
					<li>Otherwise, the validation engine must derive a variable name from the value of <code>sh:annotationProperty</code> using the same <a href="#template-arguments">local name mechanism</a> as described earlier</li>
				</ol>
				<p>
					If a variable name could be determined, then the validation engine must copy the bindings for the given variable into the constructed validation results for the current row.
					If the variable has no binding in the result set row, then the value of <code>sh:annotationValue</code> must be used, if present.
				</p>
				<p>
					The values of <code>sh:annotationProperty</code> must not be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
				</p>
				<p>
					Here is a slightly complex example, illustrating the use of result annotations.
				</p>
				<pre class="example-shapes">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:scopeNode ex:ExampleRootResource ;
	sh:constraint [
		a sh:SPARQLConstraint ;
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:sparql """
			SELECT $this ?subject (ex:property2 AS ?predicate) (?first AS ?object) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>

				<pre class="example-data">
ex:ExampleRootResource
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
				<p>
					Which produces the following validation result resource:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:ExampleRootResource ;
	sh:subject ex:ExampleValueResource ;
	sh:predicate ex:property2 ;
	sh:object ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:constraint above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
			</section>
		</section>
		
		<section id="constraint-components">
			<h2>SPARQL-based Constraint Components</h2>
			<p>
				SPARQL-based constraints as introduced in the previous section provide a lot of flexibility.
				However, SPARQL-based constraints may be hard to understand for some people or lead to repetition.
				<span class="term">Constraint components</span> are a way to abstract the complexity of SPARQL and define high level reusable components similar to the <a href="#constraints">core constraint components</a>.
				The definition of such constraint components can be represented in the SHACL RDF vocabulary and thus shared and reused.
			</p>
			<p>
				<code>sh:ConstraintComponent</code> is the class of all constraint components.
				Each constraint component must define:
			</p>
			<ul>
				<li>one or more <a href="#constraint-components-parameters">parameters</a> (e.g. <code>sh:class</code>, <code>sh:stem</code>)</li>
				<li>one or more <a href="#constraint-components-context">contexts</a></li>
				<li>one <a href="#constraint-components-validators">validator</a> for each defined context</li>
			</ul>
			<section class="informative">
				<h3>An Example Constraint Component</h3>
				<p>
					The following example demonstrates how SPARQL-based constraint components can be applied to define core elements of the SHACL language itself.
					The example implements <a href="#PatternConstraintComponent"><code>sh:pattern</code> and <code>sh:flags</code></a> using a <a href="#SPARQLAskValidator">SPARQL ASK</a> query to validate that each <span class="term">value node</span> matches a given regular expression.
					Note that this is only an example implementation and should not be considered normative.
				</p>
				<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:PatternConstraintComponent
	a sh:ConstraintComponent ;
	sh:context sh:NodeConstraint, sh:PropertyConstraint, sh:InversePropertyConstraint ;
	sh:parameter [
		sh:predicate sh:pattern ;
		sh:order 0 ;
	] ;
	sh:parameter [
		sh:predicate sh:flags ;
		sh:optional true ;
		sh:order 1 ;
	] ;
	sh:nodeValidator shimpl:hasPattern ;
	sh:propertyValidator shimpl:hasPattern ;
	sh:inversePropertyValidator shimpl:hasPattern .

ex:hasPattern
	a sh:SPARQLAskValidator ;
	sh:message "Value does not match pattern {$pattern}" ;
	sh:sparql "ASK { FILTER (!isBlank($value) &amp;&amp; IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern))) }" .</pre>
				<p>
					The following sections introduce the properties that constraint components may have.
					Some of these properties are independent of SPARQL-based execution and apply
					to constraint components based on other potential extension languages such as JavaScript too.
				</p>
			</section>
			<section id="constraint-components-parameters">
				<h3>Parameters Declaration (sh:parameter)</h3>
				<p>
					The parameters of a constraint component are declared via the property <code>sh:parameter</code>.
					Each parameter must be a <a>SHACL instance</a> of <code>sh:Parameter</code>, but the <code>rdf:type</code> triples can be omitted.
				</p>
				<p class="issue" data-number="107" title="Specifying SPARQL variable name">
					There is an open issue about the relationship between SPARQL variable name and sh:predicate.
					Possible revisions may require an additional property similar to sh:annotationVarName.
				</p>
				<p>
					Each <code>sh:Parameter</code> must have exactly one value <code>p</code> for the property <code>sh:predicate</code> and the value must be an IRI.
					<span id="def-local-name">The <span class="term">local name</span> of an IRI is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the IRI, not immediately preceded by the first colon in the IRI.</span>
					The <span class="term">local names</span> of the values of <code>sh:predicate</code> must fulfill the following conditions (to ensure that a correct mapping from parameters into SPARQL variables is possible):
				</p>
				<ul>
					<li>The <span class="term">local name</span> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Parameter</code> for the same constraint component that has a <code>sh:predicate</code> with the same <span class="term">local name</span></li>
					<li>The <span class="term">local name</span> must not be <code>this</code>, <code>shapesGraph</code> or <code>currentShape</code>.</li>
					<li>The <span class="term">local name</span> must not be <code>subject</code>, <code>predicate</code> or <code>object</code>.</li>
				</ul>
				<p>
					An <code>sh:Parameter</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
					Every <code>sh:ConstraintComponent</code> must have at least one non-optional parameter.
				</p>
				<p>
					The class <code>sh:Parameter</code> is defined as a subclass of <code>sh:PropertyConstraint</code>,
					and all properties that are applicable to property constraints may also be used for parameters.
					This includes descriptive properties such as <code>sh:name</code> and <code>sh:description</code>
					but also constraint parameters such as <code>sh:class</code>.
					Some implementations MAY use these constraint parameters to prevent the execution of constraint components with invalid parameter values.
				</p>
			</section>
			<section id="labelTemplate">
				<h3>Label Templates (sh:labelTemplate)</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used at any <span class="term">constraint component</span> to suggest how they could be rendered to humans.
					The values of <code>sh:labelTemplate</code> must be strings (possibly with language tag) that can reference the values of the declared parameters using the syntax <code>{?varName}</code> or <code>{$varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the parameter.
					At display time, these <code>{...}</code> blocks SHOULD be substituted with the actual parameter values.
					There may be multiple label templates for the same subject, assuming they do not have the same language tags.
				</p>
			</section>
			<section id="constraint-components-context">
				<h3>Constraint Component Context (sh:context)</h3>
				<p>
					Each <code>sh:ConstraintComponent</code> can define one or more contexts with the <code>sh:context</code> predicate.
					The values of <code>sh:Context</code> are restricted to:
				</p>
				<ul>
			    	<li><code>sh:PropertyConstraint</code>, to allow the constraint component parameters in <code>sh:property</code> definitions.</li>
					<li><code>sh:InversePropertyConstraint</code>, to allow the constraint component parameters in <code>sh:inverseProperty</code> definitions.</li>
					<li><code>sh:NodeConstraint</code>, to allow the constraint component parameters in <code>sh:constraint</code> definitions.</li>
				</ul>
			</section>
			<section id="constraint-components-validators">
				<h3>Validators</h3>
				<p>
					For every provided <span class="term">context</span> in the constraint component,
					a suitable <span class="term">validator</span> must be declared.
					Each context defines a dedicated property that links to a validator according to the following table.
				</p>
				<table class="term-table">
					<tr>
						<th>Context</th>
						<th>Validator Property</th>
					</tr>
					<tr>
						<td><code>sh:NodeConstraint</code></td>
						<td><code>sh:nodeValidator</code></td>
					</tr>
					<tr>
						<td><code>sh:PropertyConstraint</code></td>
						<td><code>sh:propertyValidator</code></td>
					</tr>
					<tr>
						<td><code>sh:InversePropertyConstraint</code></td>
						<td><code>sh:inversePropertyValidator</code></td>
					</tr>
				</table>
				<p>
					SHACL includes two types of validators, based on <a href="#SPARQLSelectValidator">SPARQL SELECT</a> or <a href="#SPARQLAskValidator">SPARQL ASK</a> queries.
					For each provided context, one <span class="term">validator</span> must be defined  in the shapes graph.

				</p>
				<section id="SPARQLSelectValidator">
					<h3>Validators based on SPARQL SELECT Queries</h3>
					<p>
						Validators that have the <code>rdf:type</code> <code>sh:SPARQLSelectValidator</code> must point at exactly one string representation of a SPARQL SELECT query via the property <code>sh:sparql</code>.
						The value of <code>sh:sparql</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
					</p>
					<p>
						The following example illustrates the definition of a constraint component based on a SPARQL SELECT query.
						It is a generalized variation of the SPARQL-based example constraint from the <a href="#example-sparql-constraint">section on SPARQL-based constraints</a>.
						That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
						Constraint components make it possible to generalize such scenarios, so that constants get <a href="#pre-binding">pre-bound</a> with <span class="term">parameters</span>.
						This allows the query logic to be reused in multiple places, without having to write any new SPARQL.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingSELECT
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:context sh:PropertyConstraint ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:propertyValidator [
		a sh:SPARQLSelectValidator ;
		sh:message "Values must be literals with language \"{?lang}\"" ;
		sh:sparql """
			SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
			WHERE {
				$this $predicate ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
			}
			"""
	] .</pre>
					<p>
						Once a constraint component has been defined, its parameters can be used in the declared <span class="term">contexts</span>, as illustrated in the following example.
						The <code>sh:context</code> of the given constraint component includes <code>sh:PropertyConstraint</code> which means that the new parameter <code>ex:lang</code> can be used in values of <code>sh:property</code>.
						Furthermore, the SPARQL query can access the provided <code>sh:predicate</code> using the variable <code>$predicate</code>.
					</p>
					<pre class="example-shapes" title="Shape definition using ex:LanguageConstraintComponent">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:property [
		sh:predicate ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:property [
		sh:predicate ex:englishLabel ;
		ex:lang "en" ;
	] .</pre>
					<p>
						The example shape above specifies that all values of <code>ex:germanLabel</code> must carry the language tag <code>de</code>
						while all values of <code>ex:englishLabel</code> must have <code>en</code> as their language.
						These details are specified via two property constraints that provide values for the <code>ex:lang</code> parameter required by the constraint component.
					</p>
					<p id="SPARQLSelectValidator-evaluation">
						A SPARQL-based SHACL validation engine executes the provided SPARQL query with the same <a href="#pre-binding">pre-bound variables</a>
						as outlined in the section for <a href="#sparql-constraints-prebound">SPARQL-based Constraints</a> (<code>$this</code> etc).
						Additionally, the value of each declared <span class="term">parameter</span> of the constraint component needs to be pre-bound for
						the variable derived by the <span class="term">local name</span> of the parameter's <code>sh:predicate</code>.
						For example, if a non-optional parameter declares <code>sh:predicate ex:lang</code> then the variable <code>$lang</code> needs to be pre-bound.
						The result set of the SELECT query is turned into validation results using the same rules as outlined in the section for <a href="#sparql-constraints-variables">SPARQL-based Constraints</a>.
						In addition to the result properties listed in that section, the property <code>sh:sourceConstraintComponent</code> MUST point at the
						IRI of the constraint component that has been evaluated.
						Furthermore, a <code>sh:SPARQLSelectValidator</code> may declare additional <a href="#sparql-constraints-annotations">annotation properties</a> via <code>sh:resultAnnotation</code>.
					</p>
				</section>
				<section id="SPARQLAskValidator">
					<h3>Validators based on SPARQL ASK Queries</h3>
					<p>
						Many constraint components are of the form in which all <span class="term">value nodes</span> are tested individually against some boolean condition.
						Writing SELECT queries for these becomes burdensome, especially if a constraint component can be used in multiple contexts.
						SHACL provides an alternative, more compact syntax for validators based on ASK queries.
					</p>
					<p>
						Validators that have the <code>rdf:type</code> <code>sh:SPARQLAskValidator</code> must point at exactly one string representation of a SPARQL ASK query via the property <code>sh:sparql</code>.
						The value of <code>sh:sparql</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
						The ASK queries are expected to return <code>true</code> if a given <span class="term">value node</span>
						(represented by the pre-bound variable <code>?value</code>) is valid.
					</p>
					<p>
						Prior to evaluation, a SHACL validation engine transforms the provided ASK query into a SELECT query using the following templates.
						The engine drops the ASK keyword, leaving only the fraction between the outermost <code>{...}</code> pair.
						This block then substitutes <code>...</code> in the template.
					</p>
					<p>Template for <code>sh:NodeConstraint</code> context:</p>
					<pre>
	SELECT $this
	WHERE {
		BIND ($this AS ?value) .
		FILTER NOT EXISTS ...
	}</pre>
					<p>Template for <code>sh:PropertyConstraint</code> context:</p>
					<pre>
	SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
	WHERE {
		$this $predicate ?value .
		FILTER NOT EXISTS ...
	}</pre>
					<p>Template for <code>sh:InversePropertyConstraint</code> context:</p>
					<pre>
	SELECT $this ($this AS ?object) $predicate (?value AS ?subject)
	WHERE {
		?value $predicate $this .
		FILTER NOT EXISTS ...
	}</pre>
					<p>
						The templates need to use a different variable than <code>?value</code> if the constraint component has a parameter that would cause <code>?value</code> to be a pre-bound variable.
					</p>
					<p>
						Once the corresponding template has been applied, the resulting SELECT query will be evaluated using the same approach as outlined <a href="#SPARQLSelectValidator-evaluation">above</a>.
						Actual SHACL implementations may of course use a different approach internally, as long as the results are equivalent to the described approach.
					</p>
					<p>
						The following example defines a constraint component using an ASK query.
						Note that the example represents the validator with an IRI node <code>ex:hasLang</code>
						so that it becomes easier to reuse the same validator for both contexts.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingASK
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:context sh:NodeConstraint, sh:PropertyConstraint ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:nodeValidator ex:hasLang ;
	sh:propertyValidator ex:hasLang .
	
ex:hasLang
	a sh:SPARQLAskValidator ;
	sh:message "Values must be literals with language \"{$lang}\"" ;
	sh:sparql """
		ASK {
			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang))
		}
		""" .</pre>
					<p>
						Note that the validation condition implemented by an ASK query is "in the inverse direction" from its SELECT counter-part:
						ASK queries return <code>true</code> for valid value nodes, while SELECT queries return the invalid value nodes.
					</p>
					<p class="todo">
						TODO: The TopBraid SHACL API uses such ASK constraint declarations to install new SPARQL functions.
						Time permitting we could standardize that too, so that people can reuse the same business logic in the queries.
					</p>
				</section>
			</section>

			<section>
				<h3>Evaluation</h3>
				A constraint component is triggered for every <a>SHACL instance</a> of a context that defines all non-optional parameters.
			</section>
		</section>

		<section id="sparql-scopes">
			<h2>SPARQL-based Scopes (sh:scope)</h2>
			<p>
				In addition to the scope classes introduced in the core section, such as <code>sh:PropertyScope</code>,
				SHACL provides facilities to define custom scopes.
				Similar to constraints, scopes may either be <a href="#SPARQLScope"><span class="term">SPARQL-based scopes</span></a> or
				<a href="#SPARQLScopeType"><span class="term">SPARQL-based scope types</span></a> in a higher-level vocabulary.
				All subjects of <code>sh:scope</code> triples must be IRIs.
			</p>
			<section id="SPARQLScope">
				<h3>Scopes using sh:SPARQLScope</h3>
				<p>
					SPARQL-based scopes must be <a>SHACL instances</a> of <code>sh:SPARQLScope</code>, which is a subclass of <code>sh:Scope</code>.
					The SPARQL queries linked to a <span class="term">scope</span> via <code>sh:sparql</code> must be of the query form <code>SELECT</code>.
					The SELECT queries must project to the result variable <code>?this</code>.
					The resulting scope consists of all distinct bindings for the variable <code>?this</code>.
				</p>
				<p>
					The SELECT queries must also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This design makes sure that validation engines can validate whether a given shape applies to a given individual focus node.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based scope that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based scope example">
ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		a sh:SPARQLScope ;
		sh:sparql """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	sh:constraint ...</pre>
			</section>
			<section id="SPARQLScopeType">
				<h3>SPARQL-based Scope Types</h3>
				<p>
					The class <code>sh:ScopeType</code> can be used to define high-level vocabularies for scopes.
					Similar to constraint components, such scopes take <span class="term">parameters</span> that are interpreted when the scope is evaluated.
					The class <code>sh:SPARQLScopeType</code> is a subclass of <code>sh:ScopeType</code> for scope types that define a SPARQL SELECT query via the property <code>sh:sparql</code>.
					Similar to constraint components, the parameter values become <span class="term">pre-bound variables</span> in such SPARQL queries.
					The parameter values of such scopes must not be blank nodes.
					All parameters of scope types are expected to have <code>sh:maxCount 1</code>.
					Similar to constraint components, scope types may also have values for the property <a href="#labelTemplate"><code>sh:labelTemplate</code></a>.
				</p>
				<p>
					The following example defines a new SPARQL-based parameterizable scope class that takes one parameter <code>ex:country</code>
					that gets mapped into the variable <code>$country</code> in the corresponding SPARQL query to determine the resulting focus nodes.
				</p>
				<pre class="example-shapes" title="Parameterized scope example">
ex:PeopleBornInCountryScope
	a sh:SPARQLScopeType ;
	rdfs:subClassOf sh:Scope ;
	sh:labelTemplate "All persons born in {$country}" ;
	sh:parameter [
		sh:predicate ex:country ;
		sh:name "country" ;
		sh:description "The country that the focus nodes must be born in." ;
		sh:class ex:Country ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:sparql """
		SELECT ?this
		WHERE {
			?this a ex:Person .
			?this ex:bornIn $country .
		}
		""" .

ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		a ex:BornInCountryScope ;
		ex:country ex:USA ;
	] ;
	sh:constraint ...</pre>
				<p>
					The set of scope nodes produced by such a scope type consists of all bindings of the variable <code>?this</code> in the result set,
					when the SPARQL SELECT query has been executed with the pre-bound parameter values.
				</p>
			</section>
		</section>
		
		<section id="derivedValues">
			<h2>Derived Values Constraints</h2>
			<p>
				It is a common scenario that certain property values are derived from other values.
				For example, the area of a rectangle must be the product of width and height, or an uncle of a person is a male sibling of a parent.
				SHACL includes a constraint parameter <code>sh:derivedValues</code> that can be used with property and inverse property constraints to define such constraints.
			</p>
			<p>
				<span class="component-class">Constraint Component:</span> <code>sh:DerivedValuesConstraintComponent</code>
			</p>
			<p>
				<span class="parameter-context">Supported Contexts:</span> <code>sh:PropertyConstraint</code>, <code>sh:InversePropertyConstraint</code>.
			</p>
			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>sh:derivedValues</code></td>
					<td><code>sh:ValuesDeriver</code></td>
					<td>An object providing instructions on how to derive the values</td>
				</tr>
			</table>
			<p>
				The values of <code>sh:derivedValues</code> must be <a>SHACL instances</a> of a subclass of <code>sh:ValuesDeriver</code>.
				<code>sh:SPARQLValuesDeriver</code> is the only subclass <code>sh:ValuesDeriver</code> defined by SHACL.
				Each <code>sh:SPARQLValuesDeriver</code> must have exactly one value for the property <code>sh:sparql</code> that can be used to produce the values that the property is expected to have.
				The values of <code>sh:sparql</code> must be SPARQL SELECT queries that project into the variable <code>?value</code> only.
				These queries can access the current focus node via the variable <code>$this</code> and must produce bindings for the variable <code>?value</code> for all derived values.
			</p>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body">
					Let S be the set of nodes produces by the derived values template for the <span class="term">focus node</span>.
					A <span class="term">validation result</span> must be produced for every value of the given property <code>sh:predicate</code>
					that is not in S, and for every member of S that is not a property value.
					The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code>, and the missing or extra value as its <code>sh:object</code>.
					(The same definition applies in the inverse direction if <code>sh:derivedValues</code> is used in an inverse property constraint.)
				</div>
			</div>
			<p>
				The following example illustrates the use of <code>sh:derivedValues</code> to define a restriction
				so that the value of the property <code>ex:area</code> must be the product of the value of <code>ex:width</code> and <code>sh:height</code>.
			</p>
			<pre class="example-shapes" title="A property definition with derived values">
ex:RectangleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:width ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:height ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:area ;
		sh:datatype xsd:integer ;
		sh:derivedValues [
			a sh:SPARQLValuesDeriver ;
			sh:sparql """
				SELECT ?value
				WHERE {
					$this ex:width ?width .
					$this ex:height ?height .
					BIND (?width * ?height AS ?value) .
				}
				""" ;
		] ;
	] .</pre>
		</section>
		
		<section id="functions">
			<h2>SPARQL Functions</h2>
			<p>
				SHACL <span class="term">functions</span> define operations that produce an RDF node based on zero or more parameters and an input RDF Graph (or dataset).
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<section id="sparql-functions-syntax">
				<h3>Syntax of SPARQL Functions</h3>
				<p>
					Functions that encapsulate a SPARQL query must be <a>SHACL instances</a> of <code>sh:SPARQLFunction</code>, which is a subclass of the more general class <code>sh:Function</code>.
					Such functions must provide exactly one value of <code>sh:sparql</code>, linking to a SPARQL query.
				</p>
				<p>
					The following example illustrates the definition of a <span class="term">function</span> based on a simple mathematical SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:exampleFunction
	a sh:SPARQLFunction ;
	rdfs:comment "Computes the sum of its two parameters ?op1 and ?op2." ;
	sh:parameter [
		sh:predicate ex:op1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:parameter [
		sh:predicate ex:op2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:returnType xsd:integer ;
	sh:sparql """
		SELECT ($op1 + $op2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Using the declaration above, SPARQL engines with full SHACL support can install a new SPARQL function based on the SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:exampleFunction(40, 2)</code>, producing <code>42</code>, as illustrated in the following SPARQL query.
				</p>
				<pre class="example-shapes" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject
WHERE {
	?subject ex:myProperty ?value .
	FILTER (ex:exampleFunction(?value, 2) = 42) .
}</pre>
				<p>
					The following sections introduce the properties that such functions may have.
				</p>
			</section>
			<section id="function-parameters">
				<h3>Function Parameters</h3>
				<p>
					The parameters of a function are linked to its <code>sh:Function</code> via the property <code>sh:parameter</code>.
					Each parameter must be a <a>SHACL instance</a> of <code>sh:Parameter</code>, but their <code>rdf:type</code> triple can be omitted.
				</p>
				<p>
					Each <code>sh:Parameter</code> must have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs, and follow the following restrictions:
				</p>
				<ul>
					<li>The <span class="term">local name</span> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Parameter</code> for the same function that has a <code>sh:predicate</code> with the same <span class="term">local name</span></li>
				</ul>
				<p id="parameters-ordering">
					Parameters are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?param1, ?param2)</code>.
					The ordering of function parameters is determined as follows:
				</p>
				<ol>
					<li>Parameters are ordered in ascending order by the numeric values of <code>sh:order</code>.</li>
					<li>Parameters that do not declare an <code>sh:order</code> are placed after those that have.</li>
					<li>Parameters that do not declare an <code>sh:order</code> are ordered by the <span class="term">local names</span> of their declared <code>sh:predicate</code>s.</li>
				</ol>
				<p>
					Each <code>sh:Parameter</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an RDF value type.
				</p>
			</section>
			<section id="function-evaluation">
				<h3>Evaluation of Functions</h3>
				<p>
					Instances of <code>sh:SPARQLFunction</code> must have exactly one value for the property <code>sh:sparql</code>.
					The values of this property must be strings that can be parsed into SPARQL queries of type ASK or SELECT.
					SELECT queries must project exactly one result variable and SHOULD not use the <code>SELECT *</code> syntax.
					In the SPARQL query, the SPARQL processor needs to <span class="term">pre-bind</span> variables based on the provided parameters of the function call.
					For ASK queries, the function's return value is the result of the ASK query execution, i.e. <code>true</code> or <code>false</code>.
					For SELECT queries, the function's return value is the binding of the (single) result variable of the first row in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one row.
					Also note that the result variable may be unbound, making the return value of the function <span class="term">undefined</span>.
				</p>
				<p class="issue" data-number="22" title="Treatment of recursive shape definitions">
					According to resolution <a href="https://www.w3.org/2015/12/16-shapes-minutes.html#resolution04">2015.12.16/04</a> shapes graphs with dependency loops are invalid and suitable limitations of this will be explored.
					Until issue 22 is closed, definitions regarding recursion are not endorsed by the WG.
				</p>
				<p>
					<em>Recursive use of functions is undefined:</em>
					If a SPARQL-based function contains calls to other functions so that the same function with the same combination of parameters would be visited twice
					then the result of the function call is undefined.
					An implementation may either return no result (unbound) or terminate the surrounding SPARQL query with an error.
				</p>
				<p>
					Some processors may ignore the specified <code>sh:sparql</code> query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified <code>sh:sparql</code> query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the <code>sh:sparql</code> query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>

		<section id="entailment">
			<h2>Entailment</h2>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be activated on the data graph.
				However, the property <code>sh:entailment</code> can be used to instruct a SHACL validation engine to ensure that a given entailment is activated on the data graph.
				The values of <code>sh:entailment</code> must be IRIs, with common use cases covered by [[!sparql11-entailment]].
				<!--DK: we can be agnostic on the what the subject is-->
				<!--The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.-->
			</p>
			<p>
				SHACL validation engines are not required to support any entailment regimes.
				If an entailment regime is provided in the data graph which is not supported by the engine, the validation must produce a <span class="term">failure</span>.
			</p>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>
		
		<section id="hasShape" class="appendix">
			<h2>The Function sh:hasShape</h2>
			<div class="issue" data-number="131" title="sh:hasShape">
				The following definition is under discussion.
			</div>
			<p>
				SHACL implementations with full support of the SHACL SPARQL extension mechanism must implement
				a function <code>sh:hasShape</code>, which takes the following parameters:
			</p>
			<table class="term-table">
				<tr>
					<th style="min-width: 200px">Parameter</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>focusNode</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The focus node to validate.</td>
				</tr>
				<tr>
					<td><code>shape</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The shape to validate the focus node against.</td>
				</tr>
				<tr>
					<td><code>shapesGraph</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The IRI of the current <span class="term">shapes graph</span>.</td>
				</tr>
			</table>
			<p>
				An example call of this function is
			</p>
			<pre>
				<code>BIND (sh:hasShape(ex:JohnDoe, ex:PersonShape, $shapesGraph) AS ?hasShape)</code>
			</pre>
			<p>
				None of the parameters can be unbound.
				The result of the <code>sh:hasShape</code> function is either <code>true</code>, <code>false</code> or <span class="term">undefined</span>:
			</p>
			<ul>
				<li><span class="term">undefined</span> if during the execution, any call to <code>sh:hasShape</code> has recursively called <code>sh:hasShape</code> with exactly the same parameters, i.e. the same node/shape/shapesGraph combination. This result indicates a failure.</li>
				<li><code>true</code> if the validation of the <code>focusNode</code> against the given <code>shape</code> produces no validation results with severity <code>sh:Violation</code>.</li>
				<li><code>false</code> if the validation of the <code>focusNode</code> against the given <code>shape</code> produces at least one validation results with severity <code>sh:Violation</code>.</li>
			</ul>
			<p>
				Note that any validation results produced inside of the <code>sh:hasShape</code> function are temporary, i.e. they are not added to the results graph of the surrounding execution environment.
				However, some implementations may add those nested validation results as annotations to the surrounding validation results, via <a href="#results-detail"><code>sh:detail</code></a>.
			</p>
		</section>
		
		<section id="pre-binding" class="appendix">
			<h2>Pre-binding of Variables in SPARQL Queries</h2>
			<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
				The following definition of what pre-binding means has not been approved by the WG yet,
				and is work in progress.
			</p>
			<p>
				Some features of the SPARQL-based extension mechanism of SHACL rely on the concept of <span class="term">pre-binding of variables</span>.
				Although variations of this concept are supported by several existing SPARQL implementations, there is no formal definition of pre-binding in the SPARQL 1.1 specifications.
				The goal of this section is to illustrate the effect of pre-binding to users and implementers.
				Note however that the following definition is not meant to serve as recommendation for an actual implementation strategy.
			</p>
			<p>
				<span class="term">Pre-binding</span> a variable with a value means that
				the SPARQL processor needs to evaluate all occurrences of variables with that same name
				(including occurrences in inner scopes and nested SELECT queries)
				so that they have the provided value.
				In other words, whenever a SPARQL processor evaluates a pre-bound variable, it must use the given value.
 			</p>
		</section>

		<section id="defaultValueType" class="appendix">
			<h2>Default value types (sh:defaultValueType)</h2>
			<p>
				Some SHACL properties such as <code>sh:property</code>, <code>sh:filterShape</code> and <code>sh:parameter</code> may have untyped blank nodes or IRIs as their values.
				If, for example, a value of <code>sh:property</code> is a blank node that does not have any <code>rdf:type</code>, then the assumption is that the blank node has type <code>sh:PropertyConstraint</code>.
				The SHACL system vocabulary includes some helper triples using the predicate <code>sh:defaultValueType</code> to specify the default <code>rdf:type</code> for certain properties.
				For example, the default value type of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
				SHACL includes a resource <code>sh:DefaultValueTypeRule</code> that encapsulates a SPARQL query via <code>sh:sparql</code> that can be used for that purpose:
			</p>
			<pre class="algorithm">
CONSTRUCT {
	?node a ?defaultValueType .
}
WHERE {
	?predicate sh:defaultValueType ?defaultValueType .
	?anySubject ?predicate ?node .
	FILTER (NOT EXISTS { ?node a ?anyType }) .
}</pre>
		</section>
		
		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this specification, including members of the RDF Data Shapes Working Group.
				We especially thank the following:
			</p>
			<p>
				Arnaud Le Hors (chair),
				Jim Amsden,
				Iovka Boneva,
				Karen Coyle,
				Richard Cyganiak,
				Michel Dumontier,
				Holger Knublauch,
				Dimitris Kontokostas,
				Jose Labra,
				Peter Patel-Schneider,
				Eric Prud'hommeaux,
				Arthur Ryman (who also served as a co-editor until Feb 2016),
				Harold Solbrig,
				Simon Steyskal,
				Ted Thibodeau
			</p>
		</section>
		
	</body>
</html>
