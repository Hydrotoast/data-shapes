<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset='utf-8'>
		<script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
		<script class='remove'>
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				specStatus: "ED",
				shortName:  "shacl", 
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/"
					},
					{
						name:       "Eric Prud'hommeaux",
						url:        "http://www.w3.org/People/Eric/",
						company:    "W3C/MIT",
						companyURL: "http://www.w3.org/"
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
				wgPublicList: "public-data-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
			};
		</script>
		<style>

			pre {
				tab-size: 4;
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
		
			.term {
				font-style: italic;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}
		
			.todo {
				color: red;
			}
			
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				SHACL (Shapes Constraint Language) is an RDF vocabulary for describing RDF graph structures.
				Some of these graph structures are captured as "shapes", which are expected to correspond to nodes in RDF graphs.
				Shapes identify predicates and their associated cardinalities, datatypes and other constraints.
				Additional constraints can either be stated globally or be associated with shapes using SPARQL or other languages which complement SHACL.
				SHACL shapes can be used to communicate data structures associated with some process or interface, generate or validate data, or drive user interfaces.
			</p>
			<p>
				This document defines the SHACL RDF vocabulary together with its underlying semantics.
				The accompanying <a href="../data-shapes-primer/no-class-templates.html">primer</a> provides an informal overview of SHACL, describing by example the behavior of components of the SHACL language.
			</p>	
		</section>

		<section id="sotd">
		</section>
	
		<section id="introduction">
			<h2>Introduction</h2>
			<p class="todo">
				TODO: We currently have two versions of the introduction - requires consolidation
			</p>

			<section>
				<h3>Introduction (Alternative A)</h3>
				<p>
					SHACL (Shapes Constraint Language) provides structural constraints for <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
					SHACL constraints are grouped into conjunctions called "shapes", which may also be referenced by constraints in other shapes.
					These constraints restrict the predicates of <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a> connecting nodes in the graph.
					SHACL can restrict the number of these triples and the permitted object datatype or object terms, as well as require that the subject or object match some shape
					as well as many other conditions.
				</p>
				
				<p>
					SHACL definitions are represented in RDF and can be serialized in multiple RDF formats.
					The example snippets in this document use Turtle [[turtle]] and JSON-LD [[json-ld]] notation.
					The reader should be familiar with basic RDF concepts [[rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[sparql11-overview]].
				</p>
	
				<section>
					<h3>What are Shapes and Constraints (normative)</h3>
					<p>
						A <code>shape</code> describes the triples coming into and out of the <span class="term">focus node</span> in an RDF graph.
						A shape has <code>constraints</code> attached to it which describe the <span class="term">focus node</span>'s triples.
						Some of these <code>constraints</code> can be about a specific property only, these are called <code>property constraints</code>.
					</p>
					<p>
						A <code>property constraint</code> has a <code>predicate</code> which identifies the triple's predicate and may have a <code>minimum cardinality</code> and <code>maximum cardinality</code>, to indicate how many triples with that predicate are expected.
						The following attributes are used to constrain the object of each of triples with that predicate:
					</p>
					<ul>
						<li><code>node type</code>: identifies the RDF node type (IRI, RDF literal, or Blank Node).</li>
						<li><code>value type</code>: identifies the datatype of an RDF literal.</li>
						<li><code>allowed value</code>: enumerates specific expected values.</li>
						<li><code>value shape</code>: asserts that the object is described by another shape.</li>
					</ul>
				</section>
				
				<section>
					<h3>What can you do with Shapes (informative)</h3>
					<p>
						SHACL shapes act as a selection criteria for RDF graphs.
						One use of shapes is to define requirements form input data or an application or suite of applications.
						It can also be used to declare the structre of data in some graph or at some SPARQL endpoint.
						Another use is to drive form generation which prompts users to enter data to construct graphs.
						The semantics for shapes are described here in terms of "matching" some data against a shape with the expectation that this functionality is inherent to these uses.
					</p>
				</section>
			</section>
			
			<section>
				<h3>Introduction (Alternative B)</h3>
				<p>
					SHACL (Shapes Constraint Language) is an RDF vocabulary to describe structural constraints on <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
					The SHACL vocabulary includes high-level concepts to represent restrictions on predicates used in <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a>.
					These restrictions can be grouped into conjunctions called <span class="term">shapes</span>, which may also be referenced by constraints in other shapes.
					SHACL can restrict the number of these triples and the permitted object datatype or object terms, as well as require that the subject or object match some shape as well as other conditions.
					SHACL also includes facilities to define and reuse more complex restrictions, expressed in SPARQL or other languages.
				</p>
				<p>
					The basic building blocks of SHACL are <span class="term">constraints</span>.
					Each <span class="term">constraint</span> defines an atomic condition that can be checked against a graph.
					The output of constraint checking is a set of <span class="term">constraint violations</span>.
					The checking of each <span class="term">constraint</span> is implemented with one or more <span class="term">execution languages</span>.
					SPARQL is a built-in <span class="term">execution language</span> in SHACL, but other languages may be supported in the future or by third parties.
					Each constraint needs to provide at least one <span class="term">executable body</span> in an <span class="term">execution language</span>.
					Constraints may either directly define such an <span class="term">executable body</span> or point at a <span class="term">template</span>.
					Constraints that directly include an <span class="term">executable body</span> (e.g. via <code>sp:sparql</code>) are called <span class="term">native constraints</span>.
					A <span class="term">template</span> serves as a parameterizable macro that wraps an <span class="term">executable body</span>.
					Constraints that rely on a <span class="term">template</span> are called <span class="term">template constraints</span>.
					SHACL includes a small library of such <span class="term">templates</span> for common constraint patterns, but third parties can add their own template libraries.
					Templates can be grouped into <span class="term">profiles</span>.
					Some SHACL engines may decide to only support certain <span class="term">profiles</span> and implement them differently than the provided (SPARQL) bodies.
				</p>
				<p>
					Constraints are either <span class="term">global</span> or <span class="term">local</span>.
					<span class="term">Global constraints</span> are executed when constraint checking is invoked on the whole graph, and may verify arbitrary conditions.
					<span class="term">Local constraints</span> are evaluated against a given <span class="term">focus node</span> (represented by the variable <code>?this</code> in SPARQL).
					The <span class="term">focus node</span> serves as starting point of property paths and other graph traversal algorithms.
					A <span class="term">shape</span> describes a group of <span class="term">local constraints</span> with the same <span class="term">focus node</span>.
					Shapes may be arranged in a <span class="term">specialization</span> hierarchy, allowing some shapes to further narrow down the constraints from other shapes.
					Current proposals for such specialization mechanisms include <code>sh:extends</code> and <code>rdfs:subClassOf</code> triples.
					The latter implies that the nodes of (RDFS/OWL) classes may also be interpreted as shapes.
				</p>
				<p>
					One of the <span class="term">operations</span> that SHACL engines support verifies that a given RDF node matches a given shape.
					This operation can be called based on any control logic, i.e. applications can pick their own mapping between RDF nodes and their shapes.
					SHACL also provides mapping mechanisms based on the RDF triples in the graph being checked.
					Current proposals for these mechanisms include selection based on <code>sh:nodeShape</code> and <code>rdf:type</code> triples.
					Based on such in-graph mappings, SHACL supports constraint checking over a complete graph.
				</p>
				<p>
					Constraints and shapes may be grouped into <span class="term">contexts</span>.
					The constraint checking operations may be parameterized to include or exclude certain contexts.
				</p>
				<p>
					SHACL definitions are represented in RDF and can be serialized in multiple RDF formats.
					The example snippets in this document use Turtle [[turtle]] and <span class="todo">(not written yet:)</span> JSON-LD [[json-ld]] notation.
					The reader should be familiar with basic RDF concepts [[rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[sparql11-overview]].
				</p>
			</section>
			
			<section id="namespaces">
				<h3>Namespaces</h3>
				<p>
					The SHACL system vocabulary is available as a <a href="shacl.shacl.ttl">SHACL Turtle File</a>.
					<span class="todo">Currently contains slight differences from this spec.</span> 
				</p>
				
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
				</table>
			</section>

		</section>

		<section>
        <h2>Matching a Shape (normative)</h2>
			<div class="issue">
    			There is no agreement in the WG on how the semantics of SHACL should be defined.
    			Currently discussed options include:
    			<ol>
    				<li>
    					Based on <a href="http://labra.github.io/Haws/ldom/index">a ShEx-like Grammar</a>.
    					This section is representing that option only.
    				</li>
    				<li>
    					Based on SPARQL (plus an extension mechanism for other languages like JavaScript).
    					The other sections (3 onwards) are based on this option, and are self-contained without this section 2.
    				</li>
    			</ol>
			</div>

        <section>
			<h2>Typings</h2>
			
The semantics of SHACL consits of assigning typings to nodes in an RDF graph.
A typing is a map from RDF nodes (iri's or bNodes) to sets of labels in a Schema.
We define the following operations on shape typings:

<table>
<tbody><tr>
<td>{}</td><td>empty shape typing</td>
</tr>
<tr>
<td><i>iri -&gt; label :: typing</i></td>
<td>the result of assigning <i>iri</i> to <i>label</i> in <i>typing</i></td>
</tr>
<tr>
<td><i>t1</i> ++ <i>t2</i></td>
<td>combination of typings <i>t1</i> and <i>t2</i></td>
</tr>
<tr>
<td><i>contains(t,<code>focus node</code>,label)</i></td>
<td>returns true if the typing <i>t</i> asserts that <code>focus node</code> has shape <i>label</i></td>
</tr>

</tbody></table>
</section>

<section id="Context">
<h2>Context</h2>
<p>The shape schema validator acts in a context.
A context is a tuple <i>(s, g, t)</i> where
 <i>s</i> is a Schema, 
 <i>g</i> is an RDF Graph and
 <i>t</i> is a Typing. 
</p> 
</section>


    	<section>
<h3>Match focus node</h3>

<i>ctx |- matchNode(<code>focus node</code>, label)</i> checks if a <code>focus node</code> conforms
 with the shape associated with <i>label</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.

<table class="rule">
<tbody><tr>
<td rowspan="2">matchNode</td>
<td class="up">
 ctx.schema(label) = shape &nbsp;&nbsp;&nbsp; 
 ctx.graph.triplesAround(<code>focus node</code>) = ts &nbsp;&nbsp;&nbsp;
 ctx { <code>focus node</code> -&gt; label } |- matchShape(ts, shape) = (t,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchNode(<code>focus node</code>,label) = (t,cs,rs)</td></tr>
</tbody></table>
</section>


<section id="MatchShape">
<h3>Match Shape</h3>
<p>
<i>ctx |- matchShape(triples, shape)</i> checks if a set of triples <i>triples</i> conforms
 with <i>shape</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.
</p>

<p>The empty shape matches any set of triples without any constraint.</p>
<table class="rule">
<tbody><tr>
<td rowspan="2">Empty</td>
<td class="up">
 &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,Empty) = (ctx.typing,{},ts)</td></tr>
</tbody></table>

<p>There are five possibilities for cardinality: </p>

<ul>
<li>
<p>When the cardinality is {0,unbounded} 
 it matches any set of triples:</p>
<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_unbounded1</td>
<td class="up">
  &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,basicArc {0,unbounded}) = (ctx.typing,{},ts)</td></tr>
</tbody></table>

</li><li>
<p>When the cardinality is <i>{m,unbounded}</i> for <i>m &gt; 0</i> it matches if
 there is one triple that matches and if the rest of triples matches 
 with a cardinality of <i>{m - 1, unbounded}</i></p>
<p>Notice that it only matches if there are at least one triple</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_unbounded2</td>
<td class="up">
m &gt; 0 &nbsp;&nbsp;&nbsp;
ctx |- matchArc(t,basicArc) = t1 &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts,basicArc {m - 1,unbounded}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t:ts, basicArc {m,unbounded}) = (t1 ++ t2,t:cs,rs)</td></tr>
</tbody></table>

</li><li>

<p>When the cardinality is <i>{0, n}</i> for <i>n &gt;= 0</i> it can match if there 
is not triple that matches or if there 
is one triple that matches and the rest of triples matches with a cardinality of <i>{0, n-1}</i></p>

<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_bounded1</td>
<td class="up">
n &gt;= 0 &nbsp;&nbsp;&nbsp;
ctx |- not (matchArcAny(ts,p,v)) 
</td>
</tr>
<tr><td>ctx |- matchShape(ts, BasicArc {0, n}) = (ctx.typing,{},ts)</td></tr>
</tbody></table>

</li><li> 
<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_bounded2</td>
<td class="up">
n &gt;= 0 &nbsp;&nbsp;&nbsp;
matchArc(t,basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts,basicArc {0, n - 1}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t::ts, basicArc {0, n}) = (t1 ++ t2, t::cs, rs)</td></tr>
</tbody></table>

</li><li>
<p>If the cardinality if <i>{m, n}</i> it matches if there is one triple that matches 
 and if the rest of triples match with the cardinality <i>{m - 1, n - 1}</i></p>
 
<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_bounded3</td>
<td class="up">
m &gt; 0, n &gt;= m &nbsp;&nbsp;&nbsp;
matchBasicArc(t, basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts, basicArc {m-1, n-1} ) = (t2, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t::ts, basicArc {m, n}) = (t1 ++ t2, t::cs, rs)</td></tr>
</tbody></table>

</li></ul>

<p>If the shape is a conjunction it matches if it matches the first element and 
   then, the second with the remaining triples</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">And</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t1, cs1, rs1) &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts, e2) = (t2, cs2, rs2)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, And(e1, e2) = (t1 ++ t2, cs1 union cs2, rs1 intersection rs2)</td></tr>
</tbody></table>

<p>If the shape is a disjunction it matches if either the first element matches or the second, matching is the union</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">Or_1</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</tbody></table>

<table class="rule">
<tbody><tr>
<td rowspan="2">Or_2</td>
<td class="up">
ctx |- matchShape(ts, e2) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</tbody></table>

<p class="issue">exclusive OR to enable <a href="http://www.w3.org/2015/02/19-shapes-minutes">graph coverage</a> or <a href="https://www.w3.org/2014/data-shapes/wiki/Requirements#Expressivity:_Closed_Shapes">closed shapes</a></p>

<p>If the shape is a negation of a shape it matches if the shape does not match</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">Not</td>
<td class="up">
ctx |- not(matchShape(ts,e))
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Not(e)) = (t, ts, {})</td></tr>
</tbody></table>

<p>A set of triples matches a closed shape if the set of triples matches the shape
 and there are no remaining triples</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">Close</td>
<td class="up">
ctx |- matchShape(ts,e) = (t,cs,{})
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Closed(e)) = (t, cs, {})</td></tr>
</tbody></table>

</section>

<section id="MatchBasicArc">
<h3>Match BasicArc</h3>
<p>ctx|-matchBasicArc(triple,basicArc</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">ObjectArc</td>
<td class="up">
ctx |- matchValue(o,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, Arc p v) = t&lt;/s,p,o&gt;</td></tr>
</tbody></table>

<table class="rule">
<tbody><tr>
<td rowspan="2">SubjectArc</td>
<td class="up">
ctx |- matchValue(s,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, InvArc p v) = t&lt;/s,p,o&gt;</td></tr>
</tbody></table>

</section>

<section id="MatchValue">
<h3>Match value</h3>

<table class="rule">
<tbody><tr>
<td rowspan="2">valueSet</td>
<td class="up">
x in set
</td>
</tr>
<tr><td>ctx |- matchValueSet(x, ValueSet(set)) = ctx.typing</td></tr>
</tbody></table>

<table class="rule">
<tbody><tr>
<td rowspan="2">valueObjectType</td>
<td class="up">
x hastype t
</td>
</tr>
<tr><td>ctx |- matchValueType(x, ValueType(t)) = ctx.typing</td></tr>
</tbody></table>

<p>ValueRef handles references to shapes. There are two cases, 
  the first initial case, when the context already contains the declaration
  that <i>x</i> has shape <i>label</i> just returns the current typing.</p>
  
<table class="rule">
<tbody><tr>
<td rowspan="2">valueRef_1</td>
<td class="up">
 contains(ctx.typing, x, label)
</td>
</tr>
<tr><td>ctx |- matchValueRef(x, ValueRef(label)) = ctx.typing</td></tr>
</tbody></table>

<p>The second case, when the context does not contain the declaration that <i>x</i> has the shape <i>label</i>
 is solved by trying to match <i>x</i> with shape <i>label</i> in the graph.</p>
 
<table class="rule">
<tbody><tr>
<td rowspan="2">valueRef_2</td>
<td class="up">
not(contains(ctx, x, label)) &nbsp; &nbsp; &nbsp;
ctx |- matchNode(x,v) = (t,_,_)
</td>
</tr>
<tr><td>ctx |- matchValueRef(x, ValueRef(label)) = t</td></tr>
</tbody></table>

</section>

<section id="MatchArcAny">
<h3>MatchArcAny</h3>
<p><i>matchArcAny</i> takes a set of triples and a basic arc and checks if there is some triple
 in that set that matches with the basic arc.
 The result is a boolean</p>
 
<p>It has two possibilities. Either it matches the first triple in the set (<i>matchArc_1</i>)
 or it matches any of the rest of triples in the set (<i>matchArc_2</i>)</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">matchArcAny_1</td>
<td class="up">
ctx |- matchBasicArc(t,basicArc) = (_,_,_)
</td>
</tr>
<tr><td>ctx |- matchArcAny(t:ts, basicArc)</td></tr>
</tbody></table>
 
<table class="rule">
<tbody><tr>
<td rowspan="2">matchArcAny_2</td>
<td class="up">
ctx |- matchArcAny(ts,basicArc)
</td>
</tr>
<tr><td>ctx |- matchArcAny(t:ts, basicArc)</td>
</tr>
</tbody>
</table>

			</section>
		</section>

		<section id="violations">
			<h2>Constraint Violations Vocabulary</h2>
			<p>
				The output of a SHACL constraint checking operation is a set of <span class="term">constraint violations</span>.
				SHACL includes an RDF vocabulary to represent such constraint violations together with
				structural information that may provide guidance on how to fix the violation, as well as
				human-readable messages.
			</p>
			<p>
				The following code snippet represents a valid constraint violation that may have been produced
				by a constraint checking engine:
			</p>
			<pre class="example" title="A constructed constraint violation">
ex:ExampleConstraintViolation
	a sh:Error ;
	sh:root ex:MyCurrentNode ;
	sh:path ex:someProperty ;
	sh:value ex:someInvalidValue ;
	sh:message "Incorrect value: expected something else here." .</pre>
			<section id="violations-types">
				<h3>Types of Constraints Violations</h3>
				<p>
					A constraint violation is represented by a IRI or blank node that has exactly one
					asserted <code>rdf:type</code>.
					The <code>rdf:type</code> arc of a constraint violation must point to one of the subclasses
					of the ("abstract") base class <code>sh:ConstraintViolation</code>.
					The SHACL system vocabulary includes the following constraint violation types: 
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Constraint&nbsp;Violation&nbsp;Class</th>
						<th>Superclass</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:Warning</code></td>
						<td><code>sh:ConstraintViolation</code></td>
						<td>A non-critical constraint violation indicating a warning.</td>
					</tr>
					<tr>
						<td><code>sh:Error</code></td>
						<td><code>sh:ConstraintViolation</code></td>
						<td>A constraint violation indicating an error.</td>
					</tr>
					<tr>
						<td><code>sh:FatalError</code></td>
						<td><code>sh:Error</code></td>
						<td>
							An error that cannot be recovered and further evaluation may terminate immediately.
							Engines may decide to perform fatal checks first.
						</td>
					</tr>
				</table>
				<p class="todo">
					<code>sh:Info</code> has also been suggested, but this would work best if there was a deterministic mechanism to identify
					constraints that need to be checked, so that Info constraints can be bypassed.
					Related to this, Dimitris also suggested we introduce <code>sh:ValidationResult</code> as a superclass of <code>sh:ConstraintViolation</code>.
				</p>
				<p>
					SHACL extensions may define additional violation types, as long as they are rooted in
					<code>sh:ConstraintViolation</code>.
					The <code>rdfs:subClassOf</code> relationship between these types indicates specialization,
					e.g. <code>sh:FatalError</code> is a subclass of <code>sh:Error</code> meaning that every
					fatal error should also be regarded as an error.
				</p>
				<p class="todo">
					TODO: There is an ongoing <a href="https://lists.w3.org/Archives/Public/public-data-shapes-wg/2015Mar/0011.html">proposal</a> to use these violation levels at engine control time.
				</p>
			</section>
			<section id="violations-structure">
				<h3>Structural Violation Metadata</h3>
				<p>
					SHACL constraint violations may include machine-readable metadata that points at
					the cause of the violation.
				</p>
				<section id="violations-structure-root">
					<h4>sh:root</h4>
					<p>
						Constraint violations may have a single value for the property <code>sh:root</code> to point to an
						IRI or blank node that has caused the violation.
					</p>
				</section>
				<section id="violations-structure-path">
					<h4>sh:path</h4>
					<p>
						Constraint violations may have one or more values for the property <code>sh:path</code>
						that describes a <em>path expression</em> that can be walked starting at the <code>sh:root</code>.
						If the value of this property is a IRI, then the path produces all triples that have the root node as
						subject and the value as its predicate.
						If the value of <code>sh:path</code> is a blank node, then it must have properties that
						match either one of the following options: 
					</p>
					<ul>
						<li>
							<code>sh:inverse</code> describes an inverse path consisting of all paths that start
							at the current root node and walk the given predicate backwards, i.e. from object to subject.
							The values of <code>sh:inverse</code> must be the IRIs of properties.
							Blank nodes with <code>sh:inverse</code> may have the optional type <code>sh:InversePath</code>.
						</li>
						<li>
							<code>sh:path1</code> and <code>sh:path2</code> describe a sequence path consisting of
							two other paths.  The values of these properties must be property IRIs or blank nodes
							of the same recursive path structure.  The path produces the concatenation of the two sub-paths.
							Blank nodes with <code>sh:path1</code> and <code>sh:path2</code> may have the optional type <code>sh:SequencePath</code>.
						</li>
					</ul>
					<p>
						The following example describes a path equivalent to the SPARQL 1.1 Property Path [[sparql11-query]]
						<code>ex:firstProperty/((^ex:inverseProperty)/ex:lastProperty)</code>
					</p>
					<pre class="example" title="Constraint violation with path expression">
ex:ExampleConstraintViolationWithPath
	a sh:Error ;
	sh:root ex:MyCurrentNode ;
	sh:path [
		sh:path1 ex:firstProperty ;
		sh:path2 [
			ex:path1 [ sh:inverse ex:inverseProperty ] ;
			ex:path2 ex:lastProperty
		]
	] .</pre>
					<p class="todo">
						Open discussion: Dimitris suggested that we may want to allow path expressions as xsd:strings too,
						and rdf:Lists for sequence paths.
					</p>
				</section>
				<section id="violations-structure-value">
					<h4>sh:value</h4>
					<p>
						Constraint violations may have one or more values of the property <code>sh:value</code> to
						point at specific nodes that caused the violation.
						These nodes SHOULD be accessible via at least one <code>sh:path</code> starting at the
						specific <code>sh:root</code> node.
					</p>
				</section>
				<section id="violations-structure-source">
					<h4>sh:source</h4>
					<p>
						Constraint violations may point at one <code>sh:Constraint</code> that has caused
						the violation, specified via the property <code>sh:source</code>.
						SHACL constraint checking engines SHOULD automatically insert the <code>sh:source</code>
						based on the currently evaluated constraint, unless the constraint violation already has
						such a value.
					</p>
				</section>
				<section id="violations-structure-detail">
					<h4>sh:detail</h4>
					<p>
						The property <code>sh:detail</code> may link a (parent) constraint violation with one or more other
						(child) constraint violations that provide further details about the cause of the (parent) violation.
						Depending on the capabilities of the constraint checking engine, this may include failures of
						nested constraints that have been evaluated via <code>sh:valueShape</code>.
					</p>
				</section>
			</section>
			<section id="violations-message">
				<h3>Human-readable Violation Messages (sh:message)</h3>
				<p>
					Constraint violations may have values for the property <code>sh:message</code> to communicate
					additional textual details to humans.
					While <code>sh:message</code> may have multiple values, there SHOULD not be two values
					with the same language tag.
				</p>
			</section>
		</section>

		<section id="constraints">
			<h2>Constraints</h2>
			<p>
				The (abstract) root class for representing SHACL constraints is <code>sh:Constraint</code>.
				There are two kinds of constraints built into SHACL, represented by the following subclasses of
				<code>sh:Constraint</code>:
			</p>
			<ul>
				<li>
					<code>sh:NativeConstraint</code> represents constraints that are directly backed by a
					<em>native executable</em>, e.g. a SPARQL query, that produces constraint violations.
				</li>
				<li>
					<code>sh:TemplateConstraint</code> represents constraints that are backed by a native executable
					that is encapsulated into a <em>template</em> (aka <em>macro</em>).
				</li>
			</ul>
			<p>
				There is another dimension to constraint definitions that is orthogonal to the distinction between
				native and template constraints:
			</p>
			<ul>
				<li>
					<code>sh:GlobalConstraint</code> represents constraints that are evaluated on the whole graph.
				</li>
				<li>
					<code>sh:LocalConstraint</code> represents constraints that evaluated on a given <span class="term">focus node</span>.
					Local constraints are usually grouped into shapes but may also be declared as stand-alone
					entities with their own IRIs so that they can be shared between multiple shapes. 
				</li>
			</ul>
			<p>
				Based on those two dimensions, SHACL can represent four kinds of constraints overall:
			</p>
			<ul>
				<li><a href="#constraints-global-native">Global native constraints</a></li>
				<li><a href="#constraints-global-template">Global template constraints</a></li>
				<li><a href="#constraints-local-native">Local native constraints</a></li>
				<li><a href="#constraints-local-template">Local template constraints</a></li>
			</ul>
			<p class="todo">
				TODO: We need to somewhere explain the meaning of attaching sh:message, sh:path etc to the constraints
				(they serve as default values for the constructed constraint violations)
			</p>
			<p>
				Note that the examples in the following sub-sections all use SPARQL (via <code>sh:sparql</code>) as	the executable language.
				However, the use of SPARQL is meant for illustration purposes only and is not the only possibility.
			</p>
			<section id="constraints-global-native">
				<h3>Global Native Constraints</h3>
				<p>
					The following example illustrates the syntax for a global native constraint.
					Note that the constraint does not need to have the explicit type <code>sh:NativeConstraint</code>
					because it has a <code>sh:sparql</code> query that identifies it as a native constraint.
				</p>
				<pre class="example" title="Global native constraint">
ex:ExampleGlobalSPARQLConstraint
	a sh:GlobalConstraint ;
	sh:message "There needs to be at least one instance of ex:SomeClass." ;
	sh:sparql """
		ASK {
			FILTER NOT EXISTS { ?any rdf:type ex:SomeClass } .
		}
		""" .</pre>
			</section>
			<section id="constraints-global-template">
				<h3>Global Template Constraints</h3>
				<p>
					The following example illustrates the syntax for a global template constraint and the template
					that it instantiates.
					Note that the constraint does not need to have the explicit type <code>sh:GlobalConstraint</code>
					because it is an instance of the template <code>ex:ExampleGlobalConstraintTemplate</code> which
					is declared as a subclass of <code>sh:GlobalConstraint</code>.
				</p>
				<pre class="example" title="Global template constraint">
ex:ExampleGlobalTemplateConstraint
	a ex:ExampleGlobalConstraintTemplate ;
	ex:exampleArgument ex:SomeClass .
	
ex:ExampleGlobalConstraintTemplate
	a sh:ConstraintTemplate ;
	rdfs:subClassOf sh:GlobalConstraint ;
	sh:argument [
		sh:predicate ex:exampleArgument ;
		sh:valueType rdfs:Class ;
		rdfs:label "The class that needs to have at least one instance." ;
	] ;
	sh:message "There needs to be at least one instance of the given class" ;
	sh:sparql """
		ASK {
			FILTER NOT EXISTS { ?any rdf:type ?exampleArgument }
		}
		""" .</pre>
			</section>
			<section id="constraints-local-native">
				<h3>Local Native Constraints</h3>
				<p>
					The following example illustrates the syntax for a local native constraint.
					Note that the constraint does not need to have the explicit type <code>sh:NativeConstraint</code>
					because it has a <code>sh:sparql</code> query that identifies is as a native constraint.
					In contrast to global constraints, note that the variable <code>?this</code> is used to
					refer to the <span class="term">focus node</span>.
				</p>
				<pre class="example" title="Local native constraint">
ex:ExampleLocalSPARQLConstraint
	sh:message "At least one value of ex:someProperty expected." ;
	sh:path ex:someProperty ;
	sh:sparql """
		SELECT (?this AS ?root)
		WHERE {
			FILTER NOT EXISTS { ?this ex:someProperty ?anyValue } .
		}
		""" .</pre>
			</section>
			<section id="constraints-local-template">
				<h3>Local Template Constraints</h3>
				<p>
					The following example illustrates the syntax for a local template constraint and the
					template that it instantiates.
				</p>
				<pre class="example" title="Local template constraint">
ex:ExampleLocalTemplateConstraint
	a ex:ExampleLocalConstraintTemplate ;
	ex:exampleArgument ex:someProperty .

ex:ExampleLocalConstraintTemplate
	sh:message "At least one value of the given property expected." ;
	rdfs:subClassOf sh:LocalConstraint ;
	sh:argument [
		sh:predicate ex:exampleArgument ;
		sh:valueType rdf:Property ;
		rdfs:label "The property for which the focus node needs to have at least one instance." ;
	] ;
	sh:sparql """
		SELECT (?this AS ?root) (?exampleArgument AS ?path)
		WHERE {
			FILTER NOT EXISTS { ?this ?exampleArgument ?anyValue } .
		}
		""" .</pre>
			</section>
		</section>

		<section id="shapes">
			<h2>General Structure of Shapes</h2>
			<div class="issue">
				There is no agreement in the WG on the relationship of sh:Shape with RDFS classes.
				Proposals include:
				<ul>
					<li>Keep them completely separate, users only instantiate sh:Shape and use sh:extends</li>
					<li>Have rdfs:Class rdfs:subClassOf sh:Shape, use either sh:extends or rdfs:subClassOf</li>
					<li>Have sh:Shape rdfs:subClassOf rdfs:Class, use rdfs:subClassOf</li>
					<li>Allow both approaches in parallel: either rdfs:Class/subClassOf or sh:Shape/extends</li>
					<li>Allow both and have sh:classShape to point from a class to its shape(s)</li>
				</ul>
				In the absence of such an agreement, this document uses sh:Shape in all examples.
				Note that depending on the resolution, all examples could also use rdfs:Class instead of sh:Shape.
			</div>
			<p>
				Shapes are instances of the class <code>sh:Shape</code>
				<span class="todo">(or, depending on the outcome of the ISSUE above, <code>rdfs:Class</code>)</span>.
				The <code>rdf:type</code> triple of a shape can be omitted for shapes represented by blank nodes when the type can be deduced from
				the context, e.g. values of <code>sh:valueShape</code> do not require a type triple.
			</p>
			<section id="shapes-labels">
				<h3>Shape Labels and Comments</h3>
				<p>
					Like many other types of RDF resources, shapes SHOULD have human-readable labels
					via <code>rdfs:label</code>.
					The property <code>rdfs:comment</code> is recommended for documentation and definition purposes.
				</p>
			</section>
			<section id="shapes-private">
				<h3>Private Shapes (sh:private)</h3>
				<p class="todo">
					This feature is not based on an approved requirement.
				</p>
				<p>
					A shapes may have its property <code>sh:private</code> set to <code>true</code> to
					indicate that the shape is not meant to be directly referenced from outside of the
					graph (or namespace) that it has been defined in.
					Editing tools SHOULD actively discourage the use of private shapes outside of those scenarios.
				</p>
			</section>
			<section id="shapes-specialization">
				<h3>Shape Specialization Mechanism (sh:extends/rdfs:subClassOf)</h3>
				<p>
					Shape declarations can specialize other shapes.
					If a (sub) shape is declared to specialize another (super) shape then all constraints
					attached to the super-shape must also apply to the sub-shape.
					In other words, the set of nodes that match a sub-shape is a sub-set of those that
					match a super-shape.
				</p>
				<p class="todo">
					In the currently discussed proposals, the property <code>sh:extends</code> would be used
					for instances of <code>sh:Shape</code> if <code>sh:Shape</code> is not declared to be a
					subclass of <code>rdfs:Class</code>.
					In all other cases, the property <code>rdfs:subClassOf</code> would be used to link
					a sub-shape with its super-shape(s).
				</p>
			</section>
			<section id="shapes-abstract">
				<h3>Abstract Shapes (sh:abstract)</h3>
				<p class="todo">
					This feature is not based on an approved requirement.
				</p>
				<p>
					A shape may have its property <code>sh:abstract</code> set to <code>true</code> to
					indicate that the shape SHOULD only serve as base of further specializations.
					Abstract shapes SHOULD not be "instantiated" directly, i.e. they should not have incoming <code>sh:nodeShape</code> or <code>rdf:type</code> triples.
				</p>
			</section>
			<section id="shapes-final">
				<h3>Final Shapes (sh:final)</h3>
				<p class="todo">
					This feature is not based on an approved requirement.
				</p>
				<p>
					A shape may have its property <code>sh:final</code> set to <code>true</code> to
					indicate that the shape SHOULD not have further specializations.
				</p>
			</section>
		</section>
		
		<section id="shapeconstraints">
			<h2>Constraints on Shapes</h2>
			<p>
				A shape can be regarded as a collection of local constraints on a <span class="term">focus node</span>.
				SHACL defines several properties that can be used to link a shape with its constraints:
			</p>
			<ul>
				<li><a href="#shapeconstraints-constraint"><code>sh:constraint</code></a> is used to link a shape with general constraints</li>
				<li><a href="#shapeconstraints-property"><code>sh:property</code></a> is used to link a shape with property constraints</li>
				<li><a href="#shapeconstraints-inverseProperty"><code>sh:inverseProperty</code></a> is used to link a shape with inverse property constraints</li>
			</ul>
			<p>
				The following sections describe the role of each of these properties in detail.
				The SPARQL Definitions use the variable <code>?this</code> to refer to the <span class="term">focus node</span>.
				SPARQL-based implementations of SHACL may use variations of the provided SPARQL queries, as long as they expose compatible behavior.
			</p>

			<section id="shapeconstraints-constraint">
				<h3>General Constraints (sh:constraint)</h3>
				<p>
					The property <code>sh:constraint</code> provides the most general mechanism to associate a constraint with a shape.
					The values of this property must be <span class="term">local constraints</span>, i.e. they MUST reference a
					<span class="term">focus node</span>.
					Note that the property <code>sh:property</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:PropertyConstraint</code>.
					The property <code>sh:inverseProperty</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:InversePropertyConstraint</code>.
				</p>
				<p>
					The following example illustrates the definition of a <span class="term">local constraint</span> based on a SPARQL query.
				</p>
				<pre class="example">
ex:GeneralConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:message "The value of property2 cannot be smaller than the value of property1." ;
		sh:sparql """
			ASK {
				?this ex:property1 ?value1 .
				?this ex:property2 ?value2 .
				FILTER (?value2 &lt; ?value1) .
			}
			""" ;
	] .</pre>
			</section>

			<section id="shapeconstraints-property">
				<h3>Property Constraints (sh:property)</h3>
				<p>
					The constraint template <code>sh:PropertyConstraint</code> can be used to represent constraints	on triples that have
					the <span class="term">focus node</span> as their subject and a given property (specified via <code>sh:predicate</code>) as their predicate.
					Shapes that rely on <code>sh:PropertyConstraint</code> SHOULD use the property <code>sh:property</code>, so that
					some tools have an easier job to find the declared properties.
					When <code>sh:property</code> is used, and the property constraint is a blank node, then the <code>rdf:type</code> triple
					of the <code>sh:PropertyConstraint</code> is optional.
					Note that <code>sh:property</code> may also have values that are sub-classes of <code>sh:PropertyConstraint</code>,
					but in this case the <code>rdf:type</code> triple is required.
					It is not valid to use <code>sh:property</code> for constraints that are not instance of <code>sh:PropertyConstraint</code>.
				</p>
				<p>
					Note that the same <code>sh:PropertyConstraint</code> can hold multiple <em>facets</em>, such as <code>sh:minCount</code>
					and <code>sh:valueShape</code>.
					Shapes SHOULD group together all constraints that are about the same <code>sh:predicate</code> into the same node. <span class="todo">The previous sentence should be considered AT RISK.</span>
				</p>
				<p> 
					The following examples illustrate two ways of using property constraints.
					The first example uses a blank node:
				</p>
				<pre class="example" title="Property constraint represented by a blank node">
ex:InlinePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:valueType ex:SomeClass ;
		rdfs:label "some property" ;
		rdfs:comment "Description of the role of ex:someProperty (in the context of the constraint)" ;
	] .</pre>
				<p>
					The second example defines a constraint as an IRI node, allowing it to be referenced and shared across multiple shapes:
				</p>
				<pre class="example" title="Property constraint represented by a IRI">
ex:StandAlonePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property ex:StandAloneConstraint .

ex:StandAloneConstraint
	a sh:PropertyConstraint ;
	sh:predicate ex:someProperty ;
	sh:defaultValue ex:SomeInstance ;
	sh:minCount 1 ;
	sh:valueType ex:SomeClass .</pre>
				<p>
					Property constraints may have an <code>rdfs:label</code> to provide a human-readable label for the property	in the context where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					Similarly, property constraints may have an <code>rdfs:comment</code> to provide a description of the property in the given context.
					Both <code>rdfs:label</code> and <code>rdfs:comment</code> may have multiple values, but SHOULD only have one value per language tag.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but may be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:valueType</code> of the same constraint.
				</p>
				<p>
					The following sections provide details on the built-in facet properties that may be used with <code>sh:PropertyConstraint</code>.
					The facet properties are defined by templates that serve as abstract superclasses of <code>sh:PropertyConstraint</code>.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Facet&nbsp;Properties</th>
						<th>Template</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td><a href="#AbstractAllowedValuesPropertyConstraint"><code>sh:allowedValues</code></a></td>
						<td><code>sh:AbstractAllowedValuesPropertyConstraint</code></td>
						<td>Enumeration of allowed values</td>
					</tr>
					<tr>
						<td><a href="#AbstractHasValuePropertyConstraint"><code>sh:hasValue</code></a></td>
						<td><code>sh:AbstractHasValuePropertyConstraint</code></td>
						<td>A specific required value</td>
					</tr>
					<tr>
						<td><a href="#AbstractCountPropertyConstraint"><code>sh:minCount</code>, <code>sh:maxCount</code></a></td>
						<td><code>sh:AbstractCountPropertyConstraint</code></td>
						<td>Minimum and maximum cardinality</td>
					</tr>
					<tr>
						<td><a href="#AbstractNodeTypePropertyConstraint"><code>sh:nodeType</code></a></td>
						<td><code>sh:AbstractNodeTypePropertyConstraint</code></td>
						<td>Node type (IRI, blank node, or literal) of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractValueShapePropertyConstraint"><code>sh:valueShape</code></a></td>
						<td><code>sh:AbstractValueShapePropertyConstraint</code></td>
						<td>Nested shape of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractValueTypePropertyConstraint"><code>sh:valueType</code></a></td>
						<td><code>sh:AbstractValueTypePropertyConstraint</code></td>
						<td>Type and datatype of all values</td>
					</tr>
				</table>
				<p class="todo">
					There appears to be a good chance that SHACL will also include datatype property constraints similar to xsd:minInclusive and xsd:pattern.
				</p>
				<section id="AbstractAllowedValuesPropertyConstraint">
					<h4>sh:allowedValues</h4>
					<p>
						The property <code>sh:allowedValues</code> can be used to specify that all values of the given predicate
						at the <span class="term">focus node</span> must be members of a given set of allowed values.
						The set of allowed values is assumed to be an exhaustive enumeration of all possible values.
					</p>
					<div id="def-allowedValues-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:allowedValues</code> must be instances of <code>sh:Set</code>, with its values of
							<code>sh:member</code> pointing at the nodes in the <code>sh:Set</code>.
							An <code>sh:Error</code> must be reported for every triple that has the <span class="term">focus node</span> as its subject,
							the <code>sh:predicate</code> as its predicate and an object that is not a member of the given set.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
							Each produced <code>sh:Error</code> must have the <span class="term">focus node</span> as its <code>sh:root</code>, the <code>sh:predicate</code>
							as its <code>sh:path</code> and the respective invalid value as its <code>sh:value</code>.
						</div>
					</div>
					<div id="def-allowedValues-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT (?this AS ?root) (?predicate AS ?path) ?value
WHERE {
	?this ?predicate ?value ;
	FILTER NOT EXISTS { ?allowedValues sh:member ?value }
}</pre>
					</div>
					<pre class="example" title="Shape with sh:allowedValues constraint">
ex:AllowedValuesExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:allowedValues ex:AllowedValuesExampleSet ;
	] .

ex:AllowedValuesExampleSet
	a sh:Set ;
	sh:member ex:Value1 ;
	sh:member ex:Value2 ;
	sh:member ex:Value3 .

ex:AllowedValuesExampleValidResource
	ex:property ex:Value2 .</pre>
					<p class="issue">
						It is not yet decided whether the language should also support <code>sh:allowedValue</code>
						that would point directly to the enumerated values instead of having an intermediate sh:Set.
						The downsides of having both is that it adds extra complexity to algorithm for something that feels redundant,
						and that it is not yet clear how the execution of template arguments with multiple values should work.
						If we allowed rdf:List, then the Turtle/JSON-LD syntax may look good yet a sh:Set is more extensible. 
					</p>
				</section>
				<section id="AbstractHasValuePropertyConstraint">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify
						that the <span class="term">focus node</span> has a given RDF node among the values of the given
						predicate.
					</p>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							An <code>sh:Error</code> must be reported if there is no triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and the <code>sh:hasValue</code> as its object.
						</div>
					</div>
					<div id="def-hasValue-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
ASK {
	FILTER NOT EXISTS { ?this ?predicate ?hasValue }
}</pre>
					</div>
					<pre class="example" title="Shape with sh:hasValue constraint">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .

ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
				</section>
				<section id="AbstractCountPropertyConstraint">
					<h4>sh:minCount, sh:maxCount</h4>
					<p>
						The properties <code>sh:minCount</code> and <code>sh:maxCount</code>
						restrict the number of values of the given property at the <span class="term">focus node</span>.
					</p>
					<div id="def-count-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							Both <code>sh:minCount</code> and <code>sh:maxCount</code> are optional.
							The default value of <code>sh:minCount</code> is 0.
							Let <code>?count</code> be the number of triples that have the <span class="term">focus node</span> as
							subject and the <code>sh:predicate</code> as the predicate.
							An <code>sh:Error</code> must be reported in either of the following cases:
							If <code>?count</code> is less than the value of <code>sh:minCount</code>.
							If <code>sh:maxCount</code> is present and <code>?count</code> is greater than the value of <code>sh:maxCount</code>.
							The resulting <code>sh:Error</code> must have the <span class="term">focus node</span> as <code>sh:root</code>
							and the predicate as its <code>sh:path</code>. 
						</div>
					</div>
					<div id="def-count-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT (?this AS ?root) (?predicate AS ?path)
WHERE {
	BIND (sh:valueCount(?this, ?predicate) AS ?count) .
	FILTER ((?count &lt; ?minCount) || (bound(?maxCount) &amp;&amp; (?count &gt; ?maxCount))) .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:minCount and sh:maxCount constraints">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
				<section id="AbstractNodeTypePropertyConstraint">
					<h4>sh:nodeType</h4>
					<div>
						The values of <code>sh:nodeType</code> must be instances of the class <code>sh:NodeType</code>.
						The SHACL system vocabulary defines that <code>sh:NodeType</code> has exactly the 7 instances
						listed in the following table.
						The node types can have a property <code>sh:subNodeType</code> that links a more general
						node type with its specializations.
						The conditions to verify whether a given <code>?node</code> fulfills the constraints
						are summarized in the third column of the following table.
					</div>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>NodeType</th>
							<th>Super-NodeTypes</th>
							<th>SPARQL Expression</th>
						</tr>
						<tr>
							<td><code>sh:Node</code></td>
							<td></td>
							<td><code>true</code></td>
						</tr>
						<tr>
							<td><code>sh:BlankNodeOrIRI</code></td>
							<td><code>sh:Node</code></td>
							<td><code>isBlank(?node) || isIRI(?node)</code></td>
						</tr>
						<tr>
							<td><code>sh:BlankNodeOrLiteral</code></td>
							<td><code>sh:Node</code></td>
							<td><code>isBlank(?node) || isLiteral(?node)</code></td>
						</tr>
						<tr>
							<td><code>sh:LiteralOrIRI</code></td>
							<td><code>sh:Node</code></td>
							<td><code>isLiteral(?node) || isIRI(?node)</code></td>
						</tr>
						<tr>
							<td><code>sh:BlankNode</code></td>
							<td><code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code></td>
							<td><code>isBlank(?node)</code></td>
						</tr>
						<tr>
							<td><code>sh:IRI</code></td>
							<td><code>sh:BlankNodeOrIRI</code>, <code>sh:LiteralOrIRI</code></td>
							<td><code>isIRI(?node)</code></td>
						</tr>
						<tr>
							<td><code>sh:Literal</code></td>
							<td><code>sh:LiteralOrIRI</code>, <code>sh:BlankNodeOrLiteral</code></td>
							<td><code>isLiteral(?node)</code></td>
						</tr>
					</table>
					<p class="todo">
						Dimitris suggests we only support sh:IRI, sh:Literal and sh:BlankNode and use some generic OR mechanism to combine them.
					</p>
					<div id="def-nodeType-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							An <code>sh:Error</code> must be reported for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the node type tests
							defined in the table above.
							Each produced <code>sh:Error</code> must have the <code>sh:predicate</code>
							as its <code>sh:path</code> and the respective violating value as its <code>sh:value</code>.
						</div>
					</div>
					<div id="def-nodeType-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT (?this AS ?root) (?predicate AS ?path) ?value
WHERE {
	?this ?predicate ?value ;
	FILTER (!sh:hasNodeType(?value, ?nodeType)) .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:nodeType constraint">
ex:NodeTypeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:nodeType ex:IRI ;
	] .

ex:NodeTypeShapeExampleValidResource
	ex:someProperty ex:SomeIRI .

ex:NodeTypeShapeExampleInvalidResource
	ex:someProperty ex:SomeIRI ;
	ex:someProperty "A literal" .</pre>
				</section>
				<section id="AbstractValueShapePropertyConstraint">
					<h4>sh:valueShape</h4>
					<p>
						The property <code>sh:valueShape</code> can be used verify that all values of the given property must match a given shape.
						The value type of <code>sh:valueShape</code> is <code>sh:Shape</code><span class="todo"> (and/or <code>rdfs:Class</code>)</span>.
					</p>
					<div id="def-valueShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							An <code>sh:Error</code> must be reported for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the shape specified by <code>sh:valueShape</code>.
							Each produced <code>sh:Error</code> must have the <code>sh:predicate</code>
							as its <code>sh:path</code> and the respective violating value as its <code>sh:value</code>.
						</div>
					</div>
					<div id="def-valueShape-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT (?this AS ?root) (?predicate AS ?path) ?value 
WHERE {
	?this ?predicate ?value .
	FILTER (!sh:hasShape(?value, ?valueShape)) .
}</pre>
					</div>
					<p class="todo">
						Some WG members have voiced concerns that the definition above requires a built-in sh:hasShape that may
						be expensive to implement for SPARQL vendors.
						An alternative design would be to hard-code the <code>sh:valueShape</code> property into the engine,
						and do the recursion in the outer layer, outside of SPARQL.
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> are supposed to match the	shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
						Note that the values of <code>sh:valueShape</code> do not require an <code>rdf:type</code> triple - <code>sh:Shape</code> is implicit.
					</p>
					<pre class="example" title="Shape with sh:valueShape constraint">
ex:ValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueShape [
			a sh:Shape ;   # Optional
			sh:predicate [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .

ex:ValueShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				<section id="AbstractValueTypePropertyConstraint">
					<h4>sh:valueType</h4>
					<p class="issue">
						The details of valueType checking need to be fully worked out.
						In a nutshell, the goal is to have one or two properties to narrow down the type of values.
						The user experience may be best if there was just one property, sh:valueType.
						However, there are substantial differences between datatypes and class-based types.
						For datatypes, we should exclude reified values such as instances of xsd:integer.
						For resources, we need to make sure that (transitive) subclasses are accepted too.
						What about typeless resources - I believe these should be allowed if the valueType is rdfs:Resource or rdf:Property.
						Another question will be whether multiple valueTypes should be supported, and what their semantics should be.
						For now we only include an example of sh:valueType, to illustrate a possible design.
					</p>
				</section>
				<pre class="example" title="Shape with sh:valueType constraint">
ex:ValueTypeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueType xsd:string ;
	] .

ex:ValueTypeExampleValidResource
	ex:someProperty "A string" .</pre>
			</section>
			
			<section id="shapeconstraints-inverseProperty">
				<h3>Inverse Property Constraints (sh:inverseProperty)</h3>
				<p class="todo">
					TODO: This section is quite similar to the one about sh:property, only in the inverse direction.
					Before writing all this down, we'd rather wait until the forward direction has stabilized.
					A quick example should suffice for now:
				</p>
				<pre class="example" title="Shape with an inverse property constraint">
ex:InversePropertyConstraintExampleShape
	a sh:Shape ;
	sh:inverseProperty [
		sh:predicate ex:someProperty ;  # e.g. "child"
		sh:minCount 1 ;
		rdfs:label "is someProperty of" ;  # e.g. "parent"
	] .</pre>
			</section>
		
			<section id="shapeconstraints-or">
				<h3>Disjunctive Constraints (sh:OrConstraint)</h3>
				<p class="todo">
					TODO: The proposal here is just one possible syntax, based on a template.
					Other alternatives include to hard-code it into a new kind of Shape with its own syntax
					as outlined in Eric's version of the primer.
				</p>
				<p>
					SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether the <span class="term">focus node</span> matches at least one out of several shapes.
					This is comparable to a logical "or" operator.
				</p>
				<div id="def-orConstraint-text" class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						An <code>sh:Error</code> must be reported if the <span class="term">focus node</span> produces error-level
						constraint violations against both shapes <code>sh:shape1</code> and <code>sh:shape2</code>. 
					</div>
				</div>
				<div id="def-orConstraint-sparql" class="def def-sparql">
					<div class="def-header">SPARQL DEFINITION</div>
					<pre class="def-sparql-body">
SELECT (?this AS ?root)
WHERE {
	FILTER (!sh:hasShape(?this, ?shape1) &amp;&amp; !sh:hasShape(?this, ?shape2)) .
}</pre>
				</div>
				<p>
					The following example illustrates the use of <code>sh:OrConstraint</code> in a shape to verify
					that matching nodes have at least one value of <code>ex:exampleProperty1</code>
					or at least one value of <code>ex:exampleProperty2</code>.
				</p>
				<pre class="example" title="Shape with a disjunction">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		a sh:OrConstraint ;
		sh:shape1 [
			sh:property [
				sh:predicate ex:exampleProperty1 ;
				sh:minCount 1 ;
			] ;
		] ;
		sh:shape2 [
			sh:property [
				sh:predicate ex:exampleProperty2 ;
				sh:minCount 1 ;
			]
		]
	] .
	
ex:OrConstraintExampleValidResource
	sh:exampleProperty1 ex:someValue .</pre>
			</section>
		</section>
		
		<section id="shape-selection">
			<h2>Shape Selection</h2>
			<p>
				Some operations on SHACL graphs, such as <a href="#operation-checkNode"><code>checkNode</code></a> and
				<a href="#operation-checkGraph"><code>checkGraph</code></a> rely on in-graph information to determine
				which nodes need to be evaluated against which shapes.
				This section describes the two currently supported <span class="term">shape selection</span> properties.
			</p>
			<div class="issue">
				There are multiple proposals on how to associate resources with their shapes, in particular
				based on rdf:type or sh:nodeShape.
				The WG may chose to:
				<ul>
					<li>Only support one of these patterns</li>
					<li>Always support both of these patterns</li>
					<li>Support both of these patterns, allowing them to be switched on or off individually</li>
					<li>Support a more general mechanism that allows arbitrary selectors</li>
				</ul>
				Also we need to agree on terminology, e.g. Shape Selection vs Shape Mapping
			</div>
			<section>
				<h3>Shape selection based on rdf:type</h3>
				<p>
					RDF Schema and OWL provide a well-established framework to model domains in terms of classes and instances.
					A lot of existing data is already represented using these languages.
					In this <span class="term">shape selector</span>, the IRIs of classes double as shape definitions, i.e.
					it is possible to directly attach constraints at the IRI of a class.
					The property <code>rdf:type</code> is used to determine which shapes a given node needs to fulfill.
					Specialization between shapes is expressed via <code>rdfs:subClassOf</code>.
					This pattern is illustrated in the following example.
				</p>
				<pre class="example" title="Shape selection based on rdf:type">
ex:ExampleClass
	a rdfs:Class ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	rdf:type ex:ExampleClass .</pre>
			</section>
			<section>
				<h3>Shape selection based on sh:nodeShape</h3>
				<p>
					In some application scenarios, there may be unwanted interactions between existing RDFS models and shapes.
					For example, an application may want to ensure that there is no interaction between shapes and RDFS/OWL inferencing.
					In those cases, users can declare shapes as instances of <code>sh:Shape</code> and use <code>sh:nodeShape</code>
					to point from a node to its shape(s).
					This pattern is illustrated in the following example. 				
				</p>
				<pre class="example" title="Shape selection based on sh:nodeShape">
ex:ExampleShape
	a sh:Shape ;
	sh:constraint [
		...
	] .

ex:ExampleInstance
	sh:nodeShape ex:ExampleShape .</pre>
			</section>
		</section>
		
		<section id="templates">
			<h2>Templates</h2>
			<p>
				Templates can be used to encapsulate and parameterize <span class="term">executable bodies</span> based on arguments.
				Templates can be instantiated anywhere where a native constraint may appear (for example, at <code>sh:constraint</code>).
				SHACL includes several templates that were deemed to be of general use, including the <a href="#shapeconstraints-property">property constraint templates</a>.
				Such templates form a high-level vocabulary that may be directly interpreted ("hard-coded") without reliance on their executable bodies.
			</p>
			<p>
				Constraint templates are represented as IRI nodes that are instances of the class <code>sh:ConstraintTemplate</code>.
				SHACL also includes a more general superclass <code>sh:Template</code> that may be used for other kinds of templates (rules, stored queries etc) by third parties.
				Well-defined, non-abstract templates MUST provide at least one executable body property, such as <a href="#sparql-templates"><code>sh:sparql</code></a>.
				The following example illustrates the definition of a local constraint template based on a SPARQL query.
			</p>
			<pre class="example" title="Constraint template based on SPARQL">
ex:ExampleTemplate
	a sh:ConstraintTemplate ;
	rdfs:label "Example Template" ;
	rdfs:comment "Verifies that the given focus node (?this) has at least one value for the argument property (?argProperty)." ;
	sh:argument [
		sh:predicate ex:argProperty ;
		sh:valueType rdf:Property ;
	] ;
	sh:labelTemplate "The property {?argProperty} must have at least one value" ;
	sh:sparql """
		SELECT (?this AS ?root) (?argProperty AS ?path) 
		WHERE {
			FILTER NOT EXISTS { ?this ?argProperty ?anyValue }
		}
		""" .</pre>
			<p>
				The following sections introduce details of the properties that such templates may have.
			</p>
			<section id="template-arguments">
				<h3>Template Arguments</h3>
				<p>
					The arguments of a template are attached via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>.
					The <code>rdf:type</code> triple of the argument can be omitted if it is a blank node with an incoming <code>sh:argument</code> triple.
				</p>
				<p>
					Each <code>sh:Argument</code> MUST have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs such that no pair of argument predicates in the scope of the same template have the same local name.
					(This ensures that there is a unique mapping from arguments into SPARQL variables). <span class="todo">TODO: Check if all local names can become variables, otherwise define translation algorithm.</span>
					Arguments are "inherited" from the superclasses of the template <span class="todo">(may need details)</span>.
				</p>
				<p>
					An <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
				</p>
				<p>
					An <code>sh:Argument</code> may declare a default value via <code>sh:defaultValue</code>.
					For non-optional arguments, the engine must use the declared default value for template instances that do not define a value for this argument.
				</p>
				<p>
					An <code>sh:Argument</code> may declare one value for the property <code>sh:valueType</code>.
					This can be used to communicate the expected value type of the argument in template instances.
					Some implementations MAY use this information to prevent the execution of a template with invalid arguments, and to signal errors.
				</p>
			</section>
			<section id="template-labelTemplate">
				<h3>sh:labelTemplate</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used to suggest how instances of the template shall be rendered to humans.
					The <code>sh:labelTemplate</code> must be a string that can reference the arguments using the syntax <code>{?varName}</code>,
					where <code>?varName</code> is the name of the SPARQL variable that corresponds to the argument.
					In SPARQL-based systems, the function <a href="#function-label"><code>sh:label</code></a> may be used to expand those label templates into consumable strings.
				</p>
			</section>
		</section>
		
		<section id="functions">
			<h2>Functions</h2>
			<p class="todo">
				This section is backed by a requirement that has not yet been officially approved by the WG.
			</p>
			<p>
				SHACL <span class="term">functions</span> define operations that produce an RDF node based on arguments.
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL.
			</p>
			<p>
				Functions must be declared as instances of the class <code>sh:Function</code>.
				Well-defined, non-abstract functions MUST provide at least one executable body property, such as <a href="#sparql-functions"><code>sh:sparql</code></a>.
				The following example illustrates the definition of a <span class="term">function</span> based on a SPARQL query.
			</p>
			<pre class="example" title="SHACL function with a SPARQL body">
# Example call: ex:exampleFunction(4, 3) returns 7
ex:exampleFunction
	a sh:Function ;
	rdfs:comment "Computes the sum of its two arguments ?arg1 and ?arg2." ;
	sh:returnType xsd:integer ;
	sh:argument [
		sh:predicate sh:arg1 ;
		sh:valueType xsd:integer ;
		rdfs:comment "The first operand" ;
	] ;
	sh:argument [
		sh:predicate sh:arg2 ;
		sh:valueType xsd:integer ;
		rdfs:comment "The second operand" ;
	] ;
	sh:sparql """
		SELECT (?arg1 + ?arg2 AS ?result)
		WHERE {
		}
		""" .</pre>
			<p>
				The following sections introduce details of the properties that such functions may have.
			</p>
			<section id="function-arguments">
				<h3>Function Arguments</h3>
				<p>
					The arguments of a function are attached to its <code>sh:Function</code> via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>.
					The <code>rdf:type</code> triple of the argument can be omitted if it is a blank node with an incoming <code>sh:argument</code> triple.
					Arguments are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?arg1, ?arg2)</code>.
				</p>
				<p>
					Each <code>sh:Argument</code> MUST have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be <code>sh:arg1</code> for the first argument,
					<code>sh:arg2</code> for the second argument, etc.
					Arguments are "inherited" from the superclasses of the function.
					For example if a superclass already declares <code>sh:arg1</code> then subclasses may only define <code>sh:arg2</code> etc.
				</p>
				<p>
					Each <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
					If an argument has been declared optional, then all succeeding arguments must also be declared optional.
				</p>
				<p>
					Each <code>sh:Argument</code> may declare one value for the property <code>sh:valueType</code>.
					This can be used to communicate the expected value type of the argument in function calls.
					Some implementations MAY use this information to prevent the execution of a function with invalid arguments, and to signal errors.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					the engine how to cast a native value into an RDF value type.
				</p>
			</section>
			<section id="function-cachable">
				<h3>sh:cachable</h3>
				<p>
					A <code>sh:Function</code> may have a property <code>sh:cachable</code> set to <code>true</code>.
					Functions that are marked as cachable MUST always return the same value for the same combination of arguments, regardless of the query graphs.
					Engines can use this information to cache and reuse previous function calls without repeatedly evaluating their executable body.
				</p>
			</section>
		</section>
		
		<section id="graphs">
			<h2>Graph Management</h2>
			<p class="todo">
				TODO: Introduce <code>sh:Graph</code>, <code>sh:include</code>, <code>sh:library</code> once they have been discussed and approved by the WG.
			</p>
		</section>
		
		<section id="contexts">
			<h2>Contexts</h2>
			<p>
				A <span class="term">context</span> is a IRI that can be used to group related shapes or constraints together.
				<span class="term">Contexts</span> can be used to selectively activate or deactivate certain constraints for constraint checking or other use cases.
				This makes it possible to share shape declarations while giving certain applications the freedom to override selected aspects of these shapes.
			</p>
			<p>
				A <span class="term">context</span> is defined as an instance of the class <code>sh:Context</code>.
				The property <code>sh:context</code> can be attached to individual instances of <code>sh:Constraint</code> and <code>sh:Shape</code> (and possibly <code>rdfs:Class</code>).
			</p>
			<p class="todo">
				TODO: Details need to be worked out, e.g. whether graphs can also serve as contexts.
				We may also need a class to represent ContextFilters needed by the operations.
			</p>
		</section>

		<section id="profiles">
			<h2>Profiles</h2>
			<p>
				A Profile is a set of shape templates.
				Profiles can be used to define controlled sub-dialects of SHACL, e.g. with desirable complexity.
				Tools may decide to only support certain profiles, for example so that they can hard-code and optimize certain algorithms.
				Since Profiles are entirely based on templates, <span class="term">native constraints</span> such as those in SPARQL are outside of their expressivity.
			</p>
			<p>
				The class <code>sh:Profile</code> is used to represent SHACL profiles.
				The property <code>sh:member</code> links a <code>sh:Profile</code> with the templates that are in the profile.
				The following example defines a profile consisting of the two built-in templates for min/max cardinality and value shape,
				as well as their shared superclass (which defines the <code>sh:predicate</code> property) and their shared subclass
				<code>sh:PropertyConstraint</code> that is directly instantiated.
			</p>
			<pre class="example" title="Simple SHACL Profile">
ex:MyProfile
	a sh:Profile ;
	sh:member sh:AbstractPropertyConstraint ;
	sh:member sh:AbstractCountPropertyConstraint ;
	sh:member sh:AbstractValueShapePropertyConstraint ;
	sh:member sh:PropertyConstraint .</pre>
			<p>
				In the example above, the profile includes only the properties from the enumerated template classes.
				Sibling template classes such as <code>sh:AbstractAllowedValuesPropertyConstraint</code> are outside of the profile,
				which means that <code>sh:allowedValues</code> would be out of scope for this profile.
			</p>
		</section>

		<section id="operations">
			<h2>Supported Operations</h2>
			<p>
				This section enumerates the basic operations that complete SHACL engines SHOULD support.
				The specification does not prescribe how these operations are exposed to the user of a SHACL system.
				The following table provides an overview of the operations and how they depend on each other.
			</p>
			<table class="term-table" border="1" cellpadding="5">
				<tr>
					<th>Operation</th>
					<th>Depends&nbsp;On</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><a href="#operation-checkConstraint"><code>checkConstraint</code></a></td>
					<td></td>
					<td>Evaluates a single constraint</td>
				</tr>
				<tr>
					<td><a href="#operation-checkNodeAgainstShape"><code>checkNodeAgainstShape</code></a></td>
					<td><code>checkConstraint</code></td>
					<td>Evaluates a given node against a given shape</td>
				</tr>
				<tr>
					<td><a href="#operation-checkNode"><code>checkNode</code></a></td>
					<td><code>checkNodeAgainstShape</code></td>
					<td>Evaluates a given node against the shapes derived from the graph</td>
				</tr>
				<tr>
					<td><a href="#operation-checkGraph"><code>checkGraph</code></a></td>
					<td><code>checkNode</code>, <code>checkConstraint</code></td>
					<td>Evaluates all nodes in a graph, including global constraints</td>
				</tr>
			</table>
			<p>
				All operations produce <span class="term">constraint violations</span>.
				For the sake of this specification, we assume that the constraint violations are represented as instances of
				<code>sh:ConstraintViolation</code>	that are added to a <span class="term">result graph</span> that is known
				to each operation for the duration of its execution.
				Actual implementations may use different data structures and result formats and input and output to these operations.
			</p>
			<p class="todo">
				All operations have an implicit argument, which is a data set with a default named graph.
				Details of this need to be fleshed out, pending design decisions for the section <a href="#graphs">Graph Management</a>.
			</p>
			<section id="operation-checkConstraint">
				<h3>checkConstraint</h3>
				<p>
					This operation evaluates a single <span class="term">constraint</span> and produces <span class="term">constraint violations</span>. 
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>?constraint</code></td>
						<td><code>sh:Constraint</code></td>
						<td>The <span class="term">constraint</span> to evalate</td>
					</tr>
					<tr>
						<td><code>?focusNode</code></td>
						<td><code>rdfs:Resource</code> (Optional)</td>
						<td>The <span class="term">focus node</span>, if present.</td>
					</tr>
				</table>
				<p>
					This operation assumes that the <code>?constraint</code> is either a <span class="term">native constraint</span>
					or a <span class="term">template constraint</span>.
				</p>
				<ul>
					<li>
						For <span class="term">native constraints</span>, the operation selects one of the provided <span class="term">executable bodies</span>.
						For example if the constraint has a <code>sh:sparql</code> query and the engine is capable of executing SPARQL,
						it should follow the execution rules specified in the <a href="#sparql-constraints">SPARQL-based Constraints</a> section,
						using the provided <code>?focusNode</code> if present.
						A <code>sh:Warning</code> should be produced if no suitable <span class="term">executable body</span> was found.
					</li>
					<li>
						For <span class="term">template constraints</span>, the operation traverses the associated template as well as all its superclasses.
						For each of those templates, it selects the best suitable <span class="term">executable body</span>.
						For example, if the template has a <code>sh:sparql</code> query and the engine is capable of executing SPARQL,
						it should follow the execution rules specified in the <a href="#sparql-templates">SPARQL-based Templates</a> section,
						using the provided <code>?focusNode</code> if present.
						A <code>sh:Warning</code> should be produced if no suitable <span class="term">executable body</span> was found.
					</li>
				</ul>
			</section>
			<section id="operation-checkNodeAgainstShape">
				<h3>checkNodeAgainstShape</h3>
				<p>
					This operation checks a single <span class="term">node</span> against all constraints associated with a given shape.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>?focusNode</code></td>
						<td><code>rdfs:Resource</code></td>
						<td>The <span class="term">focus node</span> to check</td>
					</tr>
					<tr>
						<td><code>?shape</code></td>
						<td><code>sh:Shape</code></td>
						<td>The <span class="term">shape</span> that has the constraints.</td>
					</tr>
					<tr>
						<td><code>?contextFilter</code></td>
						<td><code class="todo">TBD</code></td>
						<td>The <span class="term">context filter</span> specifying which constraints to exclude/include.</td>
					</tr>
				</table>
				<p>
					Algorithm in pseudo-code:
				</p>
				<pre>
forEach ?s := ?shape and its transitive super-shapes
	if ?s matches the ?contextFilter
		forEach ?constraint := (?s sh:constraint|sh:property|sh:inverseProperty|sh:argument ?constraint) 
			if ?constraint matches the ?contextFilter
				checkConstraint(?constraint, ?focusNode)</pre>
			</section>
			<section id="operation-checkNode">
				<h3>checkNode</h3>
				<p>
					This operation checks a single <span class="term">node</span> against all shapes associated with it, based on in-graph mappings.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>?focusNode</code></td>
						<td><code>rdfs:Resource</code></td>
						<td>The <span class="term">focus node</span> to check</td>
					</tr>
					<tr>
						<td><code>?contextFilter</code></td>
						<td><code class="todo">TBD</code></td>
						<td>The <span class="term">context filter</span> specifying which shapes and constraints to exclude/include.</td>
					</tr>
				</table>
				<p>
					Algorithm in pseudo-code:
				</p>
				<pre>
forEach ?shape := (?focusNode sh:nodeShape|rdf:type ?shape)
	checkNodeAgainstShape(?focusNode, ?shape, ?contextFilter)</pre>
				<p class="todo">
					Note that the selection properties sh:nodeShape|rdf:type are not decided yet.
					Possibly we need a mechanism to switch one or the other off (could become a parameter).
				</p>
			</section>
			<section id="operation-checkGraph">
				<h3>checkGraph</h3>
				<p>
					This operation checks a whole graph against global constraints and all shapes associated with it, based on in-graph mappings.
				</p>
				<table class="term-table" border="1" cellpadding="5">
					<tr>
						<th>Argument</th>
						<th>Type</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>?contextFilter</code></td>
						<td><code class="todo">TBD</code></td>
						<td>The <span class="term">context filter</span> specifying which shapes and constraints to exclude/include.</td>
					</tr>
				</table>
				<p>
					Algorithm in pseudo-code:
				</p>
				<pre>
forEach ?focusNode := (?focusNode sh:nodeShape|rdf:type ?anyShape)
	checkNode(?focusNode, ?contextFilter)

forEach ?constraint := instance of sh:GlobalConstraint
	if ?constraint matches the ?contextFilter
		checkConstraint(?constraint)</pre>
   			</section>
		</section>

		<section id="sparql">
			<h2>SPARQL-based Execution (sh:sparql)</h2>
			<p>
				The property <code>sh:sparql</code> is used to link constraints, templates and functions with an executable body in SPARQL.
				The values of <code>sh:sparql</code> must be string literals that can be parsed into syntactically valid SPARQL queries.
				Prior to parsing, a SHACL engine MUST add all prefix declarations from the defining graph into the beginning of the string.
				This means that the values of <code>sh:sparql</code> do not have to explicitly state any <code>@prefix</code> declarations for the prefixes used in the SPARQL query.
			</p>
			<p>
				The following sections provide details on how <code>sh:sparql</code> is interpreted for
				<a href="#sparql-constraints">constraints</a>, <a href="#sparql-templates">templates</a> and <a href="#sparql-functions">functions</a>.
			</p>
			<section id="sparql-constraints">
				<h3>SPARQL-based Constraints</h3>
				<p>
					The SPARQL queries attached to a <span class="term">constraint</span> via <code>sh:sparql</code> must be of the query form <code>ASK</code>, <code>CONSTRUCT</code> or <code>SELECT</code>.
					<a href="#sparql-constraints-construct"><code>CONSTRUCT</code></a> is the most flexible option, so the following section starts with describing how these are executed.
					The subsequent sections describe how <a href="#sparql-constraints-ask"><code>ASK</code></a> and <a href="#sparql-constraints-select"><code>SELECT</code></a> queries can be transformed into equivalent <code>CONSTRUCT</code> forms.
				</p>
				<p class="todo">
					There is ongoing <a href="https://lists.w3.org/Archives/Public/public-data-shapes-wg/2015Feb/0359.html">discussion</a> about whether all options below shall be supported, and whether an approach based on variable names only would be better.
				</p>
				<section id="sparql-constraints-construct">
					<h4>CONSTRUCT-based Constraints</h4>
					<p>
						Constraints backed by a SPARQL <code>CONSTRUCT</code> query are assumed to construct <span class="term">constraint violations</span>.
						<code>CONSTRUCT</code> queries consist of a <span class="term">graph template</span> and a <code>WHERE</code> clause.
						The output of a <code>CONSTRUCT</code> query is a new RDF graph, and the triples from those RDF graphs need to be added to the result graph of the constraint checking operation.
					</p>
					<p>
						The following example illustrates how a <code>CONSTRUCT</code> query is used to produce instances of <code>sh:Error</code> for every instance of <code>ex:ExampleClass</code> that has no <code>rdfs:label</code>.
						Note that <code>_:error</code> is a SPARQL syntax representing a new blank node for each row of the result set (<code>WHERE</code> clause).
					</p>
					<pre class="example" title="Global constraint based on SPARQL CONSTRUCT">
sh:ExampleGlobalConstructConstraint
	a sh:GlobalConstraint ;
	sh:sparql """
		CONSTRUCT {
			_:error a sh:Error .
			_:error sh:root ?instance .
			_:error sh:path rdfs:label .
			_:error sh:message "Instances of ex:ExampleClass must have an rdfs:label" .
		}
		WHERE {
			?instance a ex:ExampleClass .
			FILTER NOT EXISTS { ?instance rdfs:label ?anyLabel } .
		}
		""" .
}</pre>
					<p>
						The instances of <code>sh:ConstraintViolation</code> produced by such queries are not modified further,
						except that the engine SHOULD add <code>sh:source</code> triples that have each constraint violation
						instance as subject and the surrounding <code>sh:Constraint</code> as its object.
					</p>
				</section>
				<section id="sparql-constraints-ask">
					<h4>ASK-based Constraints</h4>
					<p class="todo">
						Issue: It is quite possible that ASK queries will be removed from the language.
						For many use cases, a corresponding SELECT query is easy to write.
						Furthermore, ASK often leads to confusion because they need to return false to signal correctness.
					</p>
					<p>
						SPARQL queries of the <code>ASK</code> form that produce <code>true</code> signal a constraint violation.
						As shown in the following example, the subject node holding the <code>sh:sparql</code> query may also have other properties that define properties of the constraint violation.
					</p>
					<pre class="example" title="Global constraint based on SPARQL ASK">
ex:ExampleGlobalAskConstraint
	a sh:GlobalConstraint ;
	sh:level sh:Warning ;
	sh:message "Properties marked as deprecated should not be used" .
	sh:sparql """
		ASK {
			?subject ?predicate ?object .
			?predicate ex:deprecated true .
		}
		""" .</pre>
					<p>
						The <code>ASK</code> query above gets translated into the following <code>CONSTRUCT</code>:
					</p>
					<pre class="example">
CONSTRUCT {
	_:violation a sh:Warning .
	_:violation sh:message "Properties marked as deprecated should not be used" .
}
WHERE {
	?subject ?predicate ?object .
	?predicate ex:deprecated true .
}</pre>
					<p>
						In its most basic form, an <code>ASK</code> query is translated into a <code>CONSTRUCT</code> form with an identical <code>WHERE</code> clause.
						The <span class="term">graph template</span> of the <code>CONSTRUCT</code> must create exactly one blank node.
						The <code>rdf:type</code> of that blank node must be the value of the property <code>sh:level</code> at the surrounding subject node.
						If no <code>sh:level</code> has been specified, <code>sh:Error</code> must be used as default type.
					</p>
					<p>
						If the surrounding subject node defines a <code>sh:message</code> then the constructed blank node needs to have a corresponding triple.
						Similarly, the values of <code>sh:root</code>, <code>sh:path</code> and <code>sh:value</code> must be inserted (they cannot be blank nodes).
					</p>
					<p class="todo">
						TODO: Maybe allow special variable names such as <code>?root</code>, <code>?path</code> etc to be projected similar to how this happens with SELECT queries.
					</p>
				</section>
				<section id="sparql-constraints-select">
					<h4>SELECT-based Constraints</h4>
					<p>
						SPARQL queries of the <code>SELECT</code> form need to produce one constraint violation blank node for each row of the produced result set.
						The following example illustrates a constraint that flags warnings for all subjects that have a <code>rdfs:label</code> with the language tag <code>"de"</code>.
					</p>
					<pre class="example" title="Global constraint based on SPARQL SELECT">
ex:ExampleGlobalSelectConstraint
	a sh:GlobalConstraint ;
	sh:level sh:Warning ;
	sh:message "Deutsch is verboten" ;
	sh:path rdfs:label ;
	sh:sparql """
		SELECT (?subject AS ?root) (?object AS ?value)
		WHERE {
			?subject rdfs:label ?object .
			FILTER (lang(?object) = "de") .
		}
		""" .</pre>
					<p>
						For execution, the constraint above can be turned into the following <code>CONSTRUCT</code> query.
					</p>
					<pre class="example">
CONSTRUCT {
	_:violation a sh:Warning .
	_:violation sh:message "Deutsch is verboten" .
	_:violation sh:path rdfs:label .
	_:violation sh:root ?subject .
	_:violation sh:value ?object .
}
WHERE {
	?subject rdfs:label ?object .
	FILTER (lang(?object) = "de") .
}</pre>
					<p>
						The following naming conventions are used to map the result variables of a <code>SELECT</code> into corresponding RDF properties: 
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Result&nbsp;Variable</th>
							<th>Constraint&nbsp;Violation&nbsp;Property</th>
						</tr>
						<tr>
							<td><code>?level</code></td>
							<td><code>rdf:type</code></td>
						</tr>
						<tr>
							<td><code>?message</code></td>
							<td><code>sh:message</code></td>
						</tr>
						<tr>
							<td><code>?predicate</code></td>
							<td><code>sh:predicate</code></td>
						</tr>
						<tr>
							<td><code>?root</code></td>
							<td><code>sh:root</code></td>
						</tr>
						<tr>
							<td><code>?value</code></td>
							<td><code>sh:value</code></td>
						</tr>
					</table>
					<p>
						Similar to <a href="#sparql-constraints-ask"><code>ASK</code></a> queries, corresponding values attached to the surrounding subject node must be used in the absence of the result variables above.
					</p>
					<p>
						In local constraints the variable <code>?this</code> must be projected into <code>?root</code> unless the <code>SELECT</code> clause already projects to <code>?root</code>.
						This means that the frequently needed pattern <code>SELECT (?this AS ?root)</code> is redundant.
					</p>
				</section>
				<section>
					<h4>Binding the Focus Node in Local SPARQL Constraints (?this)</h4>
					<p>
						The SPARQL variable <code>?this</code> has a special meaning in local constraints.
						When SPARQL constraints are executed then the variable <code>?this</code> needs to be pre-bound to the <span class="term">focus node</span>.
						<span class="todo">(Need a pointer to what "pre-binding" means in this context)</span>
					</p>
				</section>
			</section>
			<section id="sparql-templates">
				<h3>SPARQL-based Templates</h3>
				<p>
					If a <code>sh:Template</code> has a value for <code>sh:sparql</code>, then the corresponding instances need to follow the same execution rules as outlined for <a href="#sparql-constraints">SPARQL-based Constraints</a>.
					The only difference is that the SPARQL queries need to be executed with additional <span class="term">pre-bound</span> variables, derived from the arguments of the template.
					The names of those variables must match the <span class="term">local name</span> of the argument predicates.
					For example, if an argument is represented with the predicate <code>ex:myArgument</code> then the variable <code>?myArgument</code> must be <span class="term">pre-bound</span> with the value of the argument in the template instance.
				</p>
			</section>
			<section id="sparql-functions">
				<h3>SPARQL-based Functions</h3>
				<p>
					If a <code>sh:Function</code> has a value for <code>sh:sparql</code>, then a SPARQL-based execution engine SHOULD
					execute the provided SPARQL query on the current data set.
					In this SPARQL query, the engine needs to <span class="term">pre-bind</span> the variables <code>?arg1</code>, <code>?arg2</code> etc
					based on the provided arguments of the function call.
					The SPARQL query must be of type ASK or SELECT.
					For ASK queries, the function's return value is the result of the ASK query execution.
					For SELECT queries, the function's return value is the first binding of the first result variable in the result set.
				</p>
				<p>
					Some execution engines may ignore the specified <code>sh:sparql</code> query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified <code>sh:sparql</code> query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the <code>sh:sparql</code> query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
			<section>
				<h3>Built-in Functions</h3>
				<p>
					SPARQL-based SHACL engines MUST implement the following SPARQL functions.
				</p>
				<section id="function-hasShape">
					<h4>sh:hasShape</h4>
					<p>
						The built-in function <code>sh:hasShape</code> returns <code>true</code> if	a given node (<code>?arg1</code>) matches a given shape (<code>?arg2</code>).
						The return type of this function is <code>xsd:boolean</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Value type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?arg1</code></td>
							<td>Any IRI or blank node</td>
							<td>The node to check</td>
						</tr>
						<tr>
							<td><code>?arg2</code></td>
							<td><code>sh:Shape</code> or <code>rdfs:Class</code></td>
							<td>The shape to match against</td>
						</tr>
					</table>
					<p>
						This function MUST perform constraint checking equivalent to the <a href="#operation-checkNodeAgainstShape"><code>checkNodeAgainstShape</code></a> operation.
						The function MUST return <code>true</code> if the operation returns no error-level constraint violations, <code>false</code> if any error-level constraint violations exist. 
					</p>
				</section>
				<section id="function-hasNodeType">
					<h4>sh:hasNodeType</h4>
					<p>
						The function <code>sh:hasNodeType</code> can be used to verify whether a given
						node (<code>?arg1</code>) has the provided <code>sh:NodeType</code> (<code>?arg2</code>).
						The return type of this function is <code>xsd:boolean</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Value type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?arg1</code></td>
							<td>Any</td>
							<td>The node to test</td>
						</tr>
						<tr>
							<td><code>?arg2</code></td>
							<td><code>sh:NodeType</code></td>
							<td>The node type that <code>?arg1</code> is expected to have</td>
						</tr>
					</table>
					<div id="def-hasNodeType-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
ASK {
	FILTER (isIRI(?arg1) &amp;&amp; (?arg2 IN (sh:IRI, sh:BlankNodeOrIRI, sh:LiteralOrIRI, sh:Node)) ||
		(isLiteral(?arg1) &amp;&amp; (?arg2 IN (sh:Literal, sh:BlankNodeOrLiteral, sh:LiteralOrIRI, sh:Node))) ||
 		(isBlank(?arg1) &amp;&amp; (?arg2 IN (sh:BlankNode, sh:BlankNodeOrLiteral, sh:BlankNodeOrIRI, sh:Node))))
}</pre>
					</div>
					<pre class="example">
sh:hasNodeType(42, sh:IRI)   # false
sh:hasNodeType(42, sh:Literal)   # true
sh:hasNodeType(ex:MyInstance, sh:BlankNodeOrIRI)   # true</pre>
				</section>
				<section id="function-inverseValueCount">
					<h4>sh:inverseValueCount</h4>
					<p>
						The function <code>sh:inverseValueCount</code> returns the number of triples that have
						a given object (<code>?arg1</code>) and a given predicate (<code>?arg2</code>).
						The return type of this function is <code>xsd:integer</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Value type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?arg1</code></td>
							<td>Any node</td>
							<td>The object node</td>
						</tr>
						<tr>
							<td><code>?arg2</code></td>
							<td><code>rdf:Property</code></td>
							<td>The predicate node</td>
						</tr>
					</table>
					<div id="def-inverseValueCount-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT (COUNT(?subject) AS ?result)
WHERE {
	?subject ?arg2 ?arg1 .
}</pre>
					</div>
				</section>
				<section id="function-label">
					<h4>sh:label</h4>
					<p>
						The function <code>sh:label</code> returns a string representation of a given node <code>?arg1</code>.
						This function is the recommended entry point whenever a node shall be displayed to end users, e.g. as part of a constructed <code>sh:message</code>.
						The output of this function must be an <code>xsd:string</code> literal.
						Unbound is not a valid result.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Value type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?arg1</code></td>
							<td>Any node</td>
							<td>The node to render</td>
						</tr>
					</table>
					<p>
						The implementation details of this function are left unspecified.
						As a guideline, the function MAY use the values of <code>rdfs:label</code> and similar properties for resources.
						As a fall-back, it may return the qname or full IRI of a resource.
						For literal values, the function may use the lexical form, but may also render date and time literals in locale-specific strings.
					</p>
				</section>
				<section id="function-valueCount">
					<h4>sh:valueCount</h4>
					<p>
						The function <code>sh:valueCount</code> returns the number of triples that have
						a given subject (<code>?arg1</code>) and a given predicate (<code>?arg2</code>).
						The return type of this function is <code>xsd:integer</code>.
					</p>
					<table class="term-table" border="1" cellpadding="5">
						<tr>
							<th>Argument</th>
							<th>Value type</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>?arg1</code></td>
							<td>Any IRI or blank node</td>
							<td>The subject node</td>
						</tr>
						<tr>
							<td><code>?arg2</code></td>
							<td><code>rdf:Property</code></td>
							<td>The predicate node</td>
						</tr>
					</table>
					<div id="def-valueCount-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT (COUNT(?object) AS ?result)
WHERE {
	?arg1 ?arg2 ?object .
}</pre>
					</div>
				</section>
			</section>
		</section>

	</body>
</html>
