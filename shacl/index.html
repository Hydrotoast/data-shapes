<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "ED",
				shortName:  "shacl",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Dimitris Kontokostas",
						url:        "http://aksw.org/DimitrisKontokostas",
						company:    "University of Leipzig",
						companyURL: "http://informatik.uni-leipzig.de/",
						w3cid:      58399
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "//www.w3.org/2014/data-shapes/",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status"
			};
		</script>
		<!-- script src="https://www.w3.org/scripts/jquery/2.1/jquery.min.js"></script--> 
		<style>

			pre {
				tab-size: 4;
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.part-header {
				font-weight: bold;
			}
		
			.term {
				font-style: italic;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}
			
			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of RDF graphs.
				SHACL groups these descriptions and constraints into "shapes", which specify conditions that apply at a given RDF node.
				Shapes provide a high-level vocabulary to identify predicates and their associated cardinalities, datatypes and other constraints.
				Additional constraints can be associated with shapes using SPARQL.
				The vocabulary of SHACL has been designed to support similar extension languages besides SPARQL.
				These extension languages can also be used to define new high-level vocabulary terms.
				SHACL shapes can be used to communicate information about data structures associated with some process or interface, generate or validate data, or drive user interfaces.
				This document defines the SHACL language and its underlying semantics.
			</p>	
		</section>

		<section id="sotd">
		</section>
		<section class='introductory'>
		  <h2>Revision History</h2>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes/commits/gh-pages/shacl/index.html">Git repository</a>.
			</p>
			<ul>
				<li><b>2016-03-12</b>: Added issue warning regarding recursion</li>
				<li><b>2016-03-04</b>: Simplified the definition of sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-02-24</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-02-19</b>: Clarified that support for <code>$shapesGraph</code> is optional (<a href="http://www.w3.org/2014/data-shapes/track/issues/47">ISSUE-47</a>)</li>
				<li><b>2016-02-19</b>: Clarified that the SHACL graph URI includes the # (<a href="http://www.w3.org/2014/data-shapes/track/issues/129">ISSUE-129</a>)</li>
				<li><b>2016-02-18</b>: Removed reference to the proposed class <code>sh:QCC</code>(<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-12</b>: Added a paragraph on the limits of the core vocabulary, highlighting how rdf:Lists can be handled by the extension mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/119">ISSUE-119</a>)</li>
				<li><b>2016-02-10</b>: Added <code>sh:partition</code>. (<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-05</b>: Removed value type constraints on various constraint properties such as sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/117">ISSUE-117</a>)</li>
				<li><b>2016-01-29</b>: Clarified that validation results must be based on the data graph only. (<a href="http://www.w3.org/2014/data-shapes/track/issues/118">ISSUE-118</a>)</li>
				<li><b>2016-01-25</b>: Clarified direction of property path. Remove comment about consistency. (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-22</b>: Switched closed shapes syntax to sh:closed (<a href="http://www.w3.org/2014/data-shapes/track/issues/115">ISSUE-115</a>)</li>
				<li><b>2016-01-21</b>: Limit definition of shapes that are also classes to the shapes graph (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-19</b>: Describe scoping of shapes that are also classes (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-18</b>: Stated starting point for recursion (<a href="http://www.w3.org/2014/data-shapes/track/issues/22">ISSUE-22</a>)</li>
				<li><b>2016-01-18</b>: Clarified the meaning of filter shapes (<a href="http://www.w3.org/2014/data-shapes/track/issues/49">ISSUE-49</a>)</li>
				<li><b>2016-01-11</b>: Deleted operations section (<a href="http://www.w3.org/2014/data-shapes/track/issues/108">ISSUE-108</a>)</li>
				<li><b>2016-01-11</b>: Added derived properties (<a href="http://www.w3.org/2014/data-shapes/track/issues/97">ISSUE-97</a>)</li>
				<li><b>2016-01-11</b>: Dropped sh:ShapeClass (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>), elaborated on possible sh:scopeClass rule</li>
				<li><b>2016-01-10</b>: Added sh:order (<a href="http://www.w3.org/2014/data-shapes/track/issues/100">ISSUE-100</a>) and sh:group (<a href="http://www.w3.org/2014/data-shapes/track/issues/114">ISSUE-114</a>)</li>
				<li><b>2016-01-10</b>: Introduced sh:datatypeIn and sh:classIn, deleted sh:text (<a href="http://www.w3.org/2014/data-shapes/track/issues/104">ISSUE-104</a>)</li>
				<li><b>2016-01-09</b>: Syntax simplifications: Switched to sh:not, sh:and, sh:or, sh:equals, sh:notEquals, sh:lessThan, sh:lessThanOrEquals (<a href="http://www.w3.org/2014/data-shapes/track/issues/103">ISSUE-103</a>)</li>
				<li><b>2015-12-02</b>: Fixed <a href="https://github.com/w3c/data-shapes/issues/9">minor mistake in spec - ex:unsinged</a>.</li>
				<li><b>2015-11-20</b>: Switched from rdfs:label/rdfs:comment at property constraints to sh:name/sh:description (ISSUE-112)</li>
				<li><b>2015-11-06</b>: Renamed sh:nodeShape to sh:scopeNode, clarified that its triples are expected in shapes graph (ISSUE-61)</li>
				<li><b>2015-10-30</b>: Deleted sh:cachable, removed the option for sh:sparql to be a query fragment in sh:scope</li>
				<li><b>2015-10-29</b>: Improved wording in the definition of sh:in.</li>
				<li><b>2015-10-28</b>: Separated definitions of sh:qualifiedMinCount and sh:qualifiedMaxCount</li>
				<li><b>2015-10-22</b>: Define sh:minLength, sh:maxLength, sh:qualifiedMinCount, and sh:qualifiedMaxCount without reference to default values</li>
				<li><b>2015-10-22</b>: Replaced ex:bornIn with ex:residentIn in Section 2.2</li>
				<li><b>2015-10-16</b>: Added sh:SPARQLConstraint and sh:SPARQLScope (part of ISSUE-98)</li>
				<li><b>2015-10-16</b>: Renamed sh:valueClass to sh:class, sh:allowedValues to sh:in, sh:directValueType to sh:directType (part of ISSUE-98)</li>
				<li><b>2015-10-15</b>: Define sh:minCount and sh:maxCount without reference to default values</li>
				<li><b>2015-10-15</b>: Use real-world names in examples 3, 4 and 5</li>
				<li><b>2015-10-15</b>: Changed SPARQL definition of sh:AllObjects, implementing resolution to ISSUE-90</li>
				<li><b>2015-10-09</b>: Added sh:flags and sh:uniqueLang</li>
				<li><b>2015-09-23</b>: Multiple minor stylistic edits and corrections</li>
				<li><b>2015-09-21</b>: Added button to show or hide SPARQL definitions (thanks to Simon)</li>
				<li><b>2015-09-18</b>: Deleted <code>sh:XorConstraint</code> as resolved, renamed <code>sh:Error</code> to <code>sh:Violation</code></li>
				<li><b>2015-09-17</b>: Added missing definition of <code>sh:class</code>, editorial changes, renamed sh:ClosedShape to sh:Closed, added sh:sourceTemplate</li>
				<li><b>2015-09-15</b>: Restructured Part 2, with new examples, integrated SPARQL binding and rewritten Operations section</li>
				<li><b>2015-09-14</b>: Added SPARQL definitions for each constraint type, added description of sh:hasShape function</li>
				<li><b>2015-09-11</b>: Restructured constraint section, cleaned up results vocabulary</li>
				<li><b>2015-09-10</b>: Added sh:shapesGraph property (<a href="http://www.w3.org/2014/data-shapes/track/issues/44">ISSUE-44</a>)</li>
				<li><b>2015-09-09</b>: Rewritten introduction, dropped Profile section, word-smithing on sh:class</li>
				<li><b>2015-09-04</b>: Applied resolution to <a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a></li>
				<li><b>2015-09-03</b>: Many editorial changes, restructured section 5 (scopes and filters) into section 2 (Shapes)</li>
				<li><b>2015-09-01</b>: Minor changes and clarifications</li>
				<li><b>2015-08-24</b>: Added section on sh:defaultValueType (<a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a>)</li>
				<li><b>2015-08-21</b>: Added support for validation functions (<a href="http://www.w3.org/2014/data-shapes/track/issues/79">ISSUE-79</a>)</li>
				<li><b>2015-08-14</b>:
					Added qualified cardinality restrictions (<a href="http://www.w3.org/2014/data-shapes/track/issues/72">ISSUE-72</a>),
					added sh:ignoredProperties to sh:ClosedShape (<a href="http://www.w3.org/2014/data-shapes/track/issues/58">ISSUE-58</a>),
					editorial improvements to terminology, added Glossary to appendix
				</li>
				<li><b>2015-08-07</b>: Extended the use of sh:severity to template constraints, split sh:source into sh:sourceConstraint and sh:sourceShape, renamed sh:root to sh:focusNode</li>
				<li><b>2015-07-31</b>: Added sh:text as the union of xsd:string and rdf:langString</li>
				<li><b>2015-07-30</b>: Integrated sh:InversePropertyScope and sh:AllObjects</li>
				<li><b>2015-07-24</b>: Added details of XSD-like facets (<a href="http://www.w3.org/2014/data-shapes/track/issues/64">ISSUE-64</a>)</li>
				<li>
					<b>2015-07-17</b>: Rewritten scope and filter mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/62">ISSUE-62</a>),
					suggestion for generalized execution language interface (<a href="http://www.w3.org/2014/data-shapes/track/issues/60">ISSUE-60</a>)
				</li>
				<li><b>2015-07-13</b>: Replaced Appendix with references to SHACL-REF document</li>
				<li><b>2015-07-03</b>: Editorial fixes, started revision history</li>
			</ul>
		</section>
		<section class='introductory'>
		  <h2>Document Outline</h2>
			<p>
				The sections 2 - 5 cover the <span class="term">SHACL Core Profile</span> and may be read independently from the later sections.
			</p>
			<p>
				The sections 6 onwards are about the advanced features of the SHACL language, including templates, functions, and execution semantics.
			</p>
			<p>
				The Appendix provides a <a href="#terms">Glossary of Key Concepts</a> that may also serve as a quick overview of the language.
			</p>
			<p>
				The examples in this document use Turtle [[!turtle]].
				The reader should be familiar with basic RDF concepts [[!rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[!sparql11-overview]].			<p>
			</p>
		</section>
	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				SHACL (Shapes Constraint Language) is a language for describing and constraining RDF graphs. 
				SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF datasets</a>.
				SHACL groups descriptive information and constraints that apply to a given data node into <span class="term">shapes</span>.
				This document defines what it means for an <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graph</a>, referred to as the "data graph", to conform to a graph containing SHACL shapes, referred to as the "shapes graph".
				Conformance can be programmatically checked by processors referred to as SHACL <span class="term">validation engines</span>.
				The process of checking conformance is referred to as <span class="term">validation</span>.
				A shape may include a <span class="term">scope</span> which defines which nodes in the data graph must conform to it.
				When a data node is checked for conformance to a shape, that node is referred to as the <span class="term">focus node</span>.
				The output of the validation process is a <span class="term">validation report</span> which indicates whether or not the data graph conforms to the shapes graph.
				If any constraints are not satisfied, then the validation report will include one or more <span class="term">violations</span> which indicate the source of the problem.
			</p>
			<p>
				For example, SHACL can be used to check whether all the nodes in a data graph that have a type link to <code>foaf:Person</code> have a single value for <code>foaf:mbox</code>, and that that value is an IRI.
				SHACL can also be used to check whether a particular node in a data graph, say the node <code>ex:bug1</code>, has at least one
				value for <code>ex:reportedBy</code> and all such values have an <code>rdf:type</code> link to <code>foaf:Person</code>.
			</p>
			<p>
				The simplest interface to a SHACL processor has two inputs:
			</p>
			<ul>
				<li>A <span class="term">data graph</span> that contains the data that is to be validated</li>
				<li>A <span class="term">shapes graph</span> containing shape definitions and other information that can be utilized to determine what validation is to be done</li>
			</ul>
			<p>
				For example, one might use SHACL to determine whether data graphs that contain information about issues and users conform to the following constraints:
			</p>
			<ul>
				<li>each issue is in either an unassigned or an assigned state, and</li>
				<li>each issue has a reporter and each such reporter has precisely one name (which is a string) and one or more mailboxes (which are IRIs).</li>
			</ul>
			<p>
				A shapes graph that defines these constraints has two shapes.
				The first, <code>ex:IssueShape</code> contains the two constraints on issues.
				The second, <code>ex:UserShape</code>, contains the two constraints on reporters.
				<code>ex:IssueShape</code> contains scope information which in this case says that its constraints apply to all nodes that have an <code>rdf:type</code> link to
				either <code>ex:Issue</code> directly or to a (transitive) subclass of <code>ex:Issue</code> following <code>rdf:subClassOf</code> triples.
			</p>
			<pre class="example" title="Definition of ex:IssueShape and ex:UserShape">
ex:IssueShape
	a sh:Shape ;
	sh:scopeClass ex:Issue;
	sh:property [
		sh:predicate ex:state ;
		sh:in (ex:unassigned ex:assigned) ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:reportedBy ;
		sh:valueShape ex:UserShape ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:UserShape
	a sh:Shape ;
	sh:property [
		sh:predicate foaf:name ;
		sh:datatype xsd:string ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate foaf:mbox ;
		sh:nodeKind sh:IRI ;
		sh:minCount 1 ;
	] .</pre>
			<p>
				The following data graph might be validated against this shapes graph.
			</p>
			<pre class="example" title="Definition of ex:IssueShape and ex:UserShape">
inst:Issue1
	a ex:Issue ;
	ex:state ex:unassigned ;
	ex:reportedBy inst:User2 .

inst:User2
	a foaf:Person ;
	foaf:name "Bob Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .

inst:Issue3
	a ex:Issue ;
	ex:state ex:unsigned ;
	ex:reportedBy inst:User4 .

inst:User4
	a foaf:Person ;
	foaf:name "Bob Smith", "Robert Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .</pre>
			<p>
				The SHACL validation would validate <code>ex:IssueShape</code> against <code>inst:Issue1</code> and <code>inst:Issue3</code>.
				Validating the first node would determine that <code>inst:Issue1</code> satisfies the constraints in <code>ex:IssueShape</code>, along the way determining that <code>inst:User2</code> satisfies the constraints in <code>ex:UserShape</code>.
				Validating the second node would determine that <code>inst:Issue3</code> violates the constraint on values for <code>ex:state</code>, because <code>ex:unsigned</code> is not in the list of allowed values (the correct value is <code>ex:unassigned</code>),
				and also violates the constraint on values for <code>ex:reportedBy</code>, because <code>inst:User4</code> violates the <code>ex:UserShape</code> constraint on the maximum number of values for <code>foaf:name</code>.
			</p>
			
			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS</h3>
				<p>
					SHACL uses RDF and RDFS vocabulary (in particular <code>rdf:type</code>, <code>rdfs:Class</code>, <code>rdfs:subClassOf</code>, <code>rdf:Property</code>, <code>rdf:List</code>,
					<code>rdf:langLiteral</code>, and <code>rdfs:Resource</code>) and notions (notably classes, instances, and subclasses).
					However, SHACL does not always use this vocabulary or these notions in exactly the way that they are formally defined in RDF and RDFS [[!rdf11-mt]].				
				</p>
				<p>
					When determining subclass and instance relationships SHACL only uses the transitive closure of <code>rdfs:subClassOf</code>,
					without requiring in particular the RDF axioms, the RDFS meaning of <code>rdfs:Resource</code>, the reflexivity of <code>rdfs:subClassOf</code>,
					the effect of subproperties of <code>rdfs:subClassOf</code>, and the effects of <code>rdfs:domain</code> and <code>rdfs:range</code>.
				</p>
				<p>
					Note that <code>rdfs:subClassOf</code> transitivity is not uniformly applied throughout SHACL.
					It is only used when SHACL explicitly determines type and subclass relationships in the shapes graph and the data.
					In other places only triples that are explicitly present in the shapes graph or the data are considered.
					For example, SHACL property constraints on <code>rdf:type</code> and <code>rdfs:subClassOf</code> only utilize triples that are explicitly in the data.
					Similarly, subproperties of <code>rdfs:label</code> and <code>rdfs:commment</code> and subclasses of <code>rdf:List</code> are not recognized in the shapes graph.
				</p>
				<p>
					These design decisions mean that SHACL processors do not have to natively support full RDFS inferencing.
					However, SHACL validation engines may operate on RDF graphs that include entailments - either pre-computed before being submitted to a SHACL processor or performed on the fly as part of SHACL processing.
					To support on the fly processing of entailments, SHACL includes the property <a href="#entailment"><code>sh:entailment</code></a> to indicate what kind of inferencing is required by a given shapes graph.
					SHACL implementations may, but are not required to, support entailment regimes.
				</p>
				<p>
					In the remainder of this document, the following terminology is used:
				</p>
				<ul>
					<li>
						<span class="term">subclass</span>, <span class="term">superclass</span>:
						A class <code>Sub</code> is a subclass of another class <code>Super</code>
						if there is a path of asserted <code>rdfs:subClassOf</code> triples from <code>Sub</code> to <code>Super</code>
						equivalent to the SPARQL property path  [[!sparql11-query]] <code>?Sub rdfs:subClassOf+ ?Super</code>.
						The term superclass is referring to the same relationship in reverse order.
					</li>
					<li>
						<span class="term">type</span>: The types of a node are the classes that are linked to the node via
						<code>rdf:type</code> as well as their superclasses as defined above.
					</li>
					<li>
						<span class="term">instance</span>: A node is an instance of a class if one of its
						<span class="term">types</span> (as defined above) is the given class.
					</li>
				</ul>
			</section>
			
			<section id="shacl-sparql">
				<h3>Relationship between SHACL and SPARQL</h3>
				<p>
					This specification uses parts of SPARQL 1.1 in the normative definition of the semantics of the SHACL Core constraints and scopes.
					However, SPARQL is not required for the implementation of the SHACL Core language.
				</p>
				<p>
					SPARQL variables starting with <code>$</code> represent external values that must be injected in the query before execution.
				</p>
				<p>
					In some places, the specification assumes that the provided SPARQL engines are preserving the identity of blank nodes,
					so that repeated invocations of queries consistently identify and communicate the same blank nodes.
				</p>
				<p>
					The definition of some constraints requires or is simplified through access to the shapes graph as a named graph during query execution.
					When needed, this named graph IRI is represented with the variable <code>$shapesGraph</code>.
					Implementations MAY <a href="#sparql-constraints-prebound">prebind</a> the variable <code>$shapesGraph</code> to a named graph IRI that contains the the shapes graph.
				</p>
				<p>
					Some SHACL constraints are defined with the use of the <code>sh:hasShape</code> function, as elaborated in the <a href="#constraints">beginning of section 3</a>.
					SHACL additionally introduces mechanisms to define constraints, scopes and new functions in SPARQL.
					Implementations that cover only the the SHACL Core features are not required to implement these mechanisms or the <code>sh:hasShape</code> function.
				</p>
				<div class="syntaxmenu">
					<p>The button below can be used to show or hide the SPARQL definitions.</p>
					<form>
						<p>
							<input id="hide-sparql" onclick="$('.def-sparql').css('display', 'none'); $('#hide-sparql').css('display', 'none'); $('#show-sparql').css('display', '');" type="button" value="Hide SPARQL Definitions" />
							<input id="show-sparql" onclick="$('.def-sparql').css('display', '');     $('#show-sparql').css('display', 'none'); $('#hide-sparql').css('display', '');" style="display:none" type="button" value="Show SPARQL Definitions" />
						</p>
					</form>
				</div>
			</section>
			
			<section id="namespaces">
				<h3>Namespaces</h3>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
				</table>
				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e. it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g. via <code>owl:imports</code> SHOULD include the <code>#</code>. 
				</p>
			</section>
			
			<section id="conformance">
				<p>
					<span class="todo">TODO: We still need to mark non-normative sections.</span>
				</p>
			</section>
			
		</section>
		
		<div style="padding-top: 30px"> <!-- ALH: really??? -->
			<h1 id="part1" style="font-size: 160%; font-weight: bold">Part 1: Core Features</h1>
		</div>

		<section id="shapes">
			<h2>Shapes</h2>
			<p>
				Shapes are instances of the class <code>sh:Shape</code> and define a group of <span class="term"><a href="#shape-constraints">constraints</a></span> that a set of <span class="term">focus nodes</span> can be validated against.
				The set of focus nodes may be defined explicitly in a shape using <span class="term"><a href="#scopes">scopes</a></span> and <span class="term"><a href="#filterShape">filter shapes</a></span>, or provided by the validation engine as defined in later sections. <!-- DK: TODO: check consistent terminology later-->
				Shape scopes instruct a SHACL validation engine how to select the focus nodes.
				Shapes with scopes MAY additionally provide <span class="term">filter shapes</span>.
				Filter shapes further refine the focus nodes to the ones that conform to a set of filter shapes.

				The following figure provides a workflow of the scoping and filtering process.
				SHACL validation engines MAY alter the order of the depicted steps as long as the returned validation results  are correct.
				<!--DK: TODO check term correct -->

			</p>
			<figure>
				<img src="images/SHACL-Validation-Process.png" />
				<figcaption>Illustration of the scoping and filtering process</figcaption>
			</figure>
			<p>
				<!-- DK: TODO: I think we should move this in a separate validation (sub)section-->
				A SHACL validation engine takes two RDF graphs as input, a <span class="term">shapes graph</span> and a
				<span class="term">data graph</span>, and validates the data graph against the shapes graph as described herein.
				SHACL tools may provide other interfaces, e.g. one that takes an RDF graph in an RDF dataset,
				adds other triples to that graph to produce the data graph, e.g. by using <code>owl:imports</code> triples,
				and/or use triples in that graph to produce the shapes graph, e.g. using <code>sh:shapesGraph</code> triples
				as described later.
				A SHACL validation engine MUST implement all constructs in the core of SHACL (Sections 2, 3, 5).
				A SHACL engine MAY not implement the other parts of SHACL.
			</p>
			<p>
				Note that at validation time, both the shape definitions (represented in the <span class="term">shapes graph</span>)
				and the <span class="term">data graph</span> must remain unchanged, i.e. both graphs at the end
				of the validation must be identical to the graph at the beginning of validation.
			</p>
			<section id="scopes">
				<h3>Scopes</h3>
				<p>
					Scopes define the set of focus nodes for a shape and SHACL provides three scope types:
				</p>
				<ul>
					<li><a href="#scopeNode"><b>Node scopes</b></a> define a specific RDF node as scope.</li>
					<li><a href="#scopeClass"><b>Class-based scopes</b></a> define the scope as the set of all instances of a class.</li><!--TODO: check instance -->
					<li><a href="#scope"><b>General scopes</b></a> define a flexible mechanism to produce arbitrary focus nodes.</li>
				</ul>
				<p>
					When multiple scopes are provided in a shape, the shape scope is the union of all individual scopes.
				</p>
				
				<section id="scopeNode">
					<h4>Node scopes (sh:scopeNode)</h4>
					<p>
						Shapes define node scopes with the <code>sh:scopeNode</code> predicate.
						The value can be an IRI or a Literal that SHOULD exist in the data graph.
						<!-- TODO: do we need SHOULD here? and why is this different that other scopes-->
						<!-- TODO: change examples and visually differentiate the shapes graph from the data graph-->
					</p>
					<pre class="example" title="Scope based on sh:scopeNode">
ex:PersonShape
	a sh:Shape ;
	sh:scopeNode ex:Alice ;
	sh:constraint [
		...
	] .

ex:Alice
	a rdfs:Resource ;
	...</pre>
				</section>
				
				<section id="scopeClass">
					<h4>Class-based Scopes (sh:scopeClass and rdf:type)</h4>
					<p>
						The RDF Schema vocabulary defines various terms to model domains in terms of classes and instances.
						A lot of existing data is already represented this way.
						The property <code>sh:scopeClass</code> can be used to link a <code>sh:Shape</code> with an <code>rdfs:Class</code>.
						The properties <code>rdf:type</code> and <code>rdfs:subClassOf</code> are used to determine which shapes a given node will be validated against.
						The scope includes all instances of the <code>sh:scopeClass</code> and its subclasses, by following <code>rdfs:subClassOf</code> triples.
						To determine class membership, the <code>rdf:type</code> and <code>rdfs:subClassOf</code> triples are queried in the <span class="term">data graph</span>. 
						This pattern is illustrated in the following example.
					</p>
					<pre class="example" title="Scope based on rdf:type and sh:scopeClass">
foaf:Person
	a rdfs:Class .

ex:PersonShape
	a sh:Shape ;
	sh:scopeClass foaf:Person ;
	sh:property [
		sh:predicate foaf:name ;
		sh:minCount 1
	] .

ex:Alice
	rdf:type foaf:Person .</pre>
					<p id="implicit-scopeClass">
						Shapes and classes are independent concepts in SHACL.
						In many applications, classes and shapes are separate resources and are therefore given different IRIs.
						However, some application designers may find it more convenient to tightly couple class and shape information
						and use the same IRI for both.
						In the following example, the IRI <code>ex:Person</code> identifies a resource that is 
						both a class and a shape.
						The <code>sh:scopeClass</code> triple explicitly instructs a SHACL engine to apply the constraints
						of the shape <code>ex:Person</code> to all instances of the class <code>ex:Person</code>.
					</p>
					<pre class="example" title="Sharing of IRIs between classes and shapes">
ex:Person
	a rdfs:Class, sh:Shape ;
	sh:scopeClass ex:Person ;
	sh:property [
		...
	] .

ex:Alice
	rdf:type ex:Person .</pre>
					<p>
						In the case where a shape is also a class, a SHACL processor MUST include all the instances of the class in the scope
						of the shape, exactly as if an explicit <code>sh:scopeClass</code> triple was present.
						An explicit <code>sh:scopeClass</code> triple is not required but MAY be included for clarity.
					</p>
					<p id="definition-of-implicit-scopeClass">
						A SHACL processor MUST recognize a resource <code>X</code> in the shapes graph as a shape if and only if the shapes graph contains 
						a triple <code>X rdf:type S</code> where <code>S</code> is either <code>sh:Shape</code> or <code>S</code> is connected to <code>sh:Shape</code> by a property path from <code>S</code> to <code>sh:Shape</code> in the shapes graph consisting of one or more triples whose predicate is <code>rdfs:subClassOf</code>.
						Similarly, a SHACL processor MUST recognize a resource <code>X</code> in the shapes graph as a class if and only if the shapes graph contains a triple <code>X rdf:type C</code> where <code>C</code> is either <code>rdfs:Class</code> or <code>C</code> is connected to <code>rdfs:Class</code> by a property path from <code>C</code> to <code>rdfs:Class</code> in the shapes graph consisting of one or more triples whose predicate is <code>rdfs:subClassOf</code>. If a SHACL processor recognizes a resource <code>X</code> in the shapes graph as both a shape and a class as defined here then all instances of
						the class <code>X</code> in the data graph MUST be included in the scope of the shape <code>X</code>.
						For the purposes of this definition, a resource <code>R</code> in the data graph is said to be an instance of the resource <code>X</code> if and only if
						the data graph contains a triple <code>R rdf:type X</code> or the data graph contains a triple <code>R rdf:type Y</code>
						and <code>Y</code> is connected to <code>X</code> by a property path from <code>Y</code> to <code>X</code> in the data graph consisting of one or more triples whose
						predicate is <code>rdfs:subClassOf</code>.
					</p>
					<p>
						The following SPARQL query, when run on a shapes graph, illustrates how a SHACL processor MUST recognize all resources 
						<code>X</code> that are both shapes and classes for the purpose of computing class-based scopes.
						The use of SPARQL here is for illustration purposes only.
						A SHACL implementation MAY use any equivalent method.
						
					</p>
				<pre class="algorithm">
SELECT ?X
WHERE {
	?X rdf:type/rdfs:subClassOf* sh:Shape .
	?X rdf:type/rdfs:subClassOf* rdfs:Class .
}</pre>
					<div class="issue" data-number="78" title="Abstract classes">
						The following paragraph about <code>sh:abstract</code> is not yet approved by the WG.
						Options include:
						<ul>
							<li>No support of abstract classes</li>
							<li>Use <code>sh:abstract</code> entirely for documentation purposes</li>
							<li>Use <code>sh:abstract</code> also as a constraint check, possibly producing a warning</li>
						</ul>
					</div>
					<p>
						Classes may be declared to be <span class="term">abstract</span> by
						setting their property <code>sh:abstract</code> to <code>true</code>.
						Abstract classes SHOULD not be instantiated directly, i.e. every instance of an abstract class SHOULD also
						have an <code>rdf:type</code> triple to a non-abstract subclass of the abstract class.
					</p>
				</section>
				
				<section id="scope">
					<h4>General scopes (sh:scope)</h4>
					<p>
						SHACL includes a generic mechanism to select focus nodes.
						A Shape can point to one or more instances of <code>sh:Scope</code> using the <code>sh:scope</code> predicate.
						SHACL includes four built-in scope classes:
						<a href="#PropertyScope">sh:PropertyScope</a>,
						<a href="#InversePropertyScope">sh:InversePropertyScope</a>,
						<a href="#AllSubjectsScope">sh:AllSubjectsScope</a> and
						<a href="#AllObjectsScope">sh:AllObjectsScope</a>
						The full SHACL language defines an additional <a href="#general-scopes">generic scoping mechanism based on SPARQL</a>.
					</p>
					<section id="PropertyScope">
						<h5>Property scopes (sh:PropertyScope)</h5>
						<p>
							The scope class <code>sh:PropertyScope</code> selects all subjects that have at least one value for a given property <code>sh:predicate</code>.
							In the following SPARQL query, the variable <code>$predicate</code> is assumed to be substituted with the given value of <code>sh:predicate</code>.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this $predicate [] .
}</pre>
						</div>
						<p>
							The following example uses <code>sh:PropertyScope</code> to define a constraint	that applies to all resources that have any value for the property <code>ex:property</code>:
						</p>
						<pre class="example" title="Shape with sh:PropertyScope">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:PropertyScope ;
		sh:predicate ex:property ;
	] ;
	sh:constraint [
		...
	] .</pre>
					</section>
					<section id="InversePropertyScope">
						<h5>Inverse property scopes (sh:InversePropertyScope)</h5>
						<p>
							The scope class <code>sh:InversePropertyScope</code> selects all objects that appear in at least one triple with a given property <code>sh:predicate</code>.
							In the following SPARQL query, the variable <code>$predicate</code> is assumed to be substituted with the given value of <code>sh:predicate</code>.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	[] $predicate ?this .
}</pre>
						</div>
					</section>
					<section id="AllSubjectsScope">
						<h5>All subjects scopes (sh:AllSubjectsScope)</h5>
						<p>
							The scope class <code>sh:AllSubjectsScope</code> selects all subjects in the data graph.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this ?anyPredicate [] .
}</pre>
						</div>
						<p>
							The following example uses <code>sh:AllSubjectsScope</code> to define a constraint that shall apply to all subjects in the data graph:
						</p>
						<pre class="example" title="Shape with sh:AllSubjectsScope">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:AllSubjectsScope ;
	] ;
	sh:constraint [
		...
	] .</pre>
					</section>
					<section id="AllObjectsScope">
						<h5>All objects scopes (sh:AllObjectsScope)</h5>
						<p>
							The scope class <code>sh:AllObjectsScope</code> selects all objects in the data graph.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	[] ?anyPredicate ?this .
}</pre>
						</div>
					</section>
				</section>
			</section>
			
			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					Filter shapes can further refine the focus nodes produced by a scope.
					For example, instances of the given class <code>ex:Person</code> that were <code>ex:residentIn</code>
					the country <code>ex:USA</code> may have a different legal drinking age than others.
					In order to support such use cases, SHACL includes the concept of <span class="term">filter shapes</span> that act as pre-conditions that all focus nodes need to fulfill before they are being validated.
					Formally, filter shapes eliminate entries from the collection of focus nodes selected by a shape's scopes, if the focus node produces a validation result with severity <a href="#results-severity"><code>sh:Violation</code></a> or a failure for the given filter shapes.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint only applies to resources that have a certain value for <code>ex:requiredProperty</code>. 
				</p>
				<pre class="example" title="Constraint with a filter shape">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:filterShape [
			a sh:Shape ; # Optional triple
			sh:property [
				sh:predicate ex:requiredProperty ;
				sh:hasValue ex:requiredValue ;
			]
		] ;
	] .

ex:FilteredShapeValidExampleInstance
	ex:someProperty ex:someValue ;
	ex:requiredProperty ex:requiredValue .</pre>
			<p>
				Alternatively, <code>sh:filterShape</code> can be defined for a whole shape, with the meaning
				that the filter applies to all constraints defined by the shape, as shown in the following example.
			</p>
			<pre class="example" title="Shape with a filter shape">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:filterShape [
		sh:property [
			sh:predicate ex:requiredProperty ;
			sh:hasValue ex:requiredValue ;
		]
	] ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
	] .

ex:FilteredShapeValidExampleInstance
	ex:someProperty ex:someValue ;
	ex:requiredProperty ex:requiredValue .</pre>
				<p>
					Filters always contribute to the meaning of a shapes.
					This includes both the computation of scopes and when shapes are directly referenced via <code>sh:valueShape</code>.
					In general, a filter shape acts like the test condition of an <code>IF-THEN</code> statement.
					For example, suppose some optional property has a default value.
					Then a shape might express the constraint that <code>IF</code> the property is present <code>THEN</code> its value must be equal to the default value.
					In this case the filter would test for the presence of the property and the constraint would test that its value was equal to the
					default value.
				</p>
				<p>
					When a SHACL processor validates a focus node against a shape, it begins by validating any filters associated with the shape via 
					<code>sh:filterShape</code>.
					If any of the filters produce a violation then the processor interprets this as indicating that none of the constraints
					of the shape are applicable to the focus node and no violations for the shape are reported.
					Conversely, if none of the filters produce a violation then the processor proceeds to evaluate the constraints and reports any 
					violations produced by them.
				</p>
				<p>
					Similarly, when a SHACL processor validates a focus node against a constraint, it begins by validating any filters
					associated with the constraint via <code>sh:filterShape</code>.
					If any of the filters produce a violation then the processor interprets this as indicating that the constraint
					is not applicable to the focus node and no violations for the constraint are reported.
					Conversely, if none of the filters produce a violation then the processor proceeds to evaluate the constraint and reports any 
					violations produced by it.
				</p>
			</section>
			<section id="shape-constraints">
				<h3>Constraints</h3>
				<p>
					A shape defines a group of constraints.
					SHACL includes a collection of Core constraint types that are covered in the next section.
					Additional types of constraints can be added using the <a href="#template-constraints">extension mechanism</a>.
				</p>
				<p>
					Shapes can be linked to their constraints via the following properties:
				</p>
				<ul>
					<li>
						<code>sh:property</code> links a shape with constraints about a given property of the focus node.
						These constraints are called <a href="#constraints-property"><span class="term">property constraints</span></a>.
					</li>
					<li>
						<code>sh:inverseProperty</code> links a shape with constraints about a given property traversed in the inverse direction of the focus node.
						These constraints are called <a href="#constraints-inverse-property"><span class="term">inverse property constraints</span></a>.
					</li>
					<li>
						<code>sh:constraint</code> link a shape with constraints that do not involve just a single dedicated property.
						SHACL includes several <a href="#constraints-other">built-in constraint types</a> such as logical operators.
					</li>
				</ul>
			</section>
		</section>
		
		<section id="constraints">
			<h2>Core Constraint Types</h2>
			<p>
				The following sections define the constraint types built into the SHACL Core.
				Compliant SHACL validation engines MUST support all of these constraints.
			</p>
			<p>
				The choice of constraint types that are defined by the SHACL Core was made based on
				the requirements collected by the [[shacl-ucr]] document.
				Special attention was paid to the balance between trying to cover as many common use cases as possible
				and keeping the size of the core language under control.
				Not all use cases (such as describing constraints on members of an <code>rdf:List</code>) can be expressed by the Core Vocabulary alone.
				Instead, SHACL provides extension mechanisms, such as SPARQL queries, as described in the second part of this specification.
				It is the expectation of the Working Group that reusable libraries of SHACL extensions will be maintained by third parties.
			</p>
			<p>
				Note that the textual definitions of the constraint types refer to the <a href="#results">Validation Results Vocabulary</a>
				introduced in a later section.
			</p>
			<p>
				The SPARQL definitions in this section assume the following variable bindings:
			</p>
			<ul>
				<li>The value of the variable <code>$this</code> is the current focus node.</li>
				<li>The value of the variable <code>$shapesGraph</code> a named graph IRI that contains the <span class="term">shapes graph</span>.</li>
				<li>The value of the variable <code>$currentShape</code> is the currently evaluated shape.</li>
			</ul>
			<p>
				Each row in the result set of the SPARQL queries in this document represents one <span class="term">validation result</span>.
				The other variables in the SELECT clause are mapped to the details of each <a href="#results">validation result</a>, e.g. <code>?object</code> is mapped to <code>sh:object</code>.
				<span class="todo">(Clarify what exact compliance level is required, e.g. do they need to produce focus nodes)</span>
				If a row in a SPARQL result set produces <code>true</code> as value for the variable <code>?failure</code> then a <span class="term">failure</span> must be reported.
			</p>
			<p>
				The SPARQL definitions in this section also assume the existence of a built-in SPARQL function <code>sh:hasShape</code>, which takes the following arguments:
			</p>
			<table class="term-table">
				<tr>
					<th style="min-width: 200px">Argument</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>$focusNode</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The focus node to validate.</td>
				</tr>
				<tr>
					<td><code>$shape</code></td>
					<td><code>sh:Shape</code></td>
					<td>The shape to validate the focus node against.</td>
				</tr>
				<tr>
					<td><code>$shapesGraph</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The current <span class="term">shapes graph</span>.</td>
				</tr>
				<tr>
					<td><code>$recursionIsError</code></td>
					<td><code>xsd:boolean</code></td>
					<td>
						If set to <code>true</code> then any recursive occurrence of the same resource against the same shape signals a failure,
						with the function returning <span class="term">undefined</span>.
						If not <code>true</code> then any recursive occurrence must return <code>true</code>.
						<p class="issue" data-number="22" title="Treatment of recursive shape definitions">
							According to resolution <a href="https://www.w3.org/2015/12/16-shapes-minutes.html#resolution04">2015.12.16/04</a> shapes graphs with dependency loops are invalid and suitable limitations of this will be explored.
							Until  issue 22 is closed, definitions regarding recursion are not endorsed by the WG.
						</p>
					</td>
				</tr>
			</table>
			<p>
				The result of the <code>sh:hasShape</code> function is either <code>true</code>, <code>false</code> or <span class="term">undefined</span>.
				The function returns <code>true</code> if the validation of the <code>?focusNode</code> against the given <code>?shape</code> produces no validation results with severity <code>sh:Violation</code>.
				Note that any validation results produced inside of the <code>sh:hasShape</code> function are temporary, i.e. they are not added to the results graph of the surrounding execution environment.
				However, some implementations may add those nested validation results as annotations to the surrounding validation results, via <a href="#results-detail"><code>sh:detail</code></a>.
			</p>

			<section id="constraints-property">
				<h3>Property Constraints (sh:property)</h3>
				<p>
					A <span class="term">property constraint</span> is a constraint that defines restrictions on the values of a given property in the context of the focus node.
					Here, the focus node is the <span class="term">subject</span> and the property is the <span class="term">predicate</span> of relevant triples.
					The property <code>sh:property</code> can be used to link a shape with its property constraints.
				</p>
				<p>
					In SHACL, property constraints are instances of the class <code>sh:PropertyConstraint</code>.
					When used as values of <code>sh:property</code>, property constraints do not require an <code>rdf:type</code> triple.
					However, if those values are IRIs, then they SHOULD have an <code>rdf:type</code> triple.
					Note that <code>sh:property</code> may also have values that are sub-classes of <code>sh:PropertyConstraint</code>,
					but in this case the <code>rdf:type</code> triple is required.
					It is not valid to use <code>sh:property</code> for constraints that are not instance of <code>sh:PropertyConstraint</code>.
				</p>
				<p> 
					The following examples illustrate two ways of using property constraints.
					The first example uses a blank node:
				</p>
				<pre class="example" title="Property constraint represented by a blank node">
ex:InlinePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:name "some property" ;
		sh:description "Description of the role of ex:someProperty (in the context of the constraint)" ;
		sh:minCount 1 ;
		sh:class ex:SomeClass ;
	] .</pre>
				<p>
					The second example defines a constraint as an IRI node, allowing it to be more easily referenced and shared across multiple shapes:
				</p>
				<pre class="example" title="Property constraint represented by a IRI">
ex:StandAlonePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property ex:StandAloneConstraint .

ex:StandAloneConstraint
	a sh:PropertyConstraint ;
	sh:predicate ex:someProperty ;
	sh:defaultValue ex:SomeInstance ;
	sh:minCount 1 ;
	sh:class ex:SomeClass .</pre>
				<p>
					The following sections provide details on the properties that may be used with <code>sh:PropertyConstraint</code>.
					None of these properties can be repeated within the same <code>sh:PropertyConstraint</code>.
					In order to define multiple constraints using the same predicate, such as multiple <code>sh:hasValue</code> constraints, the shape must use multiple <code>sh:property</code> definitions.
				</p>
				<p class="todo">
					Note that this chapter is work in progress to implement the resolution to ISSUE-98.
					In a nutshell, these constraint types can be used either at sh:constraint (to apply to the focus node itself),
					at sh:property (to apply to all values of a given property), or at sh:inverseProperty (to apply to all inverse values of a given property).
					Which combinations are supported is summarized in the following table.
					The flow of the sub-sections needs to be adjusted and generalized accordingly.
				</p>
				<table class="term-table">
					<tr>
						<th>Properties</th>
						<th>sh:constraint</th>
						<th>sh:property</th>
						<th>sh:inverseProperty</th>
						<th>Summary</th>
					</tr>
					<tr>
						<td>
							<a href="#AbstractClassPropertyConstraint"><code>sh:class</code></a>,
							<a href="#classIn"><code>sh:classIn</code></a> and
							<a href="#AbstractDirectTypePropertyConstraint"><code>sh:directType</code></a>
						</td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>Type, based on <code>rdf:type</code></td>
					</tr>
					<tr>
						<td>
							<a href="#AbstractDatatypePropertyConstraint"><code>sh:datatype</code></a> and
							<a href="#datatypeIn"><code>sh:datatypeIn</code></a>
						</td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td></td>
						<td>Datatype, for literals</td>
					</tr>
					<tr>
						<td><a href="#equals"><code>sh:equals</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td></td>
						<td>Property with equal values</td>
					</tr>
					<tr>
						<td><a href="#AbstractHasValuePropertyConstraint"><code>sh:hasValue</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>A specific required value</td>
					</tr>
					<tr>
						<td><a href="#AbstractInPropertyConstraint"><code>sh:in</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>Enumeration of allowed values</td>
					</tr>
					<tr>
						<td><a href="#lessThan"><code>sh:lessThan</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td></td>
						<td>Must have lesser values than another property</td>
					</tr>
					<tr>
						<td><a href="#lessThan"><code>sh:lessThanOrEquals</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td></td>
						<td>Must have lesser or equal values than another property</td>
					</tr>
					<tr>
						<td><a href="#AbstractCountPropertyConstraint"><code>sh:minCount</code>, <code>sh:maxCount</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>Minimum and maximum cardinality</td>
					</tr>
					<tr>
						<td><a href="#AbstractLengthPropertyConstraint"><code>sh:minLength</code>, <code>sh:maxLength</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td></td>
						<td>Minimum and maximum string length</td>
					</tr>
					<tr>
						<td><a href="#AbstractMaxExclusivePropertyConstraint"><code>sh:maxExclusive</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td></td>
						<td>Maximum exclusive value (&gt;)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMaxInclusivePropertyConstraint"><code>sh:maxInclusive</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td></td>
						<td>Maximum inclusive value (&gt;=)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMinExclusivePropertyConstraint"><code>sh:minExclusive</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td></td>
						<td>Minimum exclusive value (&lt;)</td>
					</tr>
					<tr>
						<td><a href="#AbstractMinInclusivePropertyConstraint"><code>sh:minInclusive</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td></td>
						<td>Minimum inclusive value (&lt;=)</td>
					</tr>
					<tr>
						<td><a href="#AbstractNodeKindPropertyConstraint"><code>sh:nodeKind</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>Node kind (IRI, blank node, or literal) of all values</td>
					</tr>
					<tr>
						<td><a href="#notEquals"><code>sh:notEquals</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td></td>
						<td>Property with unequal values</td>
					</tr>
					<tr>
						<td><a href="#AbstractPatternPropertyConstraint"><code>sh:pattern</code></a></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td></td>
						<td>Regular expression string matching</td>
					</tr>
					<tr>
						<td><a href="#AbstractUniqueLangPropertyConstraint"><code>sh:uniqueLang</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td></td>
						<td>No duplicate language tags</td>
					</tr>
					<tr>
						<td><a href="#AbstractValueShapePropertyConstraint"><code>sh:valueShape</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>Nested shape of all values</td>
					</tr>
					<tr>
						<td><a href="#AbstractQualifiedValueShapePropertyConstraint"><code>sh:qualifiedValueShape</code>, <code>sh:qualifiedMinCount</code>, <code>sh:qualifiedMaxCount</code></a></td>
						<td></td>
						<td>&#9745;</td>
						<td>&#9745;</td>
						<td>Nested shape of a given minimum/maximum number of values</td>
					</tr>
				</table>
				<section id="AbstractClassPropertyConstraint">
					<h4>sh:class</h4>
					<p>
						The property <code>sh:class</code> can be used to verify that each value of the given property is an instance of a given type. 
						The main difference with <a href="#AbstractDirectTypePropertyConstraint"><code>sh:directType</code></a> is that <code>sh:class</code> also includes subclasses of the type.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:class</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if it has an <code>rdf:type</code> value that is the type or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code>.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* $class } .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:class constraint">
ex:ClassExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:class ex:ClassA ;
	] .
	
ex:InstanceOfClassA
	a ex:ClassA .

ex:ClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA .</pre>
				</section>
				<section id="classIn">
					<h4>sh:classIn</h4>
					<p>
						The property <code>sh:classIn</code> can be used to verify that each value of the given property is an instance of a type from a given list. 
						The values of <code>sh:classIn</code> must be lists of resources.
						<code>sh:classIn</code> is a generalization of <code>sh:class</code> allowing users to state that the values must have one out of several types.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:classIn</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>List of types of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if it has an <code>rdf:type</code> value that is one of the types from the list or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code>.
							Each type from the list is tested using the same logic as <code>sh:class</code>.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isLiteral(?value) || NOT EXISTS {
			GRAPH $shapesGraph {
				$classIn (rdf:rest*)/rdf:first ?class .
			}
			FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* ?class }
		})
}</pre>
					</div>
					<pre class="example" title="Shape with sh:classIn constraint">
ex:ClassInExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:classIn ( ex:ClassA ex:ClassB ) ;
	] .
	
ex:InstanceOfClassA
	a ex:ClassA .
	
ex:InstanceOfClassB
	a ex:ClassB .

ex:ClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA ;
	ex:someProperty ex:InstanceOfClassB .</pre>
				</section>
				<section id="AbstractDatatypePropertyConstraint">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all values of the given property.
						The values of <code>sh:datatype</code> must be resources representing datatypes, such as <code>xsd:string</code>.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Datatype of all values (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is not a literal, or is a literal with a mismatching datatype.
							A literal matches a datatype if the literal's datatype has the same IRI.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		{
			FILTER isLiteral(?value) .
		} .
		BIND (datatype(?value) AS ?valueDatatype) .
		FILTER (?valueDatatype = $datatype) .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:datatype constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatype xsd:string ;
	] .

ex:DatatypeShapeExampleValidResource
	ex:someProperty "Some value" .

ex:DatatypeShapeExampleInvalidResource
	ex:someProperty "Value with language tag"@en ;
	ex:someProperty 42 .</pre>
				</section>
				<section id="datatypeIn">
					<h4>sh:datatypeIn</h4>
					<p>
						The property <code>sh:datatypeIn</code> can be used to restrict the datatype of all values of the given property.
						The values of <code>sh:datatypeIn</code> must be lists of resources representing datatypes, such as <code>xsd:string</code>.
						<code>sh:datatypeIn</code> is a generalization of <code>sh:datatype</code> allowing users to state that the values must have one out of several datatypes.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>Allowed datatypes of all values (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object is not a literal, or is a literal with a mismatching datatype.
							A literal matches if the literal's datatype is member of the provided datatypes list.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isLiteral(?value) || NOT EXISTS {
			GRAPH $shapesGraph {
				$datatypeIn (rdf:rest*)/rdf:first ?datatype .
			} 
			BIND (datatype(?value) AS ?valueDatatype) .
			FILTER (?valueDatatype = $datatype) .
		})
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:datatypeIn constraint">
ex:DatatypeInExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatypeIn ( xsd:string rdf:langString ) ;
	] .

ex:DatatypeInShapeExampleValidResource
	ex:someProperty "Value with language tag"@en ;
	ex:someProperty "Some string value" .

ex:DatatypeInShapeExampleInvalidResource
	ex:someProperty 42 .</pre>
				</section>
				<section id="AbstractDirectTypePropertyConstraint">
					<h4>sh:directType</h4>
					<p>
						The property <code>sh:directType</code> can be used to restrict the <code>rdf:type</code> of all values of the given property.
						The main difference with <a href="#AbstractClassPropertyConstraint"><code>sh:class</code></a> is that <code>sh:directType</code> does not include subclasses of the type.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:directType</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not have an <code>rdf:type</code> triple with the given value type as object.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		?value a $directType .
	}
}</pre>
					</div>
				</section>
				<section id="equals">
					<h3>sh:equals</h3>
					<p>
						<code>sh:equals</code> constrains a pair of properties so that the value sets of both properties at a given focus node must be equal.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:equals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Property to compare with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced
							for each value of <code>sh:predicate</code> that does not exist as value of <code>sh:equals</code> and
							for each value of <code>sh:equals</code> that does not exist as value of <code>sh:predicate</code>
							at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the corresponding values of the existing triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	{
		$this $predicate ?object .
		FILTER NOT EXISTS {
			$this $equals ?object .
		}
	}
	UNION
	{
		$this $equals ?object .
		FILTER NOT EXISTS {
			$this $predicate ?object .
		}
	}
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:equals</code> in a shape to verify
						that certain nodes must have the same value sets for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<pre class="example" title="Shape with an sh:equals constraint">
ex:EqualExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:equals ex:givenName ;
	] .

ex:ValidInstance1
	ex:firstName "John" ;
	ex:givenName "John" .</pre>
				</section>
				<section id="AbstractHasValuePropertyConstraint">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify
						that the <span class="term">focus node</span> has a given RDF node among the values of the given
						predicate.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>any</td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if there is no triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and the <code>sh:hasValue</code> as its object.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	FILTER NOT EXISTS {
		$this $predicate $hasValue .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:hasValue constraint">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .

ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
				</section>
				<section id="AbstractInPropertyConstraint">
					<h4>sh:in</h4>
					<p>
						The property <code>sh:in</code> exclusively enumerates the values that a property may have.
						When specified, each value of the given property must be a member of the specified list.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:in</code></td>
							<td><code>rdf:List</code></td>
							<td>Enumeration of allowed values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:in</code> must be well-formed instances of <code>rdf:List</code>.
							The members of that <code>rdf:List</code> must not be blank nodes.
							A <span class="term">validation result</span> must be produced for every triple that has the <span class="term">focus node</span> as its subject,
							the <code>sh:predicate</code> as its predicate and an object that is not a member of the given list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
							Each produced <span class="term">result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective invalid value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		GRAPH $shapesGraph {
			$in (rdf:rest*)/rdf:first ?value .
		}
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:in constraint">
ex:AllowedValuesExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:in ( ex:Value1 ex:Value2 ex:Value3 ) ;
	] .

ex:InExampleValidResource
	ex:someProperty ex:Value2 .</pre>
				</section>
				<section id="lessThan">
					<h3>sh:lessThan</h3>
					<p>
						<code>sh:lessThan</code> constrains a pair of properties so that the values of the first property must be smaller than the values of the second property at a given focus node.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThan</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate</code>
							and <code>sh:lessThan</code> at the given <span class="term">focus node</span>, where
							the first value is not less than the second value, based on SPARQL's <code>&lt;</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value of <code>sh:predicate</code> as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThan ?object2 .
	FILTER (!(?object &lt; ?object2)) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:lessThan</code> in a shape to verify
						that all values of <code>ex:startDate</code> must "before" the values of <code>ex:endDate</code>.
					</p>
					<pre class="example" title="Shape with an sh:lessThan constraint">
ex:LessThanExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:startDate ;
		sh:lessThan ex:endDate ;
	] .</pre>
				</section>
				<section id="LessThanOrEqualConstraint">
					<h3>sh:lessThanOrEquals</h3>
					<p>
						<code>sh:lessThanOrEquals</code> constrains a pair of properties so that the values of the first property must be smaller than or equal to the values of the second property at a given focus node.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThanOrEquals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate</code>
							and <code>sh:lessThanOrEquals</code> at the given <span class="term">focus node</span>, where
							the first value is not less than or equal to the second value, based on SPARQL's <code>&lt;=</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value of the first predicate as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThanOrEquals ?object2 .
	FILTER (!(?object &lt;= ?object2)) .
}</pre>
					</div>
				</section>
				<section id="AbstractCountPropertyConstraint">
					<h4>sh:minCount, sh:maxCount</h4>
					<p>
						The properties <code>sh:minCount</code> and <code>sh:maxCount</code>
						restrict the number of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>. 
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum cardinality. If the value is 0 then this constraint is always satisfied and so may be omitted.</td>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum cardinality. If this constraint is omitted then there is no limit on the number of triples.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:minCount</div>
						<div class="def-text-body">
							Let <code>?count</code> be the number of triples that have the <span class="term">focus node</span> as
							the <span class="term">subject</span> and the value of <code>sh:predicate</code> as the <span class="term">predicate</span>.
							A <span class="term">validation result</span> must be produced
							if <code>?count</code> is less than the value of <code>sh:minCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the predicate as its <code>sh:predicate</code>. 
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:minCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &lt; $minCount)
}</pre>
					</div>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:maxCount</div>
						<div class="def-text-body">
							Let <code>?count</code> be the number of triples that have the <span class="term">focus node</span> as
							the <span class="term">subject</span> and the value of <code>sh:predicate</code> as the <span class="term">predicate</span>.
							A <span class="term">validation result</span> must be produced 
							if <code>?count</code> is greater than the value of <code>sh:maxCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the predicate as its <code>sh:predicate</code>. 
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:maxCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &gt; $maxCount))
}</pre>
					</div>
					<pre class="example" title="Shape with sh:minCount and sh:maxCount constraints">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
				<section id="AbstractLengthPropertyConstraint">
					<h4>sh:minLength, sh:maxLength</h4>
					<p>
						The properties <code>sh:minLength</code> and <code>sh:maxLength</code>
						restrict the string length of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						This can be applied to any type of literal and IRIs, but not for blank nodes.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum length. If the value is 0 then there is no restriction on the string length but this constraint is still violated if the node is a blank node.</td>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum length. If this constraint is omitted then there is no restriction on the string length and no requirement that the node is a literal or IRI.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:minLength</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the length of the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							of the object is less than the specified minimum length, or if the object is a blank node.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:minLength</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &lt; $minLength) .
}</pre>
					</div>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:maxLength</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the length of the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							of the object is either more than the specified maximum length, or if the object is a blank node.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:maxLength</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &gt; $maxLength) .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:minLength and sh:maxLength constraints">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
		rdfs:comment "Password must be between 8 and 10 characters long" ;
	] .

ex:PasswordExampleValidResource
	ex:password "password" .</pre>
				</section>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						The supported datatypes of these properties are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="AbstractMinExclusivePropertyConstraint">
							<td><code>sh:minExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code></td>
						</tr>
						<tr id="AbstractMinInclusivePropertyConstraint">
							<td><code>sh:minInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code></td>
						</tr>
						<tr id="AbstractMaxExclusivePropertyConstraint">
							<td><code>sh:maxExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code></td>
						</tr>
						<tr id="AbstractMaxInclusivePropertyConstraint">
							<td><code>sh:maxInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <span class="term">validation result</span> must also be produced if the object cannot be compared to the specified range.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the validation engine will produce a validation result.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<p>
						The following SPARQL definition covers <code>sh:minExclusive</code> - the other variations can be derived by replacing the <code>&gt;</code> operator.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!($value &gt; $minExclusive)) .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:minInclusive and sh:maxInclusive constraints">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minInclusive 1 ;
		sh:maxInclusive 10 ;
	] .

ex:NumericExampleValidResource
	ex:someProperty 7 .

ex:NumericExampleInvalidResource1
	ex:someProperty 11 .

ex:NumericExampleInvalidResource2
	ex:someProperty "a string" .</pre>
				</section>
				<section id="AbstractNodeKindPropertyConstraint">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> can be used to restrict the RDF node kind of all values of the given property.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td><code>sh:NodeKind</code></td>
							<td>Node kind (IRI, blank node, or literal) of all values</td>
						</tr>
					</table>
					<p>
						The values of <code>sh:nodeKind</code> must be instances of the class <code>sh:NodeKind</code>.
						The SHACL system vocabulary defines that <code>sh:NodeKind</code> has exactly 3 instances:
						<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code>.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the object does not match the given node kind.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		FILTER ((isIRI(?value) &amp;&amp; $nodeKind = sh:IRI) ||
			(isLiteral(?value) &amp;&amp; $nodeKind = sh:Literal) ||
			(isBlank(?value) &amp;&amp; $nodeKind = sh:BlankNode)) .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:nodeKind constraint">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:nodeKind ex:IRI ;
	] .

ex:NodeKindShapeExampleValidResource
	ex:someProperty ex:SomeIRI .

ex:NodeKindShapeExampleInvalidResource
	ex:someProperty ex:SomeIRI ;
	ex:someProperty "A literal" .</pre>
				</section>
				<section id="notEquals">
					<h3>sh:notEquals</h3>
					<p>
						<code>sh:notEquals</code> constrains a pair of properties so that the value sets of both properties at a given focus node must not share any values.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each value of <code>sh:predicate</code>
							that also exists as value of <code>sh:notEquals</code> at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $notEquals ?object .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:notEquals</code> in a shape to verify
						that certain nodes must not share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<pre class="example" title="Shape with an sh:notEquals constraint">
ex:NotEqualsExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:notEquals ex:altLabel ;
	] .

ex:ValidInstance1
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

ex:InvalidInstance1
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .</pre>
				</section>
				<section id="AbstractPatternPropertyConstraint">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to validate whether all values of the given property match a given regular expression.
						The values of <code>sh:pattern</code> must be valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td><code>xsd:string</code></td>
							<td>Regular expression that all values must match</td>
						</tr>
						<tr>
							<td><code>sh:flags</code></td>
							<td><code>xsd:string</code> (optional)</td>
							<td>An optional string of flags, interpreted as in <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL 1.1 REGEX</a></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							of the object does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							If <code>sh:flags</code> is present then this must be interpreted according to the SPARQL REGEX function. 
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || IF(bound($flags), !regex(str(?value), $pattern, $flags), !regex(str(?value), $pattern))) .
}</pre>
					</div>
					<pre class="example" title="Shape with sh:pattern constraint">
ex:PatternExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:pattern "^Ali" ;
		sh:flags "i" ;       # Ignore case
	] .

ex:PatternShapeExampleValidResource
	ex:someProperty "alice" .

ex:PatternShapeExampleInvalidResource
	ex:someProperty "The Alice" .</pre>
				</section>
				<section id="AbstractUniqueLangPropertyConstraint">
					<h4>sh:uniqueLang</h4>
					<p>
						The property <code>sh:uniqueLang</code> can be set to <code>true</code> to specify that no pair of values of the given property may use the same language tag.
						The values of <code>sh:uniqueLang</code> must be <code>xsd:boolean</code>.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:uniqueLang</code></td>
							<td><code>xsd:boolean</code></td>
							<td><code>true</code> to activate this constraint</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:uniqueLang</code> is set to <code>true</code> then a <span class="term">validation result</span> must be produced for each non-empty language tag that is
							used by at least two triples that have the <span class="term">focus node</span> as their subject and the <code>sh:predicate</code> as their predicate.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ($this AS ?subject) $predicate
WHERE {
	{
		FILTER ($uniqueLang) .
	}
	$this $predicate ?value .
	BIND (lang(?value) AS ?lang) .
	FILTER (bound(?lang) &amp;&amp; ?lang != "") . 
	FILTER EXISTS {
		$this $predicate ?otherValue .
		FILTER (?otherValue != ?value &amp;&amp; ?lang = lang(?otherValue)) .
	}
}</pre>
					</div>
					<pre class="example" title="Shape with sh:pattern constraint">
ex:UniqueLangExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:uniqueLang true ;
	] .

ex:UniqueLangShapeExampleValidResource
	ex:someProperty "Me" ;
	ex:someProperty "Me"@en ;
	ex:someProperty "Moi"@fr .

ex:UniqueLangShapeExampleInvalidResource
	ex:someProperty "Me"@en ;
	ex:someProperty "Myself"@en .</pre>
				</section>
				<section id="AbstractValueShapePropertyConstraint">
					<h4>sh:valueShape</h4>
					<p>
						The property <code>sh:valueShape</code> can be used verify that all values of the given property must have a given shape.
						The value type of <code>sh:valueShape</code> is <code>sh:Shape</code>, but the <code>rdf:type</code> triple of those shapes can be omitted.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:valueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each triple that has
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:valueShape</code> 
							produces any validation results with severity <code>sh:Violation</code> or a failure.
							Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object ?failure
WHERE {
	$this $predicate ?object .
	BIND (sh:hasShape(?object, $valueShape, $shapesGraph, false) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || !?hasShape) .
}</pre>
					</div>
					<p class="issue" data-number="22" title="Treatment of recursive shape definitions">
						According to resolution <a href="https://www.w3.org/2015/12/16-shapes-minutes.html#resolution04">2015.12.16/04</a> shapes graphs with dependency loops are invalid and suitable limitations of this will be explored.
						Until  issue 22 is closed, definitions regarding recursion are not endorsed by the WG.
					</p>
					<p>
						A shape may refer to itself directly or indirectly via <code>sh:valueShape</code>, <code>sh:filterShape</code>, etc.
						Such a shape is said to be <em>recursive</em>.
						The meaning of non-recursive shapes is always well-founded.
						In contrast, the meaning of a recursive shape may not be well-founded.
						As a starting point, the SHACL specification only defines the meaning of non-recursive shapes.
						However, there are use-cases where recursion is valuable, either for its inherent expressive power or because it makes the
						intension of shapes clearer.
						The Working Group will therefore explore conditions under which recursive shapes can be assigned a well-defined meaning and will
						relax the restrictions on recursion accordingly. 
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> will validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example" title="Shape with sh:valueShape constraint">
ex:ValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueShape [
			a sh:Shape ;   # Optional
			sh:predicate [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .

ex:ValueShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				<section id="AbstractQualifiedValueShapePropertyConstraint">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<div class="issue" data-number="92" title="Relationship of QCRs with Partitions">
						Feature at risk:
						There is an ongoing proposal (see sh:partition) that strongly overlaps with the QCRs proposed here.
						The WG may decide to support only one of these options, but not both.
					</div>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a certain number  of values of the given property must have a given shape.
						The value type of <code>sh:qualifiedValueShape</code> is <code>sh:Shape</code>, and it needs to be accompanied by
						a <code>sh:qualifiedMinCount</code> or a <code>sh:qualifiedMaxCount</code> (both typed <code>xsd:integer</code>), or both.
						The <code>rdf:type</code> of the value shapes can be omitted.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of the specified values</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum number of values that must have the shape. If this constraint is omitted then there is no minimum number of values required. </td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum number of values that can have the shape. If this constraint is omitted then there is no maximum number of values required.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMinCount</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of triples that have
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no validation results with severity <code>sh:Violation</code> or a failure is less than
							<code>sh:qualifiedMinCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMinCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph, true) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &lt; $qualifiedMinCount) .
}</pre>
					</div>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMaxCount</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of triples that have
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no validation results with severity <code>sh:Violation</code> or a failure is greater than
							<code>sh:qualifiedMaxCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMaxCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph, true) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; $qualifiedMaxCount) .
}</pre>
					</div>
					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example" title="Shape with sh:qualifiedValueShape constraint">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .

ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>

				<section id="PartitionConstraint">
					<h4>sh:partition</h4>
					<div class="issue" data-number="92" title="Under Development">
						This section is one proposal to resolve ISSUE-92.
					</div>
					<p>
						In some cases a given property may be multi-valued and it may be required that the set of values
						be partitioned into two or more subsets, each of which satisfies certain constraints.
					</p>
					<p>
						For example, suppose that in the Library of Congress BIBFRAME (<code>bf:</code>) Cultural Heritage vocabulary each person (<code>bf:Person</code>) must be identified by 
						(<code>bf:identifiedBy</code>) exactly one identifier from <code>id.loc.gov</code> and may have another identifier
						from <code>viaf.org</code>. No other identifiers are allowed. Thus the set of all identifiers is partitioned into
						two subsets, the first of which contains exactly one member and the second of which contains zero or one members.
						The following example shows a snippet of some valid BIBFRAME data.
					</p>
					<pre class="example" title="Valid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> .</pre>
					<p>
						The following example shows a snippet of some invalid BIBFRAME data.
					</p>
					<pre class="example" title="Invalid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> ;
	bf:identifiedBy "this is a mistake" . # should be an error</pre>
					<p>
						Qualified cardinality constraints provide a basis for expressing this type of partitioning requirement, but using them imposes a burden on the shapes author. In the BIBFRAME example the author would need to express the requirement that the set of all identifiers that are from neither <code>id.loc.gov</code> nor <code>viaf.org</code> is empty, i.e. it has a maximum cardinality of 0. Clearly, as more subsets of values are involved, the burden on the author increases.
						The <code>sh:partition</code> constraint makes it easier to express this type of requirement than it would be to use 
						multiple qualified cardinality constraints.
						In effect, <code>sh:partition</code> chains together a sequence of qualified cardinality constraints and removes the set of context nodes matched by each from further consideration. If every context node gets matched in this process, then
						the <code>sh:partition</code> constraint reports no violations. Otherwise, any context nodes remaining are reported as
						violations of the constraint.
						The BIBFRAME example constraint is expressed as follows.
					</p>
					<pre class="example" title="BIBFRAME constraint expressed using sh:partition">ex:BibframeShape a sh:Shape ;
sh:property [
	sh:predicate bf:identifiedBy ;
	sh:partition (
		[sh:minCount 1; sh:maxCount 1; sh:pattern "^http://id.loc.gov/"]
		[sh:maxCount 1; sh:pattern "^https://viaf.org/"]
	)
] .</pre>
					<p>
						The value of the <code>sh:partition</code> constraint parameter MUST be an <code>rdf:List</code> that contains zero or more resources. 
						Each resource in the list defines conditions on a subset of the context nodes and MAY contain the following parameters:
					</p>
					<ul>
						<li>zero or one <code>sh:minCount</code>. This defines the minimum cardinality of the corresponding subset.</li>
						<li>zero or one <code>sh:maxCount</code>. This defines the maximum cardinality of the corresponding subset.</li>
						<li>any combination of parameters associated with node validation constraints. A node validation constraint
							is any constraint defined by a boolean function on nodes. 
							These include the built-in constraints defined by <code>sh:nodeKind</code>, <code>sh:partition</code>,
							<code>sh:minExclusive</code>, etc.
							The corresponding subset consists of those remaining nodes for which the boolean function is <code>true</code>.</li>
					</ul>
					<p>
						Note that a resource that contains no parameters matches all nodes. Such a resource is useful as the last member of the list where it acts as a default matching rule in the case where nodes that do not match any of the preceeding constraints are allowed. 
						Note also that a qualified cardinality constraint defined using <code>sh:qualifiedValueShape</code>,
						<code>sh:qualifiedMinCount</code>, and <code>sh:qualifiedMaxCount</code> is equivalent to a <code>sh:partition</code> constraint that contains two resources with the first one containing the corresponding parameters and the last one being the default matching rule that matches any set of nodes.
					</p>
					<p>
						Each member of the list is used by the SHACL processor to match a subset of the context nodes.
						The SHACL processor matches as many nodes as possible and then compares the result with the specified
						minimum and maximum cardinalities if specified. This is referred to as a <em>greedy</em> matching algorithm.
						Greedy pattern matching is commonly used with textual regular expressions.
						Nodes that match are removed from further matching. Thus the set of all context nodes becomes partitioned by 
						the matching algorithm. The following paragraphs define this algorithm more precisely.
					</p>
					<p>
						Let D be a data graph and let F be a focus node in D. Let S be a shapes graph, let T be a shape in S, 
						and let C be a <code>sh:partition</code> constraint in T. 
						Let N be the set of context nodes for C in D at F. Recall that N depends on how C is related to T. 
					</p>
					<ul>
						<li>If (T, <code>sh:constraint</code>, C) is in S then N consists of just the node F.</li>
						<li>If (T, <code>sh:property</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (F, P, X) is in D.</li>
						<li>If (T, <code>sh:inverseProperty</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (X, P, F) is in D.</li>
					</ul>
					<p>
						Let the value of the <code>sh:partition</code> parameter be the list (Q<sub>1</sub>, ..., Q<sub>n</sub>) of resources.
						The SHACL validator MUST perform the following steps to validate the constraint C at F.
					</p>
					<ol>
						<li>Let R denote the set of remaining context nodes. Initialize R to N.</li>
						<li>Repeat the following for Q = Q<sub>1</sub>, ..., Q<sub>n</sub>
						<ol>
							<li>Let P be the conjunction of all the node validation constraints in Q.</li>
							<li>Compute R' to be the set of all nodes in R that satisfy P, i.e. R' = {X in R | P(X) = true}</li>
							<li>If Q contains a minimum cardinality m<sub>min</sub> and the number of nodes in R' is less than m<sub>min</sub>,
							i.e. m<sub>min</sub> > #R', then report a constraint violation and exit the loop.</li>
							<li>If Q contains a maximum cardinality m<sub>max</sub> and the number of nodes in R' is greater then m<sub>max</sub>,
							i.e. m<sub>max</sub> &lt; #R', then report a constraint violation and exit the loop.</li>
							<li>Remove R' from R, i.e. set R = R \ R'.</li>
						</ol>
						</li>
						<li>If R is non-empty and no violations have been reported yet then report a violation.</li>
					</ol>
					<p>
						Note that the order of resources within the list is significant. 
						In general, if the members of the list are reordered then different context node sets will be matched
						and different violation results will be reported.
					</p>
				</section>
				
				<section id="nonValidation">
					<h4>Non-Validating Constraint Characteristics</h4>
					<p>
						While the previous sections introduced properties that represent validation conditions,
						this section covers properties that are ignored by SHACL validation engines.
						The use of these properties is entirely optional and not subject to formal interpretation contracts.
						They may be used for purposes such as form building, predictable printing of RDF files, etc.
					</p>
					<p id="name">
						Property constraints may have one or more values for <code>sh:name</code> to provide human-readable labels for the property in the scope where it appears.
						If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
						For example, if a form displays a resource that is in the scope of a given shape, and the shape defines a <code>sh:property</code> constraint with an <code>sh:name</code>, then the tool SHOULD use the provided name.
						Similarly, property constraints may have an <code>sh:description</code> to provide a description of the property in the given context.
						Both <code>sh:name</code> and <code>sh:description</code> may have multiple values, but SHOULD only have one value per language tag.
					</p>
					<p id="order">
						Property constraints may have one value for the property <code>sh:order</code> to indicate the relative order of the property constraint for purposes such as form building.
						The values of <code>sh:order</code> must be decimals.
						<code>sh:order</code> is not used for validation purposes.
						If present, the recommended use of <code>sh:order</code> is to sort the property constraints in an ascending order, for example so that
						properties with smaller order are placed above (or to the left) of properties with larger order.
					</p>
					<p id="group">
						Property constraints may link to an instance of the class <code>sh:PropertyGroup</code> using the property <code>sh:group</code> to indicate that
						the constraint belongs to a group of related property constraints.
						Each group may have additional triples that serve application purposes, such as an <code>rdfs:label</code> for form building.
						Groups may also have an <code>sh:order</code> property to indicate the relative ordering of groups within the same form.
					</p>
					<p id="defaultValue">
						Property constraints may have a single value for <code>sh:defaultValue</code>.
						The default value does not have fixed semantics in SHACL, but MAY be used by user interface tools to pre-populate input widgets.
						The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code>, <code>sh:directType</code> or <code>sh:class</code> of the same constraint.
					</p>
					<p>
						The following example illustrates the use of these various features together.
					</p>
					<pre class="example" title="Shape with non-validating property characteristics">
ex:PersonFormShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:locality ;
		sh:name "locality" ;
		sh:description "The suburb, city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-US ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] .
	
ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .

ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .</pre>
					<p>
						A form building application may use the information above to display instances as follows:
					</p>
					<div style="background: #f3f3f3; padding: 8px">
						<div style="font-size: 18px; color: #0000a0"><b>Name</b></div>
						<table>
							<tr>
								<td style="text-align: right; width: 160px"><b>first name:</b></td>
								<td>John</td>
							</tr>
							<tr>
								<td style="text-align: right"><b>last name:</b></td>
								<td>Doe</td>
							</tr>
						</table>
						<div style="font-size: 18px; padding-top: 6px; color: #0000a0"><b>Address</b></div>
						<table>
							<tr>
								<td style="text-align: right; width: 160px"><b>street address:</b></td>
								<td>123 Silverado Ave</td>
							</tr>
							<tr>
								<td style="text-align: right"><b>locality:</b></td>
								<td>Cupertino</td>
							</tr>
							<tr>
								<td style="text-align: right"><b>zip code:</b></td>
								<td>54321</td>
							</tr>
						</table>
					</div>
				</section>
			</section>
			
			<section id="constraints-inverse-property">
				<h3>Inverse Property Constraints (sh:inverseProperty)</h3>
				<p class="todo">
					TODO: This section is quite similar to the one about sh:property, only in the inverse direction.
					Before writing all this down, we'd rather wait until the forward direction has stabilized.
					A quick example should suffice for now:
				</p>
				<pre class="example" title="Shape with an inverse property constraint">
ex:InversePropertyConstraintExampleShape
	a sh:Shape ;
	sh:inverseProperty [
		sh:predicate ex:someProperty ;  # e.g. "child"
		sh:minCount 1 ;
		sh:name "is someProperty of" ;  # e.g. "parent"
	] .</pre>
			</section>
			
			<section id="constraints-other">
				<h2>Other Core Constraints</h2>
				<p>
					While the previous sections have introduced constraints that focused on a single property within a shape,
					this section introduces other constraint types that can be used with shapes.
				</p>
				<section id="not">
					<h3>sh:not</h3>
					<p>
						SHACL supports a high-level negation constraint that can be used to verify that the <span class="term">focus node</span> does not have a given shape.
						This is comparable to a logical "not" operator.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:not</code></td>
							<td><code>sh:Shape</code></td>
							<td>The shape to negate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the <span class="term">focus node</span> produces no validation results with severity <code>sh:Violation</code> for the shape given via <code>sh:not</code>.
							A <span class="term">failure</span> must be reported if the validation of the shape produces a failure.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	BIND (sh:hasShape($this, $not, $shapesGraph, true) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || ?hasShape) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:not</code> in a shape to verify
						that certain nodes cannot have any value of <code>ex:property</code>.
					</p>
					<pre class="example" title="Shape with a negation">
ex:NotExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:not [
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:minCount 1 ;
			] ;
		]
	] .

ex:InvalidInstance1
  	ex:property "Some value" .</pre>
				</section>
				<section id="and">
					<h3>sh:and</h3>
					<p>
						SHACL supports a high-level syntax for conjunctive constraints that can be used to test whether the <span class="term">focus node</span> has all out of several shapes.
						This is comparable to a logical "and" operator.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:and</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the focus node against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the following condition is false:
							The validation of the <span class="term">focus node</span> against all of the shapes in the <code>sh:and</code> list produces a validation result with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$and rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph, true) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(!?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:and</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:and</code> in a shape to verify
						that certain nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
						the minimum count, and a blank node shape that further constrains the maximum count.
						As shown here, <code>sh:and</code> can be used to implement a specialization mechanism between shapes. 
					</p>
					<pre class="example" title="Shape with a conjunction">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:constraint [
		sh:and (
			ex:SuperShape
			[
				sh:property [
					sh:predicate ex:property ;
					sh:maxCount 1 ;
				]
			]
		)
	] .


ex:ValidInstance1
	ex:property "One" .

# Invalid: more than one property
ex:InvalidInstance2
	ex:property "One" ;
	ex:property "Two" .</pre>
				</section>
				<section id="or">
					<h3>sh:or</h3>
					<p>
						SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether the <span class="term">focus node</span> has at least one out of several shapes.
						This is comparable to a logical "or" operator.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:or</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the focus node against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the following condition is false:
							The validation of the <span class="term">focus node</span> against all of the shapes in the <code>sh:or</code> list produces no validation results with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$or rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph, true) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count = 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:or</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:or</code> in a shape to verify
						that certain nodes have at least one value of <code>ex:exampleProperty1</code>
						or at least one value of <code>ex:exampleProperty2</code>.
					</p>
					<pre class="example" title="Shape with a disjunction">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:or (
			[
				sh:property [
					sh:predicate ex:exampleProperty1 ;
					sh:minCount 1 ;
				]
			]
			[
				sh:property [
					sh:predicate ex:exampleProperty2 ;
					sh:minCount 1 ;
				]
			]
		)
	] .
	
ex:OrConstraintExampleValidResource
	ex:exampleProperty1 ex:someValue .</pre>
				</section>
				<section id="closed">
					<h3>Closed Shapes (sh:closed, sh:ignoredProperties)</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any resource can in principle have values for any property.
						However, in some cases it makes sense to restrict which properties can be applied to resources.
						The SHACL core language includes a property called <code>sh:closed</code> that can be assigned to
						a shape via the property <code>sh:constraint</code> to indicate that valid resources must only have
						values for those properties that have been explicitly declared via <code>sh:property</code>.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:closed</code></td>
							<td><code>xsd:boolean</code></td>
							<td>Set to <code>true</code> to close the shape</td>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td><code>rdf:List</code> (members: <code>rdf:Property</code>)</td>
							<td>Optional list of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
						</tr>
					</table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:closed</code> is <code>true</code> then
							a <span class="term">validation result</span> must be produced for each triple that has the <span class="term">focus node</span> as its
							<span class="term">subject</span> and a <span class="term">predicate</span> that is not explicitly enumerated as a <code>sh:predicate</code>
							of the <code>sh:property</code> constraints at the surrounding shape.
							If the argument <code>sh:ignoredProperties</code> is present then the properties enumerated in this list are also permitted.
							The produced <span class="term">validation result</span> must have the corresponding values of the triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<p>
						The core vocabulary includes an instance of <code>sh:NodeConstraint</code> called <code>sh:Closed</code>
						that can be used in places where no other arguments such as <code>sh:ignoredProperties</code> are needed.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ?predicate ?object
WHERE {
	{
		FILTER $closed .
	}
	$this ?predicate ?object .
	FILTER (NOT EXISTS {
		GRAPH $shapesGraph {
			$currentShape sh:property/sh:predicate ?predicate .
		}
	} &amp;&amp; (!bound($ignoredProperties) || NOT EXISTS {
		GRAPH $shapesGraph {
			$ignoredProperties rdf:rest*/rdf:first ?predicate .
		}
	}))
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:closed</code> in a shape to verify
						that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
						The "ignored" property <code>rdf:type</code> would also be allowed.
					</p>
					<pre class="example" title="A closed shape (complex syntax)">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:closed true ;
		sh:ignoredProperties (rdf:type) ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .
	
ex:ClosedShapeExampleValidResource
	ex:exampleProperty1 ex:someValue .
	
ex:ClosedShapeExampleInvalidResource
	ex:exampleProperty2 ex:someValue ;
	ex:someOtherProperty 42 .</pre>
					<p>
						The next example illustrates a more compact syntax using the built-in instance <code>sh:Closed</code>.
						In this form, no ignored properties can be specified.
					</p>
					<pre class="example" title="A closed shape (simple syntax)">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint sh:Closed ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .</pre>
				</section>
			</section>
		</section>
		
		<section id="shapesGraph">
			<h2>Declaring the Shapes Graph</h2>
			<p>
				A <span class="term">data graph</span> MAY link to one or more <span class="term">shapes graphs</span> via the property <code>sh:shapesGraph</code>.
				<!--The subject of this predicate must be the graph resource, i.e. the name of the data graph in the dataset.-->
				<!--TODO: do we need to know the graph resource? can we only claim we need to object value and we do not care about the subject? -->
				The object of this predicate is an IRI pointing at an RDF graph.
				Tools may use this information to determine which shapes graph to use for validation.
				If present, tools SHOULD transitively follow any links from the shapes graph via the predicate <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a> to other graphs and use the resulting union graph as parameter to the validation process.
			</p>
			<p>
				In the following example, a tool may use the named graph <code>&lt;http://example.org/graph-shapes&gt;</code> and its imports as the <span class="term">shapes graph</span> when validating the given graph.
			</p>
			<pre class="example" title="A data graph declaring a shapes graph">
&lt;http://example.org/graph&gt;
	sh:shapesGraph &lt;http://example.org/graph-shapes&gt; .

ex:MyInstance
	a ex:MyClass .</pre>
		</section>
		
		<section id="results">
			<h2>Validation Results Vocabulary</h2>
			<p>
				The output of a SHACL constraint validation process is a set of <span class="term">validation results</span>.
				SHACL includes an RDF vocabulary to represent such results together with
				structural information that may provide guidance on how to fix a violation, as well as
				human-readable messages.
			</p>
			<p>
				The validation results produced by a standards-compliant SHACL validation engine MUST be the product of validation of the <span class="term">data graph</span> only.
				Some engines MAY also report errors in the <span class="term">shapes graph</span>, but those errors MUST NOT be mixed with the data validation results using the same results vocabulary.
			</p>
			<p>
				The following code snippet represents a syntactically correct result that may have been produced by a constraint validation engine:
			</p>
			<pre class="example" title="A constructed validation result">
ex:ExampleConstraintViolation
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:MyCurrentNode ;
	sh:subject ex:MyCurrentNode ;
	sh:predicate ex:someProperty ;
	sh:object ex:someInvalidValue ;
	sh:message "Incorrect value: expected something else here." .</pre>
			<p>
				Validation results must be instances of the class <code>sh:ValidationResult</code>.
				Its superclass <code>sh:AbstractResult</code> defines the properties described in the following sub-sections.
				SHACL implementations may produce instances of other subclasses of <code>sh:AbstractResult</code>, for example
				to report successfully completed constraint checks or accumulated results.
			</p>
			<section id="results-focus-node">
				<h4>sh:focusNode</h4>
				<p>
					Validation results may have a single value for the property <code>sh:focusNode</code> to point to an
					IRI or blank node that has caused the result.
					This represents the <span class="term">focus node</span> that was validated when the validation result was produced.
				</p>
			</section>
			<section id="results-triple">
				<h4>sh:subject, sh:predicate and sh:object</h4>
				<p>
					Validation results are often caused by a single RDF triple, or a predicate in the context of a given subject or object.
					This information can be encoded via the properties <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>,
					each of which can have at most one value.
					<code>sh:predicate</code> can only be present if either <code>sh:subject</code> or <code>sh:object</code> have also been specified.
					If <code>sh:object</code> is unspecified, then the interpretation is that the result is caused by the subject/predicate combination.
					If <code>sh:subject</code> is unspecified, then the interpretation is that the result is caused by the object/predicate combination.
				</p>
			</section>
			<section id="results-source">
				<h4>sh:sourceConstraint, sh:sourceShape and sh:sourceTemplate</h4>
				<p>
					Validation results may link to one <code>sh:Constraint</code> that has caused
					the result, specified via the property <code>sh:sourceConstraint</code>,
					and at the <code>sh:Shape</code> defining the constraint, via <code>sh:sourceShape</code>.
					Validation results that were produced by a <a href="#template-constraints">template call</a> may
					link to the <code>sh:ConstraintTemplate</code> that caused the result.
				</p>
			</section>
			<section id="results-detail">
				<h4>sh:detail</h4>
				<p>
					The property <code>sh:detail</code> may link a (parent) result with one or more other
					(child) results that provide further details about the cause of the (parent) result.
					Depending on the capabilities of the constraint validation engine, this may include failures of
					nested constraints that have been evaluated via <code>sh:valueShape</code>.
				</p>
			</section>
			<section id="results-message">
				<h3>sh:message</h3>
				<p>
					Validation results may have values for the property <code>sh:message</code> to communicate
					additional textual details to humans.
					While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
				</p>
			</section>
			<section id="results-severity">
				<h3>sh:severity</h3>
				<p>
					Each validation result must have exactly one of the following values for the property <code>sh:severity</code>.
				</p>
				<table class="term-table">
					<tr>
						<th>Severity</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:Info</code></td>
						<td>An informative message, not a violation.</td>
					</tr>
					<tr>
						<td><code>sh:Warning</code></td>
						<td>A non-critical constraint violation indicating a warning.</td>
					</tr>
					<tr>
						<td><code>sh:Violation</code></td>
						<td>A constraint violation that should be fixed.</td>
					</tr>
				</table>
			</section>
			<section id="severity">
				<h3>Declaring the Severity of a Constraint</h3>
				<p>
					Constraints can specify their severity level using the property <code>sh:severity</code>,
					which must link to one of the severity types.  <code>sh:Violation</code> is the default if unspecified.
					Constraints based on <a href="#template-constraints">templates</a> use the <code>sh:severity</code> declared at the template itself unless overridden at the constraint.
					The following example clarifies this.
				</p>
				<pre class="example" title="Declaring the Severity using sh:severity">
ex:MyShape
	a sh:Shape ;
	sh:property [
		# Violations of either minCount and datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# Violation of maxCount are produced as sh:Violations (which is the default severity for sh:maxCount)
		sh:predicate ex:myProperty ;
		sh:maxCount 1 ;
	] ;
.</pre>
			</section>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="part2" style="font-size: 160%; font-weight: bold">Part 2: Advanced Features</h1>
			<p>
				Part 1 of this specification has introduced features that are built into the Core of SHACL.
				The goal of this Core was to provide a high-level vocabulary for common use cases to describe shapes.
				However, SHACL also provides mechanisms to go beyond the Core vocabulary and represent constraints and scopes with greater flexibility.
				These mechanisms are described in the sections of Part 2.
			</p>
		</div>
		
		<section id="native-constraints">
			<h2>Native Constraints</h2>
			<p>
				The property <code>sh:constraint</code> provides the most general mechanism to associate a constraint with a shape.
				The values of this property must be <span class="term">constraints</span> - instances of the class <code>sh:Constraint</code>.
				Note that the property <code>sh:property</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:PropertyConstraint</code>.
				The property <code>sh:inverseProperty</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:InversePropertyConstraint</code>.
			</p>
			<p>
				SHACL supports two types of general constraints:
			</p>
			<ul>
				<li>Constraints based on a high-level vocabulary (<a href="#template-constraints">templates</a>)</li>
				<li>Constraints based on a native executable (such as a SPARQL query)</li>
			</ul>
			<p>
				The following sub-sections are about the latter, while templates are covered at a later stage.
			</p>
			<section class="informative">
				<h3>An Example Native Constraint</h3>
				<p>
					For the sake of this example, we assume a data graph containing the following instances:
				</p>
				<pre class="example" title="Example ex:Country instances">
ex:ValidCountry
	a ex:Country ;
	ex:germanLabel "Spanien"@de .
  
ex:InvalidCountry
	a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<p>
					The following example illustrates the definition of a <span class="term">native constraint</span> based on a SPARQL query.
					The value of the property <code>sh:sparql</code> is a SELECT query as explained in a later <a href="#native-constraints-sparql">section</a>.
				</p>
				<pre class="example" title="Example Shape with a native SPARQL constraint">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:constraint [
		sh:message "Values must be literals with German language tag." ;
		sh:sparql """
			SELECT $this ($this AS ?subject) (ex:germanLabel AS ?predicate) (?value AS ?object)
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .</pre>
				<p>
					The scope of the shape includes all instances of <code>ex:Country</code>.
					For those instances (represented by the variable <code>$this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
					and verifies that they are literals with a German language code.
					The output of the graph validation for the instances above is shown in the next example: 
				</p>
				<pre class="example" title="Example validation results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:InvalidCountry ;
	sh:subject ex:InvalidCountry ;
	sh:predicate ex:focusNode ;
	sh:object "Spain"@en ;
	sh:sourceShape ex:LanguageExampleShape ;
	...
]
</pre>
				<p>
					The SPARQL query returns result set rows for all bindings of <code>?value</code> that violate the constraint.
					A validation result is produced for each row in that result set, using <code>$this</code> as the <code>sh:focusNode</code> and <code>sh:subject</code>,
					<code>ex:germanLabel</code> as <code>sh:predicate</code> and the violating value as <code>sh:object</code>.
				</p>
				<p>
					In the example above, it is assumed that the existing SHACL validation engine is capable of evaluating native constraints using SPARQL, as described in the following section.
					Additional executable languages such as JavaScript may be provided based on other sets of properties like <code>ex:javaScript</code>,
					but that is outside of the scope of this specification.
				</p>
			</section>
			<section id="native-constraints-sparql">
				<h3>SPARQL-based Native Constraints</h3>
				<p>
					Native SPARQL constraints are instances of <code>sh:SPARQLConstraint</code>, which is a subclass of <code>sh:NativeConstraint</code>, which in turn is a subclass of <code>sh:Constraint</code>.
					Native SPARQL constraints must have one value for the property <code>sh:sparql</code>.
					The SPARQL queries linked to a <span class="term">constraint</span> via <code>sh:sparql</code> must be string literals that can be parsed into legal SPARQL 1.1 queries	of the query form <code>SELECT</code>.
					Before parsing, a SHACL processor must prepend <code>PREFIX</code> statements for all namespace prefixes defined in the current <span class="term">shapes graph</span>.
				</p>
				<section id="sparql-constraints-prebound">
					<h4>Pre-bound Variables in SPARQL Constraints ($this, $shapesGraph, $currentShape)</h4>
					<p>
						The following table enumerates variables that have special meaning in SPARQL constraints.
						When SPARQL constraints are executed, the validation engine must pre-bind values for these variables.
						The effect of this pre-binding is that all occurrences of these variables in the query will have the provided
						values, similar to doing a variable substitution in the query but also supporting blank nodes.
					</p>
					<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
						The following definition of what pre-binding means has not been approved by the WG yet,
						and is work in progress.
					</p>
					<p id="pre-binding">
						Formally, <span class="term">pre-binding</span> a variable with a value means that, prior to evaluating a query,
						the SHACL processor needs to substitute all occurrences of the variable in the query (including
						inner scopes and nested SELECT queries) with the provided value.
						Expressions of the form <code>isBound(?var)</code> need to be substituted with the constant <code>true</code>.
						Furthermore, if the original query projects a pre-bound variable as part of a SELECT, then
						these result sets need to include name-value pairs based on the pre-bindings.
						Blank nodes can be handled using <em>skolemization</em>, i.e. temporarily turned into IRIs.
						Functions operating on blank nodes, such as <code>isBlank</code> need to return appropriate results for skolemized blank nodes.
					</p>
					<p>
						Note that the above definition is not meant to serve as recommendation for an actual implementation,
						but merely to illustrate the effect of pre-binding.
						In some cases, the effect can be achieved by injecting a SPARQL <code>VALUES</code> clause
						and similar techniques such as algebra manipulation.
					</p>
					<table class="term-table">
						<tr>
							<th>Variable</th>
							<th>Interpretation</th>
						</tr>
						<tr>
							<td><code>$this</code></td>
							<td>
								The <span class="term">focus node</span>.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">$shapesGraph</code></td>
							<td>
								The named graph containing the shape definitions (and possibly other data).
								Can be used as in <code>GRAPH $shapesGraph { ... }</code> to query shapes, constraints, background data
								and complex arguments such as <code>rdf:Lists</code>.
								Not all SHACL processors need to support this variable.
								Processors that do not support <code>$shapesGraph</code> MUST report an error
								if they encounter a query that references the <code>$shapesGraph</code> variable.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">$currentShape</code></td>
							<td>
								The currently validated shape.  Typically used in conjunction with <code>$shapesGraph</code>.
							</td>
						</tr>
					</table>
				</section>
				<section id="sparql-constraints-variables">
					<h4>Mapping of Result Variables to Validation Results</h4>
					<p>
						Each row of the result set produced by a SELECT query must be converted into one validation result resource.
						The properties of those resources are derived by the following rules, through a combination of result variables and the properties linked to the constraint itself.
						The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Production Rules</th>
						</tr>
						<tr>
							<td><code>sh:severity</code></td>
							<td>
								<ol>
									<li>For <span class="term">template constraints</span>, the value of <code>sh:severity</code> of the constraint node (template instance)</li>
									<li>The value of <code>sh:severity</code> of the subject of the <code>sh:sparql</code> triple</li>
									<li><code>sh:Violation</code> as default</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:focusNode</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>$this</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:subject</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?subject</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:predicate</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?predicate</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:object</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?object</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:message</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?message</code></li>
									<li>
										The values of <code>sh:message</code> of the subject of the <code>sh:sparql</code> triple.
										These values may reference any variable from the SELECT result variables via <code>{?varName}</code>.
										If the constraint is a template constraint, then the template's argument variables can also be used.
										The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
									</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceConstraint</code></td>
							<td>
								<ol>
									<li>The <span class="term">constraint</span> that was validated against</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceShape</code></td>
							<td>
								<ol>
									<li>The <span class="term">shape</span> that was validated against</li>
								</ol>
							</td>
						</tr>
					</table>
				</section>
				<section id="sparql-constraints-annotations">
					<h4>Injecting Annotation Properties into Validation Results</h4>
					<p>
						It is possible to inject additional <span class="term">annotation properties</span> into the validation result resources created for each row of the SELECT result sets.
						Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the subject holding the <code>sh:sparql</code> triple.
						The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value type</th>
							<th>Count</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>sh:annotationProperty</code></td>
							<td><code>rdf:Property</code></td>
							<td><code>1 (mandatory)</code></td>
							<td>The annotation property that shall be set</td>
						</tr>
						<tr>
							<td><code>sh:annotationVarName</code></td>
							<td><code>xsd:string</code></td>
							<td><code>0..1</code></td>
							<td>The name of the SPARQL variable to take the values from</td>
						</tr>
						<tr>
							<td><code>sh:annotationValue</code></td>
							<td></td>
							<td><code>0..unlimited</code></td>
							<td>Constant nodes that shall be used as default values</td>
						</tr>
					</table>
					<p>
						For each row of a SELECT result set, a SHACL processor must walk through the declared result annotations.
						The mapping from result annotations to SPARQL variables uses the following rules:
					</p>
					<ol>
						<li>If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the validation engine must look for the variable named after the <code>sh:annotationVarName</code></li>
						<li>Otherwise, the validation engine must derive a variable name from the value of <code>sh:annotationProperty</code> using the same <a href="#template-arguments">local name mechanism</a> as described earlier</li>
					</ol>
					<p>
						If a variable name could be determined, then the validation engine must copy the bindings for the given variable into the constructed validation results for the current row.
						If the variable has no binding in the result set row, then the value of <code>sh:annotationValue</code> must be used, if present.
					</p>
					<p>
						The values of <code>sh:annotationProperty</code> must not be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
					</p>
					<p>
						Here is a slightly complex example, illustrating the use of result annotations.
					</p>
					<pre class="example" title="Constraint with an annotation">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:scopeNode ex:ExampleRootResource ;
	sh:constraint [
		a sh:SPARQLConstraint ;
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:sparql """
			SELECT $this ?subject (ex:property2 AS ?predicate) (?first AS ?object) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .
	
ex:ExampleRootResource
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
					<p>
						Which produces the following validation result resource:
					</p>
					<pre class="example" title="Constraint example result output">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:ExampleRootResource ;
	sh:subject ex:ExampleValueResource ;
	sh:predicate ex:property2 ;
	sh:object ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:constraint above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
				</section>
			</section>
		</section>
		
		<section id="template-constraints">
			<h2>Template Constraints</h2>
			<p>
				Native constraints in a language like SPARQL as introduced in the previous section typically provide a lot of flexibility.
				However, SPARQL-based constraints may also be hard to understand for some people, and may be repetitive.
				<span class="term">Templates</span> can be used to encapsulate and parameterize such native queries.
				<span class="term">Constraint templates</span> can be instantiated anywhere where a native constraint may appear (in particular, at <code>sh:constraint</code>).
				<span class="term">Scope templates</span> can be instantiated anywhere where a native scope may appear, at <code>sh:scope</code>.
				All of the constraint and scope types built into the SHACL Core are also represented as templates in the SHACL RDF vocabulary.
				Such templates form a high-level vocabulary that may also be directly interpreted ("hard-coded") without reliance on the fact that they are templates.
			</p>
			<p>
				Constraint templates are represented as IRI nodes that are instances of the class <code>sh:ConstraintTemplate</code>.
				Scope templates are represented as IRI nodes that are instances of the class <code>sh:ScopeTemplate</code>.
				SHACL also includes a more general superclass <code>sh:Template</code> that may be used for other kinds of templates (rules, stored queries etc).
				Well-defined, non-abstract templates must provide at least one <span class="term">body</span> using a property such as <a href="#sparql-templates"><code>sh:sparql</code></a>.
			</p>
			<section class="informative">
				<h3>An Example Template Constraint</h3>
				<p>
					The following example illustrates the definition of a constraint template based on a SPARQL query.
					It is a variation of the native example constraint from the previous section.
					That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
					Templates make it possible to generalize such scenarios, so that constants get substituted with <span class="term">arguments</span>.
					This allows the query logic to be reused in multiple places, without having to write any new SPARQL. 
				</p>
			<pre class="example" title="Constraint template based on SPARQL">
ex:LanguageConstraint
	a sh:ConstraintTemplate ;
	rdfs:label "Language constraint" ;
	rdfs:subClassOf sh:TemplateConstraint ;
	sh:argument [
		sh:predicate ex:predicate ;
		sh:class rdf:Property ;
		sh:name "predicate" ;
		sh:description "The property to validate the values of." ;
    ] ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:sparql """
		SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
		WHERE {
			$this $predicate ?value .
			FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
		}
		""" .</pre>
				<p>
					Once a template has been defined, it can be instantiated as a constraint, as illustrated in the following example:
				</p>
				<pre id="TemplateLanguageExampleShape" class="example" title="Shape definition using ex:LanguageConstraint">
ex:TemplateLanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:constraint [
		a ex:LanguageConstraint ;
		ex:predicate ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:constraint [
		a ex:LanguageConstraint ;
		ex:predicate ex:englishLabel ;
		ex:lang "en" ;
	] .</pre>
				<p>
					The example shape above specifies that all values of <code>ex:germanLabel</code> must carry the language tag <code>de</code>
					while all values of <code>ex:englishLabel</code> must have <code>en</code> as their language.
					These details are specified via two instances of <code>ex:LanguageConstraint</code> that provide values for the arguments required by the template.
				</p>
				<p>
					The following sections introduce the properties that constraint templates may have.
					All of these properties except for <code>sh:sparql</code> are independent of SPARQL-based execution and apply
					to constraint templates based on other languages such as JavaScript too.
					A later <a href="#sparql-templates">section</a> provides additional details for SPARQL-based SHACL templates.
				</p>
			</section>
			<section id="template-arguments">
				<h3>Template Arguments</h3>
				<p>
					The arguments of a template are linked via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>, but the <code>rdf:type</code> triples of these instances can be omitted.
				</p>
				<p>
					Each <code>sh:Argument</code> must have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs.
					<span id="def-local-name">The <span class="term">local name</span> of a IRI is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the IRI, not immediately preceeded by the first colon in the IRI.</span>
					The local names of the values of <code>sh:predicate</code> must fulfill the following conditions (to ensure a correct mapping from arguments into SPARQL variables is possible):
				</p>
				<ul>
					<li>The <span class="term">local name</span> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Argument</code> for the same template (and its transitive superclasses) that has a <code>sh:predicate</code> with the same <span class="term">local name</span></li>
				</ul>
				<p>
					An <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
				</p>
				<p>
					An <code>sh:Argument</code> may declare a default value via <code>sh:defaultValue</code>.
					For non-optional arguments, the validation engine must use the declared default value for template instances that do not define a value for this argument.
					Template instances can have at most one value for each argument predicate.
				</p>
				<p>
					An <code>sh:Argument</code> may declare one value for the property <code>sh:class</code> or one value for
					<code>sh:datatype</code>, similar to their counterparts in property constraints.
					Likewise, an <code>sh:Argument</code> may specify a <code>sh:NodeKind</code> via <code>sh:nodeKind</code>.
					This can be used to communicate the expected value type of the argument in template instances.
					Some implementations MAY use this information to prevent the execution of a template with invalid arguments.
				</p>
			</section>
			<section id="template-instantiation">
				<h3>Template Instantiation</h3>
				<p>
					<code>sh:Template</code> is subclass of <code>rdfs:Class</code>, which means that templates can be instantiated via <code>rdf:type</code>.
					Such <span class="term">template instances</span> can be used as values of <code>sh:constraint</code>, among others, as demonstrated in an <a href="#TemplateLanguageExampleShape">example</a> above.
				</p>
				<p>
					Template instances are called <span class="term">complete</span> when they have values for all non-optional arguments.
					Only template instances that are complete will be used - incomplete templates will be (silently) ignored during constraint validation.
				</p>
				<p>
					Constraint templates may be placed in a <code>rdfs:subClassOf</code> relationship with other templates.
					The implication of doing this is that when an instance of the superclass template is validated, then all (transitive) superclass templates will also be validated,
					assuming their arguments are <span class="term">complete</span>.
				</p>
			</section>
			<section id="template-labelTemplate">
				<h3>sh:labelTemplate</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used to suggest how instances of the template shall be rendered to humans.
					The <code>sh:labelTemplate</code> must be a string that can reference the arguments using the syntax <code>{?varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the argument.
					At display time, these <code>{?...}</code> blocks SHOULD be substituted with the actual values used in the template instance.
				</p>
			</section>
			<section id="template-property-constraints">
				<h3>Property Constraint Templates</h3>
				<p>
					Some constraints are about a specific property only, and SHACL provides the system properties <code>sh:property</code> and <code>sh:inverseProperty</code> for those cases.
					In order to define constraints that can be used similar to the built-in Core constraint properties such as <code>sh:minCount</code>,
					a SHACL template needs to declared to be a subclass of <code>sh:PropertyConstraint</code> (for <code>sh:property</code>) or <code>sh:InversePropertyConstraint</code> (for <code>sh:inverseProperty</code>).
					Such templates "inherit" the argument <code>sh:predicate</code>.
					This is illustrated in the following example.
				</p>
				<pre class="example" title="An example property constraint template with a shape that uses it">
ex:LanguagePropertyConstraint
	a sh:ConstraintTemplate ;
	rdfs:subClassOf sh:PropertyConstraint ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:sparql """
		SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
		WHERE {
			$this $predicate ?value .
			FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
		}
		""" .

ex:TemplateLanguageWithPropertyConstraintExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:property [
		a ex:LanguagePropertyConstraint ;
		sh:predicate ex:germanLabel ;
		sh:datatype rdf:langString ;
		sh:maxCount 1 ;
		ex:lang "de" ;
	] .</pre>
				<p>
					As shown above, shapes can instantiate such templates via <code>sh:property</code>
					and mix custom constraint properties such as <code>ex:lang</code> with those from the SHACL Core vocabulary, such as <code>sh:maxCount</code>.
				</p>
			</section>
			<section id="template-validation-functions">
				<h3>Templates with a sh:validationFunction</h3>
				<p>
					Constraint templates that are instances of <code>sh:PropertyValueConstraintTemplate</code> or
					<code>sh:InversePropertyValueConstraintTemplate</code> (which are subclasses of <code>sh:ConstraintTemplate</code>) do not require an executable body (such a <code>sh:sparql</code>)
					if they instead link to a <code>sh:Function</code> via the property <code>sh:validationFunction</code>.
					These so called <span class="term">validation functions</span> must take an argument with the predicate <code>sh:value</code> as its first argument
					and return either <code>true</code> or <code>false</code>.
					This validation function must be used by a constraint validation engine to construct a procedure that iterates over all values of the (possibly inverse) property,
					and then runs a filter test using the function.  If the filter returns <code>false</code> then a validation result must be produced.
					Validation functions may take additional arguments, and the validation engine must fill them with the matching arguments from the surrounding template.
					The SHACL system vocabulary contains several examples of such validation functions, e.g. <code>sh:AbstractDatatypePropertyConstraint</code>.
				</p>
				<p>
					The following example defines a constraint template using a <span class="term">validation function</span> from a <a href="#ValidationFunctions">later section</a>.
				</p>
				<pre class="example" title="Template definition using a validation function">
ex:LanguageConstraint
	a sh:PropertyValueConstraintTemplate ;
	rdfs:label "Language constraint" ;
	rdfs:subClassOf sh:TemplateConstraint ;
	sh:argument [
		sh:predicate ex:predicate ;
		sh:class rdf:Property ;
		sh:name "predicate" ;
		sh:description "The property to validate the values of." ;
    ] ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:validationFunction ex:hasLanguage .</pre>
			</section>
			<section id="sparql-templates">
				<h3>SPARQL-based Constraint Templates</h3>
				<p>
					If a <code>sh:Template</code> has a value for <code>sh:sparql</code>, then the corresponding instances need to follow the same execution rules as outlined for <a href="#native-constraints-sparql">SPARQL-based Constraints</a> and <a href="#sparql-scopes">SPARQL-based Scopes</a>.
					The only difference is that the SPARQL queries need to be executed with additional <span class="term">pre-bound</span> variables, derived from the arguments of the template.
					The names of those variables must match the <a href="#def-local-name"><span class="term">local name</span></a> of the argument predicates, including the arguments defined by any (transitive) superclasses of the template.
					For example, if an argument is represented with the predicate <code>ex:myArgument</code> then the variable <code>?myArgument</code> must be <span class="term">pre-bound</span> with the value of the argument in the template instance.
				</p>
				<p>
					If a <code>sh:PropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the validation engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="algorithm">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	FILTER (!{validationFunction}(?object, {+ other matching arguments})) .
}</pre>
				<p>
					If a <code>sh:InversePropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the validation engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="algorithm">
SELECT $this ?subject $predicate ($this AS ?object)
WHERE {
	?subject $predicate $this .
	FILTER (!{validationFunction}(?subject, {+ other matching arguments})) .
}</pre>
			</section>
		</section>
		
		<section id="general-scopes">
			<h2>General Scopes (sh:scope)</h2>
			<p>
				In addition to the scope classes introduced in the core section, such as <code>sh:PropertyScope</code>,
				SHACL provides facilities to define custom scopes.
				Similar to constraints, scopes may either be <span class="term">native scopes</span> or be an instance of <code>sh:TemplateScope</code>.
				All this is analogous to how constraints work, but with the additional restrictions:
			</p>
			<ul>
				<li>All subjects of <code>sh:scope</code> triples must be IRIs</li>
				<li>The arguments of a scope template must not be blank nodes</li>
			</ul>
			<section id="sparql-scopes">
				<h3>SPARQL-based Scopes</h3>
				<p>
					SPARQL-based scopes must be instances of <code>sh:SPARQLScope</code>, which is a subclass of <code>sh:NativeScope</code>.
					The SPARQL queries linked to a <span class="term">scope</span> via <code>sh:sparql</code> must be of the query form <code>SELECT</code>.
					The SELECT queries must project to the result variable <code>?this</code>.
					The resulting scope consists of all distinct bindings for the variable <code>?this</code>.
				</p>
				<p>
					The SELECT queries must also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This constraint makes sure that validation engines can validate whether a given shape applies to a given focus node.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based scope that produces all persons born in the USA:
				</p>
				<pre class="example" title="SPARQL-based scope example">
ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		a sh:SPARQLScope ;
		sh:sparql """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	sh:constraint ...</pre>
			</section>
		</section>
		
		<section id="functions">
			<h2>Functions</h2>
			<p>
				SHACL <span class="term">functions</span> define operations that produce an RDF node based on zero or more arguments and a dataset. <!--TODO: check term dataset (SHACL is not limited to datasets) -->
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<p>
				Functions must be declared as instances of the class <code>sh:Function</code>.
				Well-defined, non-abstract functions must provide at least one body property such as <a href="#sparql-functions"><code>sh:sparql</code></a>.
			</p>
			<section class="informative">
				<h3>An Example Function</h3>
				<p>
					The following example illustrates the definition of a <span class="term">function</span> based on a SPARQL query.
				</p>
				<pre class="example" title="SHACL function with a SPARQL body">
ex:exampleFunction
	a sh:Function ;
	rdfs:comment "Computes the sum of its two arguments ?arg1 and ?arg2." ;
	sh:returnType xsd:integer ;
	sh:argument [
		sh:predicate sh:arg1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:argument [
		sh:predicate sh:arg2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:sparql """
		SELECT ($arg1 + $arg2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Based on the declaration above, SPARQL engines with full SHACL support can install a new SPARQL function based on the SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:exampleFunction(40, 2)</code>, producing <code>42</code>, as illustrated in the following SPARQL query.
				</p>
				<pre class="example" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject
WHERE {
	?subject ex:myProperty ?value .
	FILTER (ex:exampleFunction(?value, 2) = 42) .
}</pre>
				<p>
					The following sections introduce the properties that all such functions may have.
					A later <a href="#sparql-functions">section</a> provides additional details for SPARQL-based SHACL functions.
				</p>
			</section>
			<section id="function-arguments">
				<h3>Function Arguments</h3>
				<p>
					The arguments of a function are linked to its <code>sh:Function</code> via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>, but their <code>rdf:type</code> triple can be omitted.
				</p>
				<p>
					Each <code>sh:Argument</code> must have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs, and follow the same restrictions outlined for <a href="#template-arguments">Template Arguments</a>.
					Arguments are "inherited" from the superclasses of the function.
					For example if a superclass already declares <code>sh:arg1</code> then subclasses may only define <code>sh:arg2</code> etc.
				</p>
				<p id="function-arguments-ordering">
					Arguments are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?arg1, ?arg2)</code>.
					The ordering of function arguments (e.g. for printing in SPARQL strings) is determined by their index.
					For each function, the indices must be 0, 1, 2 etc.  The index of each declared <code>sh:Argument</code>
					is determined as follows:
				</p>
				<ol>
					<li>The index of the built-in argument predicates <code>sh:arg1</code>, <code>sh:arg2</code> etc is their numeric name part minus 1, e.g. <code>sh:arg1</code> has index 0.</li>
					<li>The index of other argument predicates is the value of the property <code>sh:order</code> at the surrounding <code>sh:Argument</code>.</li>
					<li>Arguments that are neither of the form <code>sh:argX</code> nor have an <code>sh:order</code> are place at the end, whereby arguments that have <code>sh:optional</code> set to <code>true</code> get a higher index than non-optional arguments.</li>
				</ol>
				<p>
					Each <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
					If an argument has been declared optional, then all succeeding arguments must also be declared optional.
				</p>
				<p>
					Similar to <a href="#constraints-property">Property Constraints</a>, each <code>sh:Argument</code> may declare one value for the property <code>sh:datatype</code> or one value for the property <code>sh:class</code>.
					This can be used to communicate the expected value type of the argument in function calls.
					Some implementations MAY use this information to prevent the execution of a function with invalid arguments.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an RDF value type.
				</p>
			</section>
			<section id="ValidationFunctions">
				<h3>Validation Functions</h3>
				<p>
					It is a common design pattern for functions to take a value as input and validate whether that value fulfills certain conditions or not.
					In support of this pattern, SHACL supports <span class="term">validation functions</span>, which are instances of <code>sh:Function</code> that are also subclasses of <code>sh:ValidationFunctions</code>.
					From that superclass, these functions "inherit" the (first) argument <code>sh:value</code>.
					Validation functions may define additional arguments with <code>sh:order</code> values larger than 1.
					The following example illustrates a validation function for the running example of the <a href="#template-validation-functions">section on constraint templates</a>.
				</p>
				<pre class="example" title="A validation function">
ex:hasLanguage
	a sh:Function ;
	rdfs:subClassOf sh:ValidationFunctions ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:order 1 ;
		sh:name "language" ;
		sh:description "The language to match against, e.g. \"de\"." ;
	] ;
	sh:returnType xsd:boolean ;
	sh:sparql """
  		ASK {
  			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang)) .
		}
		""" .</pre>
				<p>
					An example invocation of the function above is: <code>ex:hasLanguage("Spain"@en, "en")</code>, producing <code>true</code>.
				</p>
			</section>
			<section id="sparql-functions">
				<h3>SPARQL-based Functions</h3>
				<p>
					If a <code>sh:Function</code> has a value for <code>sh:sparql</code> then it can be regarded as a <span class="term">SPARQL-based function</span>.
					In the SPARQL query, the SPARQL processor needs to <span class="term">pre-bind</span> variables based on the provided arguments of the function call.
					The SPARQL query must be of type ASK or SELECT.
					For ASK queries, the function's return value is the result of the ASK query execution.
					For SELECT queries, the function's return value is the first binding of the first result variable in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one row.
				</p>
				<p class="issue" data-number="22" title="Treatment of recursive shape definitions">
					According to resolution <a href="https://www.w3.org/2015/12/16-shapes-minutes.html#resolution04">2015.12.16/04</a> shapes graphs with dependency loops are invalid and suitable limitations of this will be explored.
					Until  issue 22 is closed, definitions regarding recursion are not endorsed by the WG.
				</p>
				<p>
					<em>Recursive use of functions is undefined:</em>
					If a SPARQL-based function contains calls to other functions so that the same function with the same combination of arguments would be visited twice
					then the result of the function call is undefined.
					An implementation may either return no result (unbound) or terminate the surrounding SPARQL query with an error.
				</p>
				<p>
					Some validation engines may ignore the specified <code>sh:sparql</code> query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified <code>sh:sparql</code> query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the <code>sh:sparql</code> query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>
		
		<section id="derivedValues">
			<h2>Derived Values Constraints</h2>
			<p>
				It is a common scenario that certain property values are derived from other values.
				For example, the area of a rectangle must be the product of width and height, or an uncle of a person is a male sibling of a parent.
				SHACL includes a property <code>sh:derivedValues</code> that can be used with property and inverse property constraints, to define such constraints.
				The values of <code>sh:derivedValues</code> must be instances of the class <code>sh:DerivedValuesTemplate</code>, although the <code>rdf:type</code> triple of those instances is optional.
				Each <code>sh:DerivedValuesTemplate</code> must include execution instructions such as a SPARQL query or a JavaScript snippet, that produce the values that the property is expected to have.
				This is illustrated in the following example.
			</p>
			<pre class="example" title="A property definition with derived values">
ex:RectangleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:width ;
		sh:datatype xsd:integer ;
	] ;
	sh:property [
		sh:predicate ex:height ;
		sh:datatype xsd:integer ;
	] ;
	sh:property [
		sh:predicate ex:area ;
		sh:datatype xsd:integer ;
		sh:derivedValues [
			sh:sparql """
				$this ex:width ?width .
				$this ex:height ?height .
				BIND (?width * ?height AS ?value) .
				""" ;
		] ;
	] .</pre>
			<p>
				For SHACL processors supporting SPARQL, a <code>sh:DerivedValuesTemplate</code> can have a value of <code>sh:sparql</code>.
				The values of <code>sh:sparql</code> must be SPARQL fragments that can be turned into a valid SPARQL query by surrounding it
				with the prefix declarations from the shapes graph and <code>SELECT ?value WHERE { ... }</code>.
				These fragments can access the current focus node via the variable <code>$this</code> and must produce bindings for the variable <code>?value</code> for all derived values.
				In the example above, all values of the property <code>ex:area</code> must be all products of <code>ex:width</code> and <code>ex:height</code>.
			</p>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body">
					Let S be the set of nodes produces by the derived values template for the <span class="term">focus node</span>.
					A <span class="term">validation result</span> must be produced for every value of the given property <code>sh:predicate</code>
					that is not in S, and for every member of S that is not a property value.
					The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code>, and the missing or extra value as its <code>sh:object</code>.
					(The same definition applies in the inverse direction if <code>sh:derivedValues</code> is used in an inverse property constraint.)
				</div>
			</div>
		</section>

		<section id="defaultValueType">
			<h2>Validation of shapes graphs and the sh:defaultValueType property</h2>
			<p>
				The SHACL system vocabulary itself is using shapes, allowing SHACL constraint validation to be executed on shapes graphs, e.g. to validate the syntax of shape definitions.
				However, some system properties such as <code>sh:property</code>, <code>sh:filterShape</code> and <code>sh:argument</code> may have untyped blank nodes or IRIs as their values.
				If, for example, a value of <code>sh:property</code> is a blank node that does not have any <code>rdf:type</code>, then the assumption is that the blank node has type <code>sh:PropertyConstraint</code>.
				Unless these implicit triples are present in the data graph, constraint validation will not apply the constraints defined for <code>sh:PropertyConstraint</code>.
			</p>
			<p>
				If a validation engine intends to validate the syntax of a SHACL shapes graph itself, it should (temporarily) add the missing <code>rdf:type</code> triples.
				The SHACL system vocabulary includes some helper triples using the predicate <code>sh:defaultValueType</code> to specify the default <code>rdf:type</code> for certain properties.
				For example, the default value type of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
				These triples can be queried by a pre-processor to construct the missing type triples for the affected nodes.
				SHACL includes a template <code>sh:DefaultValueTypeRule</code> which encapsulates a SPARQL query that can be used for that purpose:
			</p>
			<pre class="algorithm">
CONSTRUCT {
	?node a ?defaultValueType .
}
WHERE {
	?predicate sh:defaultValueType ?defaultValueType .
	?anySubject ?predicate ?node .
	FILTER (NOT EXISTS { ?node a ?anyType }) .
}</pre>
			<p>
				The operations in this section assume that these default value types are present in the shapes graph, e.g.
				simplifying the test whether a given node is a <code>sh:PropertyConstraint</code>.
			</p>
		</section>

		<section id="entailment">
			<h2>Entailment</h2>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be actviated on the data graph.
				However, the property <code>sh:entailment</code> can be used to instruct a SHACL validation engine to ensure that a given entailment is activated.
				The values of <code>sh:entailment</code> must be IRIs, with common use cases covered by [[!sparql11-entailment]].
				The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.
			</p>
			<p>
				If the validation engine is not capable of supporting the given entailment regime, then it must produce a <span class="term">failure</span>.
				Standard-compliant SHACL implementations are not required to support any entailment regimes.
			</p>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>
		
		<section id="terms" class="appendix">
			<h2>Glossary of Key Concepts</h2>
			<section id="term-Shape">
				<h3>Shape</h3>
				<ul>
					<li>A <span class="term">shape</span> is represented by an RDF node belonging to the class <code>sh:Shape</code>.</li>
					<li>Can have zero or more <span class="term">constraints</span>.</li>
					<li>Can have zero or more <span class="term">scopes</span> that select the nodes that the shape applies to.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that the shape applies to.</li>
				</ul>
			</section>
			<section id="term-Constraint">
				<h3>Constraint</h3>
				<ul>
					<li>A <span class="term">constraint</span> is represented by an RDF node belonging to the class <code>sh:Constraint</code>.</li>
					<li>Are either <span class="term">native constraints</span> (e.g. based on a SPARQL query) or <span class="term">template constraints</span>.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that constraint applies to.</li>
					<li>Are validated against nodes in an RDF graph.</li>
				</ul>
			</section>
			<section id="term-Validation">
				<h3>Constraint Validation</h3>
				<ul>
					<li><span class="term">Validation</span> of <span class="term">Constraints</span> checks for the presence or absence of certain triples in an RDF graph</li>
					<li>Produces results, including informational results, warnings, and violations.</li> 
				</ul>
			</section>
			<section id="term-FocusNode">
				<h3>Focus Node</h3>
				<ul>
					<li>A <span class="term">Focus Node</span> is an RDF node in a graph that is passed into the <span class="term">validation</span> of a constraint.</li>
					<li>Represented using the variable <code>?this</code> in SPARQL.</li>
				</ul>
			</section>
			<section id="term-Scope">
				<h3>Scope</h3>
				<ul>
					<li>A <span class="term">Scope</span> is a declarative mechanism to select <span class="term">Focus Nodes</span> from a given graph.</li>
					<li>There are node scopes (<code>sh:scopeNodee</code>), class-based scopes (<code>sh:scopeClass</code>, <code>rdf:type</code>) and general scopes (<code>sh:scope</code>).</li>
					<li>A general scope may be defined by either a SPARQL query or a template.</li>
				</ul>
			</section>
			<section id="term-FilterShape">
				<h3>Filter Shape</h3>
				<ul>
					<li>A <span class="term">filter shape</span> defines constraints that potential focus nodes need to fulfill before they are validated.</li>
					<li>A node passes a filter shape when the validation against the shape does not lead to validation results with severity <code>sh:Violation</code> or a failure.</li>
				</ul>
			</section>
			<section id="term-Template">
				<h3>Template</h3>
				<ul>
					<li>A <span class="term">Template</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used for Constraints or Scopes.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
			<section id="term-Function">
				<h3>Function</h3>
				<ul>
					<li>A <span class="term">Function</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used in SPARQL queries.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
		</section>
		
		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this specification, including members of the RDF Data Shapes Working Group.
				We especially thank the following:
			</p>
			<p>
				Arnaud Le Hors (chair),
				Iovka Boneva,
				Karen Coyle,
				Richard Cyganiak,
				Michel Dumontier,
				Holger Knublauch,
				Dimitris Kontokostas,
				Jose Labra,
				Peter Patel-Schneider,
				Eric Prud'hommeaux,
				Arthur Ryman (who also served as a co-editor until Feb 2016),
				Harold Solbrig,
				Simon Steyskal,
				Ted Thibodeau
			</p>
		</section>
		
	</body>
</html>
