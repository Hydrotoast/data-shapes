# baseURI: http://www.w3.org/ns/ldom/core

# LDOM - Linked Data Object Model
# Draft Version 0.2.0 (2015-02-11)
# Editor: Holger Knublauch <holger@topquadrant.com>

@prefix ldom: <http://www.w3.org/ns/ldom/core#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .


<http://www.w3.org/ns/ldom/core>
	a ldom:Graph ;
	rdfs:label "LDOM Core Vocabulary" ;
	rdfs:comment "The core vocabulary defining the Linked Data Object Model (LDOM). This vocabulary uses a small subset of RDF, and is otherwise self-describing." ;
.


# LDOM declaration of the required RDFS terms ---------------------------------

rdfs:Resource
	a rdfs:Class ;
	rdfs:label "Resource" ;
	ldom:property [
		ldom:predicate rdf:type ;
		ldom:valueType rdfs:Class ;
		rdfs:label "type" ;
	] ;
.

ldom:Shape
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Shape" ;
	rdfs:comment "The class of shapes." ;
	ldom:property [
		ldom:predicate ldom:constraint ;
		ldom:valueType ldom:Constraint ;
		ldom:defaultValueType ldom:SPARQLConstraint ;    # SPARQLConstraints do not require rdf:type
		rdfs:label "constraint" ;
		rdfs:comment "Defines arbitrary constraints on the matching resources. Use ldom:property for structural property declarations." ;
	] ;
	# TODO: Maybe split ldom:property into ldom:attribute and ldom:relation?
	#       This may create a cleaner distinction between datatype and "object" values
	#       e.g. to specify that only attributes can be primary keys and have XSD facets.
	#       OTOH this complicates the mapping from other syntaxes and prevents properties
	#       that can take any node type.
	ldom:property [
		ldom:predicate ldom:property ;
		ldom:valueType ldom:PropertyConstraint ;
		ldom:defaultValueType ldom:PropertyConstraint ;    # PropertyConstraints do not require rdf:type
		rdfs:label "property" ;
		rdfs:comment "Declares that a given property is relevant for matching resources." ;
		# TODO: Decide whether there can be multiple ldom:property values for the same
		#       predicate within the superclass tree.  Currently some algorithms may
		#       assume that, but many people may expect to be able to overload cardinality and
		#       value type, so that the correct algorithm would need to use one of the walk functions
		#       to find the "nearest" matching declaration. 
	] ;
	ldom:property [
		ldom:predicate ldom:inverseProperty ;
		ldom:valueType ldom:PropertyConstraint ;
		ldom:defaultValueType ldom:InversePropertyConstraint ;    # InversePropertyConstraints do not require rdf:type
		rdfs:label "inverse property" ;
		rdfs:comment "Declares that a given incoming reference property is relevant for matching resources." ;
	] ;
	ldom:constraint [ # Also check constraints on untyped ldom:inverseProperty values
		ldom:queryLibraryGraph true ;
		ldom:sparql """
			CONSTRUCT {
				?cv a ldom:Error ;
					ldom:root ?this ;
					ldom:message "Malformed ldom:inverseProperty." ;
					ldom:path ldom:inverseProperty ;
					ldom:value ?prop ;
					ldom:detail ?s .
				?s ?p ?o ;
			}
			WHERE {
				{
					?this ldom:inverseProperty ?prop .
					FILTER (isBlank(?prop) && NOT EXISTS { ?prop a ?any }) .
					BIND (BNODE() AS ?cv) .
				}
				(?prop ldom:InversePropertyConstraint) ldom:constraintViolations (?s ?p ?o) .
			}
			""" ;
	] ;
	ldom:constraint [ # Also check constraints on untyped ldom:property values
		ldom:queryLibraryGraph true ;
		ldom:sparql """
			CONSTRUCT {
				?cv a ldom:Error ;
					ldom:root ?this ;
					ldom:message "Malformed ldom:property." ;
					ldom:path ldom:property ;
					ldom:value ?prop ;
					ldom:detail ?s .
				?s ?p ?o ;
			}
			WHERE {
				{
					?this ldom:property ?prop .
					FILTER (isBlank(?prop) && NOT EXISTS { ?prop a ?any }) .
					BIND (BNODE() AS ?cv) .
				}
				(?prop ldom:PropertyConstraint) ldom:constraintViolations (?s ?p ?o) .
			}
			""" ;
	] ;
.	

rdfs:Class
	a rdfs:Class ;
	rdfs:subClassOf ldom:Shape ;
	rdfs:label "Class" ;
	rdfs:comment "The class of classes." ;
	ldom:property [
		ldom:predicate rdfs:subClassOf ;
		ldom:valueType rdfs:Class ;
		rdfs:label "sub-class of" ;
	] ;
	ldom:property [
		ldom:predicate ldom:abstract ;
		ldom:valueType xsd:boolean ;
		rdfs:label "abstract" ;
		rdfs:comment "True to indicate that this class is not expected to have direct instances." ;
	] ;
	ldom:property [
		ldom:predicate ldom:final ;
		ldom:valueType xsd:boolean ;
		rdfs:label "final" ;
		rdfs:comment "True to indicate that this class is not expected to have subclasses." ;
	] ;
	ldom:property [
		ldom:predicate ldom:private ;
		ldom:valueType xsd:boolean ;
		rdfs:label "private" ;
		rdfs:comment "True to indicate that this class is only meant to be used inside of the graph that it has been defined in. This is often used to discourage instantiation outside of controlled scenarios. User interfaces may hide private classes from selection widgets." ;
	] ;
	ldom:property [
		ldom:predicate ldom:rule ;
		ldom:valueType ldom:Rule ;
		ldom:defaultValueType ldom:SPARQLRule ;    # SPARQLRules do not require rdf:type
		rdfs:label "rule" ;
	] ;
	ldom:constraint [
		ldom:level ldom:Warning ;
		ldom:message "Each named class should have at least one (other) named superclass" ;
		ldom:path rdfs:subClassOf ;
		ldom:sparql """
			ASK {
				FILTER isIRI(?this) .
				FILTER (?this != rdfs:Resource && ?this != rdfs:Literal) .
				FILTER NOT EXISTS {
					?this rdfs:subClassOf ?superClass .
					FILTER (isIRI(?superClass) && ?superClass != ?this)
				}
			}
			""" ;
	] ;
	# TODO: Add ldom:constructor? This could be a pointer to CONSTRUCT templates.
.

rdfs:Datatype
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Class ;
	rdfs:label "Datatype" ;
	rdfs:comment "The class of RDF datatypes." ;
.

rdfs:Literal
	a rdfs:Class ;
	# TODO: Decide whether the following triple is helpful/needed or not:
	rdfs:subClassOf rdfs:Resource ;
	rdfs:comment "The class of literal values, eg. textual strings and integers." ;
    rdfs:label "Literal" ;
.

rdf:Property
	a rdfs:Class ;
	rdfs:subClassOf ldom:Path ;
	rdfs:label "Property" ;
	rdfs:comment "The class of RDF properties." ;
.

# Just a suggestion of commonly used datatypes - more could be added
xsd:boolean a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "boolean" .
xsd:date a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "date" .
xsd:dateTime a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "dateTime" .
xsd:decimal a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "decimal" .
xsd:float a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "float" .  # Needed?
xsd:integer a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "integer" .
xsd:string a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "string" .
xsd:time a rdfs:Datatype ; rdfs:subClassOf rdfs:Resource ; rdfs:label "time" .  # Needed?
# TODO: rdf:HTML ?


# Selectors -------------------------------------------------------------------

ldom:ShapeSelector
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Shape selector" ;
	rdfs:comment "Specifies which properties (or more generally: paths) shall be used by the LDOM engine to select shapes." ;
	ldom:property [
		ldom:predicate ldom:shapeExtensionPath ;
		ldom:valueType ldom:Path ;
		rdfs:label "shape extension path" ;
		rdfs:comment "Zero or more paths (properties) that link a shape with more general (parent) shapes." ;
	] ;
	ldom:property [
		ldom:predicate ldom:shapeSelectionPath ;
		ldom:valueType ldom:Path ;
		ldom:minCount 1 ;
		rdfs:label "shape selection path" ;
		rdfs:comment "One or more paths (properties) that link individual resources with the shape(s) that they are expected to match against." ;
	] ;
.

ldom:ClassBasedShapeSelector
	a ldom:ShapeSelector ;
	rdfs:label "Class-based shape selector" ;
	rdfs:comment "Selects shapes based on the traditional RDF datamodel. rdf:type is used to link resources with the shapes they are supposed to match. rdfs:subClassOf is used to link a shape with its more general parent shape. This selector is used by the LDOM system vocabulary itself, e.g. to test LDOM models." ;
	ldom:shapeSelectionPath rdf:type ;
	ldom:shapeExtensionPath rdfs:subClassOf ;
.


# Graph management ------------------------------------------------------------

# There are two dedicated types of graph in LDOM:
# - The Query Graph consists of a domain model plus its ldom:includes (or owl:imports)
# - The Library Graph is the Query Graph plus any graphs referenced via ldom:library.
# The Library Graph is used to look up the definitions of templates and also includes
# the definition of the system vocabulary (such as rdfs:Class itself).
# Constraint checking can be applied in two modes:
# - 'filtered' will skip testing any class definitions and other schema-related things
#   such as making sure that a class or template is well-formed.
# - 'unfiltered' will test everything including the class definitions.
# In unfiltered mode, the full Library graph will be queried at run-time.
# In filtered mode the actual ldom:sparql queries usually only get executed over the
# Query Graphs (to make use of performance optimizations of a SPARQL database.
# The flag ldom:queryLibraryGraph can be used to instruct the engine to query the more
# complete Library Graph instead.  

ldom:Context
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Context" ;
	rdfs:comment "A context is a group of constraint declarations that belong together. The property ldom:context is used to link constraints with their context." ;
	ldom:property [
		ldom:predicate ldom:subContextOf ;
		ldom:valueType ldom:Context ;
		rdfs:label "sub-context of" ;
		rdfs:comment "All constraints defined in a sub-context also apply when the super-context is selected." ;
	] ;
.

ldom:DefaultContext
	a ldom:Context ;
	rdfs:label "Default context" ;
	rdfs:comment "Can be used to identify the default context. This value is implicit if a constraint has no value for ldom:context." ;
.

ldom:Graph
	a rdfs:Class ;
	rdfs:subClassOf ldom:Context ;
	rdfs:label "Graph" ;
	rdfs:comment "A collection of RDF triples identified by a URI. In a Linked Data scenario, a graph should be accessible from its URI via content negotiation in formats such as Turtle and JSON-LD. Graphs can also serve as contexts." ;
	ldom:property [
		ldom:predicate ldom:include ;
		ldom:valueType ldom:Graph ;
		rdfs:label "include" ;
		rdfs:comment "Links a graph with other graphs that shall be included into the query graph over which LDOM constraints and rules are executed. This is a transitive property, i.e. includes of includes are also added." ;
	] ;
	# TODO: clarify whether owl:imports also has a meaning, at least as a SHOULD
	ldom:property [
		ldom:predicate ldom:library ;
		ldom:valueType rdfs:Resource ;
		rdfs:label "library" ;
		rdfs:comment "Links a graph with other (library) graphs that shall be included into the library graph that includes template definitions as well as the metamodel." ;
	] ;
.


# Node type vocabulary --------------------------------------------------------

ldom:NodeType
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Node type" ;
	rdfs:comment "The class of RDF node types such as literals, blank nodes and IRIs. Note that this class only consists of the enumerated 7 instances." ;
	ldom:property [
		ldom:predicate ldom:subNodeType ;
		ldom:valueType ldom:NodeType ;
		rdfs:label "sub node type" ;
		rdfs:comment "Links this NodeType with other NodeTypes that include this. For example, ldom:BlankNodeOrIRI has ldom:subNodeType ldom:IRI." ;  
	] ;
.

ldom:Node
	a ldom:NodeType ;
	rdfs:label "Node" ;
	rdfs:comment "The node type of all RDF nodes, including literals, IRIs and blank nodes.";
	ldom:subNodeType ldom:BlankNodeOrIRI ;
	ldom:subNodeType ldom:BlankNodeOrLiteral ;
	ldom:subNodeType ldom:LiteralOrIRI ;
.

ldom:BlankNodeOrIRI
	a ldom:NodeType ;
	rdfs:label "Blank node or IRI" ;
	rdfs:comment "The node type of all blank nodes and IRIs.";
	ldom:subNodeType ldom:BlankNode ;
	ldom:subNodeType ldom:IRI ;
.

ldom:BlankNodeOrLiteral
	a ldom:NodeType ;
	rdfs:label "Blank node or literal" ;
	rdfs:comment "The node type of all blank nodes and literals.";
	ldom:subNodeType ldom:BlankNode ;
	ldom:subNodeType ldom:Literal ;
.

ldom:LiteralOrIRI
	a ldom:NodeType ;
	rdfs:label "Literal or IRI" ;
	rdfs:comment "The node type of all literals and IRIs.";
	ldom:subNodeType ldom:Literal ;
	ldom:subNodeType ldom:IRI ;
.

ldom:BlankNode
	a ldom:NodeType ;
	rdfs:label "Blank node" ;
	rdfs:comment "The node type of all blank nodes.";
.

ldom:IRI
	a ldom:NodeType ;
	rdfs:label "IRI" ;
	rdfs:comment "The node type of all IRIs.";
.

ldom:Literal
	a ldom:NodeType ;
	rdfs:label "Literal" ;
	rdfs:comment "The node type of all literals.";
.


# Path vocabulary -------------------------------------------------------------

# Paths are used to point from a root resource to specific values, e.g. as info
# created by a constraint violation report.
# Currently the path vocabulary only covers simple one-step paths, because if
# we open up more complex paths then the implementation burden would also increase. 

ldom:Path
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	ldom:abstract true ;
	rdfs:label "Path" ;
	rdfs:comment "Abstract superclass for property paths. If this is a URI, then it is assumes to be an rdf:Property." ;
.

ldom:InversePath
	a rdfs:Class ;
	rdfs:subClassOf ldom:Path ;
	rdfs:label "Inverse path" ;
	rdfs:comment "A path consisting of a backward link from an object to the subject via the given predicate. Engines should be able to handle cases where no rdf:type triple is present, i.e. the ldom:inverse property should be enough to identify ldom:InversePath instances." ;
	ldom:property [
		ldom:predicate ldom:inverse ;
		ldom:valueType rdf:Property ;
		ldom:minCount 1 ;
		ldom:maxCount 1 ;
		rdfs:label "inverse" ;
		rdfs:comment "The property to walk in its inverse direction." ;
		# Future versions may support more general path expressions as in http://www.w3.org/TR/sparql11-query/#propertypaths
	] ;
.

ldom:SequencePath
	a rdfs:Class ;
	rdfs:subClassOf ldom:Path ;
	rdfs:label "Sequence path" ;
	rdfs:comment "A path consisting of two other paths that shall be walked in sequence." ;
	ldom:property [
		ldom:predicate ldom:path1 ;
		ldom:valueType ldom:Path ;
		ldom:minCount 1 ;
		ldom:maxCount 1 ;
		rdfs:label "path 1" ;
		rdfs:comment "The first path segment." ;
	] ; 
	ldom:property [
		ldom:predicate ldom:path2 ;
		ldom:valueType ldom:Path ;
		ldom:minCount 1 ;
		ldom:maxCount 1 ;
		rdfs:label "path 2" ;
		rdfs:comment "The second path segment." ;
	] ; 
.


# Modules meta-model ----------------------------------------------------------

# This is the meta model for Templates and Functions - encapsulated reusable
# queries that can take arguments. 

ldom:Module
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Class ;
	rdfs:label "Module" ;
	rdfs:comment "Abstract superclass of components of a LDOM library, especially Functions and Templates. Modules can take arguments, which are constraints that are different from PropertyConstraints in that they can only have at most one value and can have a default value. Modules may not declare the same predicate in multiple Arguments, to simplify the structural analysis of arguments by a client." ;
	ldom:abstract true;
	ldom:property [
		ldom:predicate ldom:argument ;
		ldom:valueType ldom:Argument ;
		ldom:defaultValueType ldom:Argument ;    # Arguments do not require rdf:type
		rdfs:label "argument" ;
		rdfs:comment "Declares the argument(s) of this module." ;
	] ;
	ldom:constraint [
		rdfs:comment "The same predicate can only be used once at all Arguments." ;
		ldom:sparql """
			SELECT ?message
			WHERE {
				?this rdfs:subClassOf* ?class1 .
				?class1 ldom:argument ?argument1 .
				?argument1 ldom:predicate ?predicate .
				?this rdfs:subClassOf* ?class2 .
				?class2 ldom:argument ?argument2 .
				FILTER (?argument1 != ?argument2) .
				?argument2 ldom:predicate ?predicate .
				BIND (CONCAT("Duplicate Argument for the same predicate ", ldom:propertyLabel(?predicate, ?this)) AS ?message) .
			}
			""" ;
	] ;
	ldom:constraint [ # Also check constraints on untyped ldom:argument values
		ldom:message "Malformed ldom:argument." ;
		ldom:queryLibraryGraph true ;
		ldom:sparql """
			CONSTRUCT {
				?cv a ldom:Error ;
					ldom:root ?this ;
					ldom:message "Malformed ldom:argument." ;
					ldom:path ldom:argument ;
					ldom:value ?arg ;
					ldom:detail ?s .
				?s ?p ?o ;
			}
			WHERE {
				{
					?this ldom:argument ?arg .
					FILTER (isBlank(?arg) && NOT EXISTS { ?arg a ?any }) .
					BIND (BNODE() AS ?cv) .
				}
				(?arg ldom:Argument) ldom:constraintViolations (?s ?p ?o) .
			}
			""" ;
	] ;
.

ldom:Function
	a rdfs:Class ;
	rdfs:subClassOf ldom:Module ;
	rdfs:label "Function" ;
	rdfs:comment "A module implementing a SPARQL function, backed by a SPARQL ASK or SELECT query." ;
	ldom:property [
		ldom:predicate ldom:cachable ;
		ldom:valueType xsd:boolean ;
		ldom:maxCount 1 ;
		rdfs:label "cachable" ;
		rdfs:comment "True to indicate that this function will always return the same values for the same combination of arguments, regardless of the query graphs. Engines can use this information to cache and reuse previous function calls." ;
	] ;
	ldom:property [
		ldom:predicate ldom:sparql ;
		ldom:valueType xsd:string ;
		ldom:maxCount 1 ;
		rdfs:label "SPARQL" ;
		rdfs:comment "A SPARQL ASK or SELECT query that can reference the supplied arguments." ;
	] ;
	ldom:constraint [
		rdfs:comment "The arguments must be the predicates ldom:arg1, ldom:arg2 etc." ;
		ldom:sparql """
			SELECT ?message
			WHERE {
				?this rdfs:subClassOf* ?class .
				?class ldom:argument/ldom:predicate ?predicate .
				FILTER (!STRSTARTS(str(?predicate), "http://www.w3.org/ns/ldom/core#arg")) .
			}
			""" ;
	] ;
.

ldom:Functions
	a ldom:Function ;
	rdfs:subClassOf rdfs:Resource ;
	ldom:abstract true ;
	rdfs:label "Functions" ;
	rdfs:comment "The recommended abstract superclass for all functions, so that they are grouped together under a common root in class trees etc." ;
.

ldom:Template
	a rdfs:Class ;
	rdfs:subClassOf ldom:Module ;
	rdfs:label "Template" ;
	rdfs:comment "A module that acts as an abstraction of a (reusable) SPARQL query. The query can be parameterized by the supplied arguments." ;
	ldom:abstract true ;
	ldom:property [
		ldom:predicate ldom:labelTemplate ;
		ldom:valueType xsd:string ;
		rdfs:label "label template" ;
		rdfs:comment "Outlines how human-readable labels of instances of this template class shall be produced. The values must be strings that can contain {?argName} as placeholders for the actual values of the given argument. There may be multiple values, for different languages." ;
		# TODO: Is the syntax of {?varName} sufficient? Often we have conditionals, where some text should appear if a value is present
		#       Could be generalized to a SPARQL expression like SWP does it, e.g. {= IF(...) }
	] ;
.

ldom:Templates
	a ldom:Template ;
	rdfs:subClassOf rdfs:Resource ;
	ldom:abstract true ;
	rdfs:label "Templates" ;
	rdfs:comment "The recommended abstract superclass for all templates, so that they are grouped together under a common root in class trees etc." ;
.

ldom:Profile
	a rdfs:Class ;
	rdfs:subClassOf ldom:Set ;
	rdfs:label "Profile" ;
	rdfs:comment "A profile is a collection of templates. Profiles can be used to group together templates with similar complexity. Tools can indicate that they support specific profiles only." ;
	ldom:property [
		ldom:predicate ldom:member ;
		ldom:valueType ldom:Template ; # Narrowed down to templates only
	] ;
.


# Constraint Violations vocabulary --------------------------------------------

# This vocabulary describes the output of constraint checking, and can either
# be created directly (via CONSTRUCT) or indirectly (via SELECT and ASK).

# TODO: Introduce a mechanism for INFO messages?

ldom:ConstraintViolation
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Constraint violation" ;
	rdfs:comment "Instances of subclasses of this class can be constructed by constraint checks, to flag a single violation." ;
	ldom:abstract true ;
	ldom:property [
		ldom:predicate ldom:detail ;
		ldom:valueType ldom:ConstraintViolation ;
		rdfs:label "detail" ;
		rdfs:comment "Can link a violation with other violation reports that provide more details. This is especially useful to describe violations against nested patterns or shapes." ;
	] ;
	ldom:property [
		ldom:predicate ldom:message ;
		ldom:valueType xsd:string ;
		rdfs:label "message" ;
		rdfs:comment "A human-readable message explaining the cause of the violation. Multiple values are possible assuming they have different languages." ;
	] ;
	ldom:property [
		ldom:predicate ldom:path ;
		ldom:valueType ldom:Path ;
		rdfs:label "path" ;
		rdfs:comment "Zero or more paths that have caused this violation. Paths are assumed to be walkable starting at the provided root." ;
	] ;
	ldom:property [
		ldom:predicate ldom:root ;
		ldom:valueType rdfs:Resource ;
		ldom:maxCount 1 ;
		rdfs:label "root" ;
		rdfs:comment "The root resource of the violation (often: ?this)." ;
	] ;
	ldom:property [
		ldom:predicate ldom:source ;
		ldom:valueType ldom:Constraint ;
		rdfs:label "source" ;
		rdfs:comment "The Constraint that caused this. This property gets filled in automatically by the constraint checking engine." ;
	] ;
	ldom:property [
		ldom:predicate ldom:value ;
		rdfs:label "value" ;
		rdfs:comment "The actual value(s) responsible for the violation." ;
	] ;
.

ldom:Warning
	a rdfs:Class ;
	rdfs:subClassOf ldom:ConstraintViolation ;
	rdfs:label "Warning" ;
	rdfs:comment "A non-critical constraint violation indicating a warning." ; 
.

ldom:Error
	a rdfs:Class ;
	rdfs:subClassOf ldom:ConstraintViolation ;
	rdfs:label "Error" ;
	rdfs:comment "A constraint violation indicating an error." ; 
.

ldom:FatalError
	a rdfs:Class ;
	rdfs:subClassOf ldom:Error ;
	rdfs:label "Fatal Error" ;
	rdfs:comment "An error that cannot be recovered and further evaluation may terminate immediately. Engines may decide to perform fatal checks first." ;
.


# Constraint vocabulary -------------------------------------------------------

ldom:Constraint
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Constraint" ;
	rdfs:comment "An abstract superclass of constraints. Constraints are either template calls or \"native\" constraints with an executable query." ;
	ldom:abstract true ;
	ldom:property [
		ldom:predicate ldom:context ;
		ldom:valueType ldom:Context ;
		rdfs:label "context" ;
		rdfs:comment "Links a constraint with zero or more ldom:Contexts that define the scope of validation. Applications can trigger the constraint checking with specific contexts only. Constraints that have no context apply by default (equivalent to ldom:DefaultContext)." ;
	] ;
.

ldom:GlobalConstraint
	a rdfs:Class ;
	rdfs:subClassOf ldom:Constraint ;
	rdfs:label "Global constraint" ;
	rdfs:comment "The type of constraints that are used 'globally' for the whole graph and not just specific instances. In contrast to other constraints, the variable ?this has no special meaning in global constraints (and should not be used). This class can only be used as a type in conjunction with other types, e.g. it needs to be mixed with ldom:SPARQLConstraint. Instances of this constraint type are typically URI resources." ;
. 

# TODO: Maybe this should be called ldom:NativeConstraint? Do we plan to support other languages than SPARQL?
#       If yes then ldom:NativeConstraint could be a superclass of this.
ldom:SPARQLConstraint
	a rdfs:Class ;
	rdfs:subClassOf ldom:Constraint ;
	rdfs:label "SPARQL constraint" ;
	rdfs:comment "A constraint that has an executable SPARQL query attached with it, with ldom:sparql." ;
	ldom:property [
		ldom:predicate ldom:sparql ;
		ldom:valueType xsd:string ;
		ldom:maxCount 1 ;
		ldom:minCount 1 ;
		rdfs:label "SPARQL" ;
		rdfs:comment "The SPARQL ASK, CONSTRUCT or SELECT query to execute. ASK queries must return false if the constraint fails for a given resource ?this. SELECT queries may return the variables ?root, ?level, ?message, ?path and ?value for each constraint violation that shall be reported. CONSTRUCT queries must produce complete instances of ldom:Error etc." ;
	] ;
	ldom:property [
		ldom:predicate ldom:level ;
		ldom:maxCount 1 ;
		ldom:valueType rdfs:Class ;
		rdfs:label "level" ;
		rdfs:comment "Specifies the default rdf:type to produce for any constraint violation (with ASK or SELECT queries)." ;
	] ;
	ldom:property [
		ldom:predicate ldom:message ;
		ldom:valueType xsd:string ;
		rdfs:label "message" ;
		rdfs:comment "Specifies the default ldom:message(s) to produce for any constraint violation (with ASK or SELECT queries). May have multiple values for different languages." ;
	] ;
	ldom:property [
		ldom:predicate ldom:path ;
		ldom:maxCount 1 ;
		ldom:valueType ldom:Path ;
		rdfs:label "path" ;
		rdfs:comment "Specifies the default ldom:path to produce for any constraint violation (with ASK or SELECT queries)." ;
	] ;
	ldom:property [
		ldom:predicate ldom:queryLibraryGraph ;
		ldom:maxCount 1 ;
		ldom:valueType xsd:boolean ;
		rdfs:label "query library graph" ;
		rdfs:comment "If true then the query needs to be executed over the library graph, i.e. the triples of the constraint definitions and ldom:library need to be visible." ;
	] ;
	ldom:property [
		ldom:predicate rdfs:comment ;
		ldom:valueType xsd:string ;
		rdfs:label "comment" ;
		rdfs:comment "A human-readable explanation of this constraint. May have multiple values for different languages." ;
	] ;
.

ldom:ConstraintTemplate
	a rdfs:Class ;
	rdfs:subClassOf ldom:Template ;
	rdfs:label "Constraint template" ;
	rdfs:comment "A template backed by a SPARQL query that is used for constraint checking." ;
	ldom:property [
		ldom:predicate ldom:sparql ;
		ldom:valueType xsd:string ;
		ldom:maxCount 1 ;   # minCount is 0 because there may be abstract templates
		rdfs:label "SPARQL" ;
		rdfs:comment "The SPARQL CONSTRUCT or ASK queries to execute." ;
	] ;
	ldom:property [
		ldom:predicate ldom:queryLibraryGraph ;
		ldom:maxCount 1 ;
		ldom:valueType xsd:boolean ;
		rdfs:label "query library graph" ;
		rdfs:comment "If true then the associated query needs to be executed over the library graph, i.e. the triples of the constraint definitions and ldom:library need to be visible." ;
	] ;
.

# TODO: This name is easy to confuse with ldom:ConstraintTemplate
ldom:TemplateConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:Templates ;
	rdfs:subClassOf ldom:Constraint ;
	rdfs:label "Template constraint" ;
	rdfs:comment "A constraint that is instantiating a template." ;
	ldom:abstract true ;
.


# Property templating sub-system ----------------------------------------------

# The following templates cover frequently needed data modeling patterns.
# They have in common that they are about one specific rdf:Property (predicate).
# These templates are part of the core standard so that engines may decide to
# hard-code them without requiring a full SPARQL implementation.

# Note that most of these templates (those that can be used to provide user
# interfaces with structural information) are to be used via ldom:property.
# Some templates (ldom:ShapeConstraint) are meant to be used via ldom:constraint,
# because they describe additional conditions that can be verified but that may
# be hard to make sense of from a static point of view.

ldom:AbstractPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:TemplateConstraint ;
	rdfs:label "Abstract property constraint" ;
	rdfs:comment "Shared superclass for templates that take a predicate as one of their arguments." ;
	ldom:abstract true ;
	ldom:argument [
		ldom:predicate ldom:predicate ;
		ldom:valueType rdf:Property ;
		rdfs:label "predicate" ;
		rdfs:comment "The Property being constrained." ;
	] ;
	ldom:property [
		ldom:predicate rdfs:label ;
		ldom:valueType xsd:string ;
		rdfs:label "label" ;
		rdfs:comment "A display label for input forms etc. By default, the global rdfs:label of the predicate should be used. Multiple values (for different languages) are supported." ;
	] ;
	ldom:property [
		ldom:predicate rdfs:comment ;
		ldom:valueType xsd:string ;
		rdfs:label "comment" ;
		rdfs:comment "A description of the role of the predicate to users. Multiple values (for different languages) are supported." ;
	] ;
.

# Arguments -------------------------------------------------------------------

ldom:AbstractArgumentValueTypeConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract argument value type constraint" ;
	rdfs:comment "Enforces a constraint that the value of an argument must be of a certain type. For resources this will accept instances of subclasses. For literals this will accept strings with language tags instead of xsd:string." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:valueType ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Class ;
		rdfs:label "value type" ;
		rdfs:comment "The type that all values of the property must have, based on the semantics defined by the function ldom:hasType." ;
	] ;
	ldom:constraint [
		ldom:message "The values of ldom:valueType cannot be blank nodes." ;
		ldom:sparql """
			ASK WHERE {
				?this ldom:valueType ?valueType .
				FILTER isBlank(?valueType) .
			}
			""" ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (!ldom:hasType(?value, ?valueType)) .
			BIND (CONCAT("Value ", ldom:label(?value), " at argument ", ldom:propertyLabel(?predicate, ?this), " does not have type ", ldom:label(?valueType)) AS ?message)
		}
		""" ;
.

ldom:AbstractOptionalArgumentConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract optional argument constraint" ;
	rdfs:comment "Enforces a constraint that a non-optional argument must have a value, similar to minCount = 1, unless it has been declared optional, or a ldom:defaultValue exists." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:defaultValue ;
		ldom:optional true;
		rdfs:label "default value" ;
		rdfs:comment "The default value of this argument, to be used if no other value has been specified." ;
	] ;  
	ldom:argument [
		ldom:predicate ldom:optional ;
		ldom:defaultValue false ;
		ldom:valueType xsd:boolean ;
		rdfs:label "optional" ;
		rdfs:comment "True to indicate that the property does not require a value. By default, the value is required." ;
	] ;  
	ldom:argument [
		ldom:predicate ldom:optionalWhenInherited ;
		ldom:defaultValue false ;
		ldom:valueType xsd:boolean ;
		rdfs:label "optional when inherited" ;
		rdfs:comment "True to indicate that the property does not require a value when used by a subclass template. If set to true, then instances of subclasses do not need to fill in all required arguments - incomplete templates will simply not be executed. By default, the value is required." ;
	] ;  
	ldom:sparql """
		CONSTRUCT {
			_:error a ldom:Error ;
				ldom:message "Missing value for required argument." ;
				ldom:root ?this ;
				ldom:path ?predicate .
		}
		WHERE {
			FILTER (!bound(?defaultValue) && !?optional && !?optionalWhenInherited && NOT EXISTS { ?this ?predicate ?any }) .
		}
		""" ;
.

ldom:Argument
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractOptionalArgumentConstraint ;
	rdfs:subClassOf ldom:AbstractArgumentValueTypeConstraint ;
	rdfs:label "Argument" ;
	rdfs:comment "Declares an argument that gets mapped to a variable in the parameterized SPARQL query." ;
	ldom:labelTemplate "Argument {?predicate} : {?valueType}" ;
	ldom:constraint [
		ldom:message "Arguments cannot have more than one value." ;
		ldom:sparql """
			SELECT (?predicate AS ?path) (?this as ?root)
			WHERE {
				?this ?predicate ?value1 .
				?this ?predicate ?value2 .
				FILTER (?value1 != ?value2) .
			}
			""" ;
	] ;
.

# Property constraints --------------------------------------------------------

ldom:AbstractAllowedValuesPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract allowed values property constraint" ;
	rdfs:comment "Specifies the allowed values for a property by pointing to a Set of nodes." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:allowedValues ;
		ldom:optionalWhenInherited true ;
		ldom:valueType ldom:Set ;
		rdfs:label "allowed values" ;
		rdfs:comment "The ldom:Set containing the allowed values of the property." ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value ;
			FILTER NOT EXISTS { ?allowedValues ldom:member ?value }
			BIND (CONCAT("Value ", ldom:label(?value), " is not member of the set of allowed values ", ldom:label(?allowedValues)) AS ?message) .
		}
		""" ;
.

ldom:AbstractCountPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract count property constraint" ;
	rdfs:comment "Enforces a constraint on the cardinality of the property using minCount and maxCount. By default, a property may have 0 to unlimited number of values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:minCount ;
		ldom:defaultValue 0 ;
		ldom:optional true ;
		ldom:valueType xsd:integer ;
		rdfs:label "min count" ;
		rdfs:comment "The minimum number of values that the property must have. Defaults to 0." ;
	] ;  
	ldom:argument [
		ldom:predicate ldom:maxCount ;
		ldom:optional true ;
		ldom:valueType xsd:integer ;
		rdfs:label "max count" ;
		rdfs:comment "The maximum number of values that the property must have. Defaults to unlimited." ;
	] ;
	ldom:sparql """
		CONSTRUCT {
			_:error a ldom:Error ;
				ldom:message ?message ;
				ldom:root ?this ;
				ldom:path ?predicate .
		}
		WHERE {
			BIND (ldom:valueCount(?this, ?predicate) AS ?count) .
			FILTER ((?count < ?minCount) || (bound(?maxCount) && (?count > ?maxCount))) .
			BIND (CONCAT("Property ", ldom:propertyLabel(?predicate, ?this), 
					" does not match specified count of [", xsd:string(?minCount), "..", 
					IF(bound(?maxCount), xsd:string(?maxCount), "*"), "]") AS ?message) .
		}
		""" ;
.

ldom:AbstractHasValuePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract has value property constraint" ;
	rdfs:comment "Specifies that the given property must have the specified value (it may also have others)." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:hasValue ;
		ldom:optionalWhenInherited true ;
		rdfs:label "has value" ;
		rdfs:comment "The required value of the property." ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			FILTER NOT EXISTS { ?this ?predicate ?hasValue }
			BIND (CONCAT("Missing required value ", ldom:label(?hasValue)) AS ?message) .
		}
		""" ;
.

ldom:AbstractNodeTypePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract node type property constraint" ;
	rdfs:comment "Specifies the valid node type of a property." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:nodeType ;
		ldom:optionalWhenInherited true ;
		ldom:valueType ldom:NodeType ;
		rdfs:label "node type" ;
		rdfs:comment "The node type that all values of the property must be of." ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value ;
			FILTER (!ldom:hasNodeType(?value, ?nodeType)) .
			BIND (CONCAT("Value ", ldom:label(?value), " does not have the required node type ", ldom:label(?nodeType)) AS ?message) .
		}
		""" ;
.

ldom:AbstractValueTypePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract value type property constraint" ;
	rdfs:comment "Enforces a constraint that all values of the property must be of a certain type. For resources this will accept instances of subclasses. Untyped blank nodes are allowed if a defaultValueType has been specified. For literals this will accept strings with language tags instead of xsd:string." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		# TODO: Maybe this is not needed and we just hard-code the three use cases of this property into the SPARQL query below
		ldom:predicate ldom:defaultValueType ;
		ldom:optional true ;
		ldom:valueType rdfs:Class ;
		rdfs:label "default value type" ;
		rdfs:comment "If specified then blank nodes that have no rdf:type pass this constraint check. The type of those resources is assumed to be ?defaultValueType." ;
	] ;  
	ldom:argument [
		ldom:predicate ldom:valueType ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Class ;
		rdfs:label "value type" ;
		rdfs:comment "The type that all values of the property must have, based on the semantics defined by the function ldom:hasType." ;
	] ;
	ldom:constraint [
		ldom:message "The values of ldom:valueType cannot be blank nodes." ;
		ldom:sparql """
			ASK WHERE {
				?this ldom:valueType ?valueType .
				FILTER isBlank(?valueType) .
			}
			""" ;
	] ;
	ldom:sparql """
		CONSTRUCT {
			_:error a ldom:Error ;
				ldom:message ?message ;
				ldom:root ?this ;
				ldom:path ?predicate ;
				ldom:value ?value ;
		}
		WHERE {
			?this ?predicate ?value .
			FILTER (!ldom:hasType(?value, ?valueType)) .
			FILTER (!bound(?defaultValueType) || !isBlank(?value) || EXISTS { ?value a ?anyType }) .
			BIND (CONCAT("Value ", ldom:label(?value), " at property ",
					ldom:propertyLabel(?predicate, ?this), " does not have type ", 
					ldom:label(?valueType)) AS ?message)
		}
		""" ;
.


ldom:PrimaryKeyPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:PropertyConstraint ;
	rdfs:label "Primary key property constraint" ;
	rdfs:comment "Specifies that the given property is a primary key for instances of the associated class (and its subclasses). If a property has been declared to be the primary key then each instance of the class must have exactly one value for that property. Furthermore, the URIs of those instances must start with a given string (ldom:uriStart), followed by the URL-encoded primary key value. For example if ?uriStart is 'http://example.org/country-' and the primary key for an instance is 'de' then the URI must be 'http://example.org/country-de'. Finally, as a result of the URI policy, there can not be any other instance with the same value under the same primary key policy." ;
	ldom:labelTemplate "Primary Key Property {?predicate} : {?valueType} [{?minCount}..{?maxCount}] URIs start with {?uriStart}" ;
	ldom:argument [
		ldom:predicate ldom:uriStart ;
		ldom:valueType xsd:string ;
		rdfs:label "URI start" ;
		rdfs:comment "The start of URIs, e.g. 'http://example.org/country-'." ; 
		# TODO: Or allow uriTemplate as in https://tools.ietf.org/html/rfc6570 http://example.org/county-{id}
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			{
				FILTER NOT EXISTS {
					?this ?predicate ?any .
				} .
				BIND ("Missing value for primary key property" AS ?label) .
			}
			UNION
			{
				FILTER (ldom:valueCount(?this, ?predicate) > 1) .
				BIND ("Multiple values of primary key property" AS ?label) .
			}
			UNION
			{
				FILTER (ldom:valueCount(?this, ?predicate) = 1) .
				?this ?predicate ?value .
				BIND (CONCAT(?uriStart, ENCODE_FOR_URI(xsd:string(?value))) AS ?uri) .
				FILTER (xsd:string(?this) != ?uri) .
				BIND (CONCAT("Primary key value ", xsd:string(?value),
						" does not align with the expected URI ", ?uri) AS ?label) .
			} .
		}
		""" ;
.	

ldom:PropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractAllowedValuesPropertyConstraint ;
	rdfs:subClassOf ldom:AbstractCountPropertyConstraint ;
	rdfs:subClassOf ldom:AbstractHasValuePropertyConstraint ;
	rdfs:subClassOf ldom:AbstractLengthPropertyConstraint ;
	rdfs:subClassOf ldom:AbstractMaxExclusivePropertyConstraint ;
	rdfs:subClassOf ldom:AbstractMaxLengthPropertyConstraint ;
	rdfs:subClassOf ldom:AbstractMaxInclusivePropertyConstraint ;
	rdfs:subClassOf ldom:AbstractMinExclusivePropertyConstraint ;
	rdfs:subClassOf ldom:AbstractMinLengthPropertyConstraint ;
	rdfs:subClassOf ldom:AbstractMinInclusivePropertyConstraint ;
	rdfs:subClassOf ldom:AbstractNodeTypePropertyConstraint ;
	rdfs:subClassOf ldom:AbstractPatternPropertyConstraint ;
	rdfs:subClassOf ldom:AbstractValueTypePropertyConstraint ;
	rdfs:label "Property constraint" ;
	rdfs:comment "Declares the structural constraints for a property at the associated class. The supported arguments are inherited from the superclasses." ;
	ldom:labelTemplate "Property {?predicate} : {?valueType} [{?minCount}..{?maxCount}]" ;
	ldom:property [
		ldom:predicate ldom:defaultValue ;
		ldom:maxCount 1 ;
		rdfs:label "default value" ;
		rdfs:comment "A default value that could be used to pre-populate input forms etc. This has no formal meaning otherwise." ;
	] ;
	
	# TODO: Enforce constraint that valueType must be a datatype (possibly only comparable ones)
	#       if min/max values are used
	
	# TODO: Additional property suggested by http://schema.org/PropertyValueSpecification
	#       stepValue
	
	# TODO: XML Schema also has facets for:
	#       whiteSpace, fractionDigits and totalDigits
.

ldom:Set
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Set" ;
	rdfs:comment "Defines a set of nodes, for example to enumerate the allowed values of a property." ;
	ldom:property [
		ldom:predicate ldom:member ;
		rdfs:label "member" ;
		rdfs:comment "A member node of the Set." ;
	] ;
	# TODO: Maybe add sub-set property?
.

# Datatype property constraints -----------------------------------------------

ldom:AbstractDatatypePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract datatype property constraint" ;
	rdfs:comment "Abstract base class for datatype-related constraints." ;
	ldom:abstract true ;
	ldom:private true ;
.

ldom:AbstractLengthPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract length property constraint" ;
	rdfs:comment "Specifies the exact length of literal values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:length ;
		ldom:optionalWhenInherited true ;
		ldom:valueType xsd:integer ;
		rdfs:label "length" ;
		rdfs:comment "The length permitted for values of this property." ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (STRLEN(str(?value)) != ?length) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must be ", str(?length),
					" characters long, but found a value with ", STRLEN(str(?value)),
					" characters: ", str(?value)) AS ?message) .
		} 
		""" ;
.

ldom:AbstractMaxLengthPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract max length property constraint" ;
	rdfs:comment "Specifies the max length of literal values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:maxLength ;
		ldom:optionalWhenInherited true ;
		ldom:valueType xsd:integer ;
		rdfs:label "max length" ;
		rdfs:comment "The max length permitted for values of this property." ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (STRLEN(str(?value)) > ?maxLength) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must be at most ", str(?length),
					" characters long, but found a value with ", STRLEN(str(?value)),
					" characters: ", str(?value)) AS ?message) .
		} 
		""" ;
.

ldom:AbstractMinLengthPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract min length property constraint" ;
	rdfs:comment "Specifies the min length of literal values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:minLength ;
		ldom:optionalWhenInherited true ;
		ldom:valueType xsd:integer ;
		rdfs:label "min length" ;
		rdfs:comment "The min length permitted for values of this property." ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (STRLEN(str(?value)) < ?minLength) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must be at least ", str(?length),
					" characters long, but found a value with ", STRLEN(str(?value)),
					" characters: ", str(?value)) AS ?message) .
		} 
		""" ;
.

ldom:AbstractMaxExclusivePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract max exclusive property constraint" ;
	rdfs:comment "Specifies an (exclusive) maximum value for literal values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:maxExclusive ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Literal ;
		rdfs:label "max exclusive" ;
		rdfs:comment "The exclusive maximum value permitted for this property: ?value < ?maxExclusive" ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (?value >= ?maxExclusive) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must be less than ", ldom:label(?maxExclusive),
					" but found ", ldom:label(?value)) AS ?message) .
		} 
		""" ;
.

ldom:AbstractMaxInclusivePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract max inclusive property constraint" ;
	rdfs:comment "Specifies an (inclusive) maximum value for literal values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:maxInclusive ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Literal ;
		rdfs:label "max inclusive" ;
		rdfs:comment "The inclusive maximum value permitted for this property: ?value <= ?maxInclusive" ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (?value > ?maxInclusive) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must be less than or equal to ", ldom:label(?maxInclusive),
					" but found ", ldom:label(?value)) AS ?message) .
		} 
		""" ;
.

ldom:AbstractMinExclusivePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract min exclusive property constraint" ;
	rdfs:comment "Specifies an (exclusive) minimum value for literal values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:minExclusive ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Literal ;
		rdfs:label "min exclusive" ;
		rdfs:comment "The exclusive minimum value permitted for this property: ?value > ?minInclusive" ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (?value <= ?minInclusive) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must be greater than ", ldom:label(?minExclusive),
					" but found ", ldom:label(?value)) AS ?message) .
		} 
		""" ;
.

ldom:AbstractMinInclusivePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract min inclusive property constraint" ;
	rdfs:comment "Specifies an (inclusive) minimum value for literal values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:minInclusive ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Literal ;
		rdfs:label "min inclusive" ;
		rdfs:comment "The inclusive minimum value permitted for this property: ?value >= ?minInclusive" ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (?value < ?minInclusive) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must be greater than or equal to ", ldom:label(?minInclusive),
					" but found ", ldom:label(?value)) AS ?message) .
		} 
		""" ;
.

ldom:AbstractPatternPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractDatatypePropertyConstraint ;
	rdfs:label "Abstract pattern property constraint" ;
	rdfs:comment "Specifies a regular expression that all values of the property need to match." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:pattern ;
		ldom:optionalWhenInherited true ;
		ldom:valueType xsd:string ;
		rdfs:label "pattern" ;
		rdfs:comment "The (regular expression) pattern for values of this property." ;
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?value ?message
		WHERE {
			?this ?predicate ?value .
			FILTER (!regex(str(?value), ?pattern)) .
			BIND (CONCAT("The values of ", ldom:propertyLabel(?predicate, ?this),
					" must match the pattern ", str(?pattern),
					" but found: ", str(?value)) AS ?message) .
		} 
		""" ;
.


# Inverse property constraints ------------------------------------------------

ldom:AbstractCountInversePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract count inverse property constraint" ;
	rdfs:comment "Enforces a constraint on the cardinality of an incoming property using minCount and maxCount. By default, an inverse property may have 0 to unlimited number of values." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:minCount ;
		ldom:defaultValue 0 ;
		ldom:optional true ;
		ldom:valueType xsd:integer ;
		rdfs:label "min count" ;
		rdfs:comment "The minimum number of values that the inverse property must have. Defaults to 0." ;
	] ;  
	ldom:argument [
		ldom:predicate ldom:maxCount ;
		ldom:optional true ;
		ldom:valueType xsd:integer ;
		rdfs:label "max count" ;
		rdfs:comment "The maximum number of values that the inverse property must have. Defaults to unlimited." ;
	] ;
	ldom:sparql """
		CONSTRUCT {
			_:error a ldom:Error ;
				ldom:message ?message ;
				ldom:root ?this ;
				ldom:path _:path .
			_:path ldom:inverse	?predicate
		}
		WHERE {
			BIND (ldom:inverseValueCount(?this, ?predicate) AS ?count) .
			FILTER ((?count < ?minCount) || (bound(?maxCount) && (?count > ?maxCount))) .
			BIND (CONCAT("Inverse property ", ldom:inversePropertyLabel(?predicate, ?this), 
					" does not match specified count of [", xsd:string(?minCount), "..", 
					IF(bound(?maxCount), xsd:string(?maxCount), "*"), "]") AS ?message) .
		}
		""" ;
.

ldom:AbstractValueTypeInversePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract value type inverse property constraint" ;
	rdfs:comment "Enforces a constraint that all incoming values of the property must be of a certain type. This will accept instances of subclasses.." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:valueType ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Class ;
		rdfs:label "value type" ;
		rdfs:comment "The type that all values of the inverse property must have, based on the semantics defined by the function ldom:hasType." ;
	] ;
	ldom:constraint [
		ldom:message "The values of ldom:valueType cannot be blank nodes." ;
		ldom:sparql """
			ASK WHERE {
				?this ldom:valueType ?valueType .
				FILTER isBlank(?valueType) .
			}
			""" ;
	] ;
	ldom:sparql """
		CONSTRUCT {
			_:error a ldom:Error ;
				ldom:message ?message ;
				ldom:root ?this ;
				ldom:value ?value ;
				ldom:path _:path .
			_:path ldom:inverse	?predicate
		}
		WHERE {
			?value ?predicate ?this .
			FILTER (!ldom:hasType(?value, ?valueType)) .
			BIND (CONCAT("Inverse value ", ldom:label(?value), " at property ",
					ldom:propertyLabel(?predicate, ?this), " does not have type ", 
					ldom:label(?valueType)) AS ?message)
		}
		""" ;
.

ldom:InversePropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractCountInversePropertyConstraint ;
	rdfs:subClassOf ldom:AbstractValueTypeInversePropertyConstraint ;
	rdfs:label "Inverse property constraint" ;
	rdfs:comment "Declares the structural constraints for an incoming property at the associated class. The supported arguments are inherited from the superclasses." ;
	ldom:labelTemplate "Inverse property {?predicate} : {?valueType} [{?minCount}..{?maxCount}]" ;
.

ldom:AbstractAllShapeConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract all shape constraint" ;
	rdfs:comment "Enforces a constraint that all values of the property must have a certain shape, whereby a shape is a collection of constraints." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:all ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Resource ;
		rdfs:label "all" ;
		rdfs:comment "The shape that the values must have. Shapes are often classes but may also be untyped resources and even blank nodes that have constraints attached to them." ;
	] ;  
	ldom:queryLibraryGraph true ;
	ldom:sparql """
		CONSTRUCT {
			?cv a ldom:Error ;
				ldom:message ?message ;
				ldom:root ?this ;
				ldom:path ?predicate ;
				ldom:value ?value ;
				ldom:detail ?s .
			?s ?p ?o .
		}
		WHERE {
			{
				?this ?predicate ?value .
				BIND (BNODE() AS ?cv) .
			}
            BIND (CONCAT("Value ", ldom:label(?value), " at property ", ldom:propertyLabel(?predicate, ?this),
            		" does not fulfill the constraints of shape ", ldom:label(?all)) AS ?message)
			(?value ?all) ldom:constraintViolations (?s ?p ?o) .
		}
		""" ;
.

ldom:AbstractSomeShapeConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractPropertyConstraint ;
	rdfs:label "Abstract some shape constraint" ;
	rdfs:comment "Enforces a constraint that at least one of the values of the property must have a certain shape, whereby a shape is a collection of constraints." ;
	ldom:abstract true ;
	ldom:private true ;
	ldom:argument [
		ldom:predicate ldom:some ;
		ldom:optionalWhenInherited true ;
		ldom:valueType rdfs:Resource ;
		rdfs:label "some" ;
		rdfs:comment "The shape that the values must have. Shapes are often classes but may also be untyped resources and even blank nodes that have constraints attached to them." ;
	] ;  
	ldom:queryLibraryGraph true ;
	ldom:sparql """
		CONSTRUCT {
			_:error a ldom:Error ;
				ldom:message ?message ;
				ldom:root ?this ;
				ldom:path ?predicate ;
				ldom:value ?value .
		}
		WHERE {
			FILTER NOT EXISTS {
				?this ?predicate ?value .
				FILTER (ldom:hasShape(?value, ?some)) .
			}
            BIND (CONCAT("None of the values of property ", ldom:propertyLabel(?predicate, ?this),
            		" fulfill the constraints of shape ", ldom:label(?some)) AS ?message)
		}
		""" ;
.

ldom:ShapeConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:AbstractAllShapeConstraint ;
	rdfs:subClassOf ldom:AbstractSomeShapeConstraint ;
	ldom:labelTemplate "Shape constraint: All {?all}, Some {?some}" ;
	rdfs:label "Shape constraint" ;
	rdfs:comment "Enforces structural constraints on the shape of the values of the predicate." ;
.

ldom:OrConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:TemplateConstraint ;
	rdfs:label "Or constraint" ;
	rdfs:comment "Enforces a constraint that at least one of the two provided shapes must be valid for the context resource ?this." ;
	ldom:queryLibraryGraph true ;
	ldom:argument [
		ldom:predicate ldom:shape1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:label "shape 1" ;
		rdfs:comment "The class defining the first of the two 'shapes' that must be valid." ; 
	] ;
	ldom:argument [
		ldom:predicate ldom:shape2 ;
		ldom:valueType rdfs:Resource ;
		rdfs:label "shape 2" ;
		rdfs:comment "The class defining the second of the two 'shapes' that must be valid." ; 
	] ;
	ldom:labelTemplate "Or constraint: {?shape1} or {?shape2}" ;
	ldom:message "Violation of OR constraint" ;
	ldom:sparql """
			SELECT (?this AS ?root)
			WHERE {
				FILTER (!ldom:hasShape(?this, ?shape1) && !ldom:hasShape(?this, ?shape2)) .
			}
		""" ;
.

ldom:DerivedPropertyConstraint
	a ldom:ConstraintTemplate ;
	rdfs:subClassOf ldom:PropertyConstraint ;
	rdfs:label "Derived property constraint" ;
	rdfs:comment "Declares the structural constraints for a derived property that has its values computed from a SPARQL expression." ;
	ldom:labelTemplate "Derived property {?predicate} : {?valueType} [{?minCount}..{?maxCount}]" ;
	ldom:argument [
		ldom:predicate ldom:sparql ;
		ldom:valueType xsd:string ;
		rdfs:label "SPARQL" ;
		rdfs:comment "A SPARQL expression, ASK or SELECT query that derives the value that the property must have." ;
		# TODO: Can this produce multiple values (would require a derived property for ldom:eval)?
	] ;
	ldom:sparql """
		SELECT (?this AS ?root) (?predicate AS ?path) ?message ?value
		WHERE {
			BIND (ldom:eval(?sparql, "this", ?this) AS ?expected) .
			?this ?predicate ?value .
			FILTER (!bound(?expected) || ?value != ?expected) .
			BIND (CONCAT("Value ", ldom:label(?value), " of property ", ldom:propertyLabel(?predicate, ?this),
					" does not match expected value ", COALESCE(ldom:label(?expected), '(none)')) AS ?message) . 
		}
		""" ;
.


# Rules vocabulary ------------------------------------------------------------

# TODO: Unfinished, not in the focus of the Shapes WG right now

ldom:Rule
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	rdfs:label "Rule" ;
	rdfs:comment "An abstract superclass of rules - a module with executable semantics. Some rules may be template calls, others may directly have an executable query." ;
	ldom:abstract true ;
	# TODO: Rule ordering is important, e.g. rules may need IDs and be grouped together
.

ldom:SPARQLRule
	a rdfs:Class ;
	rdfs:subClassOf ldom:Rule ;
	rdfs:comment "A rule backed by an executable SPARQL query, via ldom:sparql." ;
	ldom:property [
		ldom:predicate ldom:sparql ;
		ldom:valueType xsd:string ;
		ldom:maxCount 1 ;
		ldom:minCount 1 ;
		rdfs:label "SPARQL" ;
		rdfs:comment "The SPARQL CONSTRUCT query to execute when the rule fires." ;
	] ;
.

ldom:RuleTemplate
	a rdfs:Class ;
	rdfs:subClassOf ldom:Template ;
	ldom:property [
		ldom:predicate ldom:sparql ;
		ldom:valueType xsd:string ;
		ldom:maxCount 1 ;   # minCount is 0 because there may be abstract templates
		rdfs:label "SPARQL" ;
		rdfs:comment "The SPARQL CONSTRUCT query to execute when the rule fires." ;
	] ;
.

ldom:TemplateRule
	a ldom:RuleTemplate ;
	rdfs:subClassOf ldom:Templates ;
	rdfs:subClassOf ldom:Rule ;
	ldom:abstract true ;
.


# Built-in Functions ----------------------------------------------------------

ldom:eval
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "eval" ;
	rdfs:comment "Evaluates a given SPARQL expression, or SPARQL ASK or SELECT query, and returns its result. The first argument is the SPARQL expression string. All other arguments must come in pairs: a variable name and a node. These pairs become pre-bound variables in the evaluated expression." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType xsd:string ;
		rdfs:comment "The SPARQL string." ;
	] ;
.

ldom:hasNodeType
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "has node type" ;
	rdfs:comment "Checks whether a given node (?arg1) has a given ldom:NodeType (?arg2). For example, ldom:hasNodeType(42, ldom:BlankNodeOrLiteral) = true." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		rdfs:comment "The node to check the node type of." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType ldom:NodeType ;
		rdfs:comment "The node type that the node must have." ;
	] ;
	ldom:returnType xsd:boolean ;
	ldom:sparql """
		ASK {
			FILTER (isIRI(?arg1) && (?arg2 IN (ldom:IRI, ldom:BlankNodeOrIRI, ldom:LiteralOrIRI, ldom:Node)) ||
				(isLiteral(?arg1) && (?arg2 IN (ldom:Literal, ldom:BlankNodeOrLiteral, ldom:LiteralOrIRI, ldom:Node))) ||
		 		(isBlank(?arg1) && (?arg2 IN (ldom:BlankNode, ldom:BlankNodeOrLiteral, ldom:BlankNodeOrIRI, ldom:Node))))
		}
		""" ;
.

# TODO: This has incorrect semantics, because an instance (via rdf:type) of xsd:string would still be
#       acceptable even if the valueType is xsd:string (only literals).
#       Options to fix that include splitting ldom:property into ldom:attribute and ldom:relation,
#       and adding another constraint that generally makes reified literals invalid. 
ldom:hasType
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "has type" ;
	rdfs:comment "Checks whether a given node (?arg1) is an instance of a given class (?arg2) or its subclasses. If the type (?arg2) is unbound, then the function will always return true. If arg1 is a literal, then the function will check whether the literal has the given datatype ?arg2. If arg2 is rdfs:Resource then the function returns true if ?arg1 is a IRI or a blank node. If arg2 is rdf:Property then the function returns true if ?arg1 is an untyped IRI." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		rdfs:comment "The node to check the type of." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:optional true ;
		ldom:valueType rdfs:Class ;
		rdfs:comment "The type that the node must have. Can be left empty to allow any node." ;
	] ;
	ldom:returnType xsd:boolean ;
	ldom:sparql """
		ASK {
			{
				# Allow any node if type is unbound
				FILTER (!bound(?arg2)) .
			}
			UNION
			{
				{
					FILTER (isIRI(?arg1) || isBlank(?arg1)) .
				} .
				?class (rdfs:subClassOf)* ?arg2 .
				?arg1 a ?class .
			}
			UNION
			{
				# Allow untyped resources for rdfs:Resource and rdf:Property
				FILTER ((isIRI(?arg1) || isBlank(?arg1)) && (?arg2 = rdfs:Resource || ?arg2 = rdf:Property) && NOT EXISTS { ?arg1 a ?any }) .
			}
			UNION
			{
				{
					FILTER isLiteral(?arg1) .
				} .
				BIND (datatype(?arg1) AS ?datatype) .
				FILTER (((?datatype = ?arg2) || (?arg2 = rdfs:Literal)) || (((!bound(?datatype)) || (rdf:langString = ?datatype)) && (?arg2 = xsd:string))) .
			} .
		}
		""" ;
.

ldom:inversePropertyLabel
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "inverse property label" ;
	rdfs:comment "Gets a human-readable label for a given inverse property (?arg1) in the context of a given resource/instance (?arg2). Attempts to use any rdfs:label locally defined at the types of ?arg2 via ldom:inverseProperty. Falls back to the global ldom:label of the property itself if no local label was found." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdf:Property ;
		rdfs:comment "The (inverse) property to render. For example for ex:child this may produce 'parent'." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The resource/instance providing the context." ;
	] ;
	ldom:returnType xsd:string ;
	ldom:sparql """
		SELECT ?label
		WHERE {
			{
				?arg2 a ?type .
				?type rdfs:subClassOf* ?class .
				?class ldom:inverseProperty ?p .
				?p ldom:predicate ?arg1 .
				?p rdfs:label ?label .
			}
			UNION {
				BIND (CONCAT("(inverse of) ", ldom:label(?arg1)) AS ?label) .
			}	
		}
		""" ;
.

ldom:inverseValueCount
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "inverse value count" ;
	rdfs:comment "Gets the number of values of a given property (?arg2) at a given object (?arg1). The result is the number of matches of (?subject, ?arg2, ?arg1)." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The object resource." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdf:Property ;
		rdfs:comment "The property to get the value count of." ;
	] ;
	ldom:returnType xsd:integer ;
	ldom:sparql """
		SELECT ((COUNT(?subject)) AS ?result)
		WHERE {
			?subject ?arg2 ?arg1 .
		}
		""" ;
.

# TODO: Is this really needed? (Not right now, and we have ldom:eval).
ldom:invoke
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "invoke" ;
	rdfs:comment "Invokes a given SPARQL function (?arg1) with additional parameters (?arg2, ?arg3, ...)." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType ldom:Function ;
		rdfs:comment "The function to invoke." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:optional true ;
		rdfs:comment "The first argument to pass into the function." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg3 ;
		ldom:optional true ;
		rdfs:comment "The second argument to pass into the function." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg4 ;
		ldom:optional true ;
		rdfs:comment "The third argument to pass into the function." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg5 ;
		ldom:optional true ;
		rdfs:comment "The forth argument to pass into the function." ;
	] ;
.

ldom:label
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "label" ;
	rdfs:comment "Gets a human-readable label for a given node, if possible. The exact behavior of this function is left to the engine's implementation, but it typically tries to find an rdfs:label or similar property. If no such label is found, it may fall back to the local name or qname, and finally the URI. If the argument is a literal then this may simply return the lexical form. For blank nodes it should find a suitable rendering, depending on its type." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		rdfs:comment "The node to render." ;
	] ;
	ldom:returnType xsd:string ;
.

ldom:propertyLabel
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "property label" ;
	rdfs:comment "Gets a human-readable label for a given property (?arg1) in the context of a given resource/instance (?arg2). Attempts to use any rdfs:label locally defined at the types of ?arg2 via ldom:property. Falls back to the global ldom:label of the property itself if no local label was found." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdf:Property ;
		rdfs:comment "The property to render." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The resource/instance providing the context." ;
	] ;
	ldom:returnType xsd:string ;
	ldom:sparql """
		SELECT ?label
		WHERE {
			{
				?arg2 a ?type .
				?type rdfs:subClassOf* ?class .
				?class ldom:property|ldom:argument ?p .
				?p ldom:predicate ?arg1 .
				?p rdfs:label ?label .
			}
			UNION {
				BIND (ldom:label(?arg1) AS ?label) .
			}	
		}
		""" ;
.

ldom:propertyValue
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "property value" ;
	rdfs:comment "Gets the 'first' value of a given property (?arg2) at a given subject (?arg1). The behavior is arbitrary if multiple values are present." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The subject resource." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdf:Property ;
		rdfs:comment "The property to get the value of." ;
	] ;
	ldom:sparql """
		SELECT ?object
		WHERE {
			?arg1 ?arg2 ?object .
		}
		""" ;
.

ldom:valueCount
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "value count" ;
	rdfs:comment "Gets the number of values of a given property (?arg2) at a given subject (?arg1). The result is the number of matches of (?arg1, ?arg2, ?object)." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The subject resource." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdf:Property ;
		rdfs:comment "The property to get the value count of." ;
	] ;
	ldom:returnType xsd:integer ;
	ldom:sparql """
		SELECT ((COUNT(?object)) AS ?result)
		WHERE {
			?arg1 ?arg2 ?object .
		}
		""" ;
.

ldom:hasShape
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "has shape" ;
	rdfs:comment "Checks whether a given resource (?arg1) fulfills all constraints defined for a given class (?arg2) or its superclasses. This creates a (possibly recursive) LDOM constraint checker." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The resource to check." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The class (shape) that has the constraints that need to be checked against." ;
	] ;
	ldom:returnType xsd:boolean ;
.

# TODO:
# LDOM engines also need to implement a magic property (aka property function)
# 	(?resource ?shape) ldom:constraintViolations (?s ?p ?o) 
# which takes a resource (instance) and a shape (class) as arguments and
# binds any constraint violation triples with the unbound variables on the right.
# SPARQL 1.1 does not have an official mechanism for such magic properties,
# so this would either need to be added to SPARQL, or instead of a magic property
# we could have a function that returns a (temporary) named graph containing the
# violation triples.

ldom:walkObjects
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "walk objects" ;
	rdfs:comment "Performs a depth-first tree traversal starting at a given node (?arg1) and then following the objects using a given predicate (?arg2). For each node it applies a given function (?arg3) that must take the current node as its first argument. All other arguments of the walkObjects function call will be passed into that function. The traversal stops on the first non-null result of the nested function calls. A use case of this function is to walk up superclasses, e.g. to find the \"nearest\" owl:Restriction of a certain kind." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The resource to start traversal at." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdf:Property ;
		rdfs:comment "The property to traverse (e.g. rdfs:subClassOf to walk up the superclasses)." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg3 ;
		ldom:valueType ldom:Function ;
		rdfs:comment "The function to call for each resource." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg4 ;
		ldom:optional true ;
		rdfs:comment "The second argument to pass into the function." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg5 ;
		ldom:optional true ;
		rdfs:comment "The third argument to pass into the function." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg6 ;
		ldom:optional true ;
		rdfs:comment "The forth argument to pass into the function." ;
	] ;
.

ldom:walkSubjects
	a ldom:Function ;
	rdfs:subClassOf ldom:Functions ;
	rdfs:label "walk subjects" ;
	rdfs:comment "Performs a depth-first tree traversal starting at a given node (?arg1) and then following the subjects using a given predicate (?arg2). For each node it applies a given function (?arg3) that must take the current node as its first argument. All other arguments of the walkSubjects function call will be passed into that function. The traversal stops on the first non-null result of the nested function calls. A use case of this function is to walk down into a SKOS hierarchy." ;
	ldom:argument [
		ldom:predicate ldom:arg1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:comment "The resource to start traversal at." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg2 ;
		ldom:valueType rdf:Property ;
		rdfs:comment "The property to traverse (e.g. rdfs:subClassOf to walk down into the subclasses)." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg3 ;
		ldom:valueType ldom:Function ;
		rdfs:comment "The function to call for each resource." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg4 ;
		ldom:optional true ;
		rdfs:comment "The second argument to pass into the function." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg5 ;
		ldom:optional true ;
		rdfs:comment "The third argument to pass into the function." ;
	] ;
	ldom:argument [
		ldom:predicate ldom:arg6 ;
		ldom:optional true ;
		rdfs:comment "The forth argument to pass into the function." ;
	] ;
.


# Test case framework ---------------------------------------------------------

ldom:TestCase
	a rdfs:Class ;
	rdfs:subClassOf rdfs:Resource ;
	ldom:abstract true ;
	rdfs:label "Test case" ;
	rdfs:comment "Each instances of this class represents a test case, e.g. to formalize the expected behavior of LDOM implementations." ;
	ldom:property [
		ldom:predicate ldom:graph ;
		ldom:maxCount 1 ;
		ldom:minCount 1 ;
		ldom:valueType rdfs:Resource ;
		rdfs:label "graph" ;
		rdfs:comment "The graph that shall be tested." ;
	] ;
.

ldom:ConstraintCheckingTestCase
	a rdfs:Class ;
	rdfs:subClassOf ldom:TestCase ;
	rdfs:label "Constraint checking test case" ;
	rdfs:comment "Superclass for test cases that perform constraint checking." ;
	ldom:abstract true ;
	ldom:property [
		ldom:predicate ldom:ignore ;
		ldom:valueType rdf:Property ;
		rdfs:ignore "ignore" ;
		rdfs:comment "Points at the predicate of triples that shall be ignored during the comparison (e.g., ldom:message)." ;
	] ;
	ldom:property [
		ldom:predicate ldom:violation ;
		ldom:valueType ldom:ConstraintViolation ;
		rdfs:label "violation" ;
		rdfs:comment "The expected constraint violations. An engine needs to perform a graph isomorphism test of all expected violations with the actual violations." ;
	] ;
.

ldom:GraphConstraintCheckingTestCase
	a rdfs:Class ;
	rdfs:subClassOf ldom:ConstraintCheckingTestCase ;
	rdfs:label "Graph test case" ;
	rdfs:comment "Represents a test case that performs constraint checking on a complete graph and asserts that certain constraint violations have been reported." ; 
.

ldom:ResourceConstraintCheckingTestCase
	a rdfs:Class ;
	rdfs:subClassOf ldom:ConstraintCheckingTestCase ;
	rdfs:label "Resource test case" ;
	rdfs:comment "Represents a test case that performs constraint checking on one or more resources and asserts that certain constraint violations have been reported." ; 
	ldom:property [
		ldom:predicate ldom:check ;
		ldom:valueType rdfs:Resource ;
		rdfs:label "check" ;
		rdfs:comment "A resource that shall be tested for constraints violations." ;
	] ;
.


# System Property declarations (mainly for RDF compliance) --------------------

rdf:type
	a rdf:Property ;
	rdfs:label "type" ;
.

rdfs:comment
	a rdf:Property ;
	rdfs:label "comment" ;
.

rdfs:label
	a rdf:Property ;
	rdfs:label "label" ;
.

rdfs:subClassOf
	a rdf:Property ;
	rdfs:label "subClassOf" ;   # Same value as defined in RDF Schema, "sub-class of" may be better
.

ldom:abstract a rdf:Property ; rdfs:label "abstract" .
ldom:all a rdf:Property ; rdfs:label "all" .
ldom:allowedValues a rdf:Property ; rdfs:label "allowed values" .
ldom:arg1 a rdf:Property ; rdfs:label "arg1" .
ldom:arg2 a rdf:Property ; rdfs:label "arg2" .
ldom:arg3 a rdf:Property ; rdfs:label "arg3" .
ldom:arg4 a rdf:Property ; rdfs:label "arg4" .
ldom:arg5 a rdf:Property ; rdfs:label "arg5" .
ldom:arg6 a rdf:Property ; rdfs:label "arg6" .
ldom:arg7 a rdf:Property ; rdfs:label "arg7" .
ldom:arg8 a rdf:Property ; rdfs:label "arg8" .
ldom:arg9 a rdf:Property ; rdfs:label "arg9" .
ldom:argument a rdf:Property ; rdfs:label "argument" .
ldom:cachable a rdf:Property ; rdfs:label "cachable" .
ldom:check a rdf:Property ; rdfs:label "check" .
ldom:checkAll a rdf:Property ; rdfs:label "check all" .
ldom:constraint a rdf:Property ; rdfs:label "constraint" .
ldom:context a rdf:Property ; rdfs:label "context" .
ldom:defaultValue a rdf:Property ; rdfs:label "default value" .
ldom:defaultValueType a rdf:Property ; rdfs:label "default value type" .
ldom:detail a rdf:Property ; rdfs:label "detail" .
ldom:final a rdf:Property ; rdfs:label "final" .
ldom:fractionDigits a rdf:Property ; rdfs:label "fraction digits" .
ldom:graph a rdf:Property ; rdfs:label "graph" .
ldom:ignore a rdf:Property ; rdfs:label "ignore" .
ldom:include a rdf:Property ; rdfs:label "include" .
ldom:inverse a rdf:Property ; rdfs:label "inverse" .
ldom:inverseProperty a rdf:Property ; rdfs:label "inverse property" .
ldom:labelTemplate a rdf:Property ; rdfs:label "label template" .
ldom:length	a rdf:Property ; rdfs:label "length" .
ldom:level a rdf:Property ; rdfs:label "level" .
ldom:library a rdf:Property ; rdfs:label "library" .
ldom:maxCount a rdf:Property ; rdfs:label "max count" .
ldom:maxExclusive a rdf:Property ; rdfs:label "max exclusive" .
ldom:maxLength a rdf:Property ; rdfs:label "max length" .
ldom:maxInclusive a rdf:Property ; rdfs:label "max inclusive" .
ldom:member a rdf:Property ; rdfs:label "member" .
ldom:message a rdf:Property ; rdfs:label "message" .
ldom:minCount a rdf:Property ; rdfs:label "min count" .
ldom:minLength a rdf:Property ; rdfs:label "min length" .
ldom:minExclusive a rdf:Property ; rdfs:label "min exclusive" .
ldom:minInclusive a rdf:Property ; rdfs:label "min inclusive" .
ldom:optional a rdf:Property ; rdfs:label "optional" .
ldom:optionalWhenInherited a rdf:Property ; rdfs:label "optional when inherited" .
ldom:path a rdf:Property ; rdfs:label "path" .
ldom:path1 a rdf:Property ; rdfs:label "path 1" .
ldom:path2 a rdf:Property ; rdfs:label "path 2" .
ldom:pattern a rdf:Property ; rdfs:label "pattern" .
ldom:predicate a rdf:Property ; rdfs:label "predicate" .
ldom:private a rdf:Property ; rdfs:label "private" .
ldom:property a rdf:Property ; rdfs:label "property" .
ldom:queryLibraryGraph a rdf:Property ; rdfs:label "query library graph" .
ldom:returnType a rdf:Property ; rdfs:label "return type" .
ldom:root a rdf:Property ; rdfs:label "root" .
ldom:rule a rdf:Property ; rdfs:label "rule" .
ldom:shapeExtensionPath a rdf:Property ; rdfs:label "shape extension path" .
ldom:shapeSelectionPath a rdf:Property ; rdfs:label "shape selection path" .
ldom:some a rdf:Property ; rdfs:label "some" .
ldom:sparql	a rdf:Property ; rdfs:label "SPARQL" .
ldom:subNodeType a rdf:Property ; rdfs:label "sub node type" .
ldom:subContextOf a rdf:Property ; rdfs:label "sub-context of" .
ldom:totalDigits a rdf:Property ; rdfs:label "total digits" .
ldom:uriStart a rdf:Property ; rdfs:label "URI start" .
ldom:valueType a rdf:Property ; rdfs:label "value type" .
ldom:value a rdf:Property ; rdfs:label "value" .
ldom:violation a rdf:Property ;	rdfs:label "violation" .
ldom:whiteSpace	a rdf:Property ; rdfs:label "whiteSpace" .
