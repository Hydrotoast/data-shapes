<!DOCTYPE html>
<html>
  	<head>
       	<title>SHACL Specification</title>
    	<meta charset='utf-8'>
    	<script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
	    <script class='remove'>
	      var respecConfig = {
	          specStatus: "unofficial",
	          shortName:  "shacl-core",
	          editors: [
		                {   name:       "Holger Knublauch",
		                    url:        "http://knublauch.com/",
		                    company:    "TopQuadrant, Inc.",
		                    companyURL: "http://topquadrant.com/" },
		                {   name:       "Eric Prud'hommeaux",
		                    url:        "http://www.w3.org/People/Eric/",
		                    company:    "W3C/MIT",
		                    companyURL: "http://www.w3.org/" }
	          ],
	          wg:           "RDF Data Shapes Working Group",
	          wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
	          wgPublicList: "public-data-shapes",
	          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
	      };
	    </script>
		<style>
			.todo {
				color: red;
			}
		    pre {
				tab-size: 4;
		    }
			th {
				text-align: left;
			}
			
			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
		</style>  		
  	</head>
  	<body>
    
    	<section id="abstract">
			<p class="todo">
				TODO
	  		</p>
		</section>
    
    	<section id="introduction">
      		<h2>Introduction</h2>
			<p class="todo">
				TODO
	  		</p>
	  		
	  		<section>
	  			<h3>What are Shapes and Constraints</h3>
	  			<!--
	  				(HK) Eric, I have taken your prose from your primer but renamed "target node" to
	  				"current node". What do you think? To me it seems to make sense to call this the
	  				current node because the predicate (or any path) is evaluated starting from there,
	  				not ending there (as "target" would imply).
	  				
	  				I have also generalized "property constraint" into "constraint", because there can
	  				be complex conditions that do not just check one property (e.g. width and height). 
	  			-->
        		<p>
					A <code>shape</code> describes the triples coming into and out of the <code>current node</code> in an RDF graph.
					A shape has <code>constraints</code> attached to it which describe the <code>current node</code>'s triples.
					Some of these <code>constraints</code> can be about a specific property only, these are called
					<code>property constraints</code>.
					A <code>property constraint</code> for a triple with the <code>current node</code> as a subject is attached to the <code>shape</code> via <span class="type">sh:</span><span class="constant">property</span>;
					a <code>property constraint</code> for a triple with the <code>current node</code> as a object is attached to the <code>shape</code> via <span class="type">sh:</span><span class="constant">inverseProperty</span>.
				</p>
	  		</section>
	  		
	  		<section>
	  			<h3>What can you do with Shapes (overview of supported operations)</h3>
	  		</section>
	  		
	  		<section>
	  			<h3>How Shapes work (Macros/Templates, SPARQL and other executable languages)</h3>
	  		</section>
    	</section>
    	
    	<section>
			<h2>Constraint Violations Vocabulary</h2>
			<section>
				<h3>Types of Constraints (Error, Warning etc)</h3>
			</section>
			<section>
				<h3>sh:root, sh:path, sh:value</h3>
				<div>Probably put path vocabulary here: sh:Path, sh:InversePath, sh:SequencePath</div>
			</section>
			<section>
				<h3>sh:message</h3>
			</section>
    	</section>
    	
    	<section>
    		<h2>Global Constraints</h2>
    		<p>
				This section is here to introduce how constraints are written in general, e.g. based on a SPARQL query.
    		</p>
    	</section>
    	
    	<section>
    		<h2>General Structure of Shapes</h2>
    		<p>
    			Shapes are instances of sh:Shape (and/or rdfs:Class?).
    		</p>
    		<div class="issue">
    			There is no agreement in the WG on the relationship of sh:Shape with RDFS classes.
    			Proposals include:
    			<ul>
    				<li>Keep them completely separate, users only instantiate sh:Shape and use sh:extends</li>
    				<li>Have rdfs:Class rdfs:subClassOf sh:Shape, use either sh:extends or rdfs:subClassOf</li>
    				<li>Have sh:Shape rdfs:subClassOf rdfs:Class, use rdfs:subClassOf</li>
    				<li>Allow both approaches in parallel: either rdfs:Class/subClassOf or sh:Shape/extends</li>
    				<li>Allow both and have sh:classShape to point from a class to its shape(s)</li>
    			</ul>
    		</div>
    		<section>
    			<h3>Shape metadata</h3>
    			<p>
    				Labels, comments, sh:abstract, sh:private.
    			</p>
    		</section>
    		<section>
    			<h3>Shape Inheritance/Extension Mechanism</h3>
    			<p>
    				sh:extends and/or rdfs:subClassOf.
    			</p>
    			<p>
    				Maybe introduce sh:final to indicate that no subshapes are encouraged.
    			</p>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Constraints on Shapes</h2>

	  		<section>
	  			<h3>General Constraints (sh:constraint)</h3>
	  			<div>
	  				(This section describes arbitrary constraints attached to shapes, more general than property constraints)
	  			</div>
	  		</section>

	  		<section>
	  			<h3>Property Constraints (sh:property)</h3>
	  			<p>
	  				(This section describes the various facets supported by sh:PropertyConstraints.
	  				General structure with sh:predicate etc)
	  				TODO: Where to describe rdfs:label, rdfs:comment and sh:defaultValue?
	  			</p>
	  			<section>
					<h4>sh:allowedValues</h4>
	  			</section>
	  			<section>
	  				<h4>sh:hasValue</h4>
	  				<p>
	  					The property constraint <code>sh:hasValue</code> can be used to verify
	  					that the current node has a given RDF node among the values of the given
	  					predicate.
	  				</p>
	  				<div id="def-hasValue-text" class="def def-text">
	  					<div class="def-header">TEXTUAL DEFINITION</div>
	  					<div class="def-text-body">
		  					An <code>sh:Error</code> must be reported if there is no triple that has
		  					the <code>current node</code> as its subject, the <code>sh:predicate</code>
		  					as its predicate and the <code>sh:hasValue</code> as its object.
	  					</div>
	  				</div>
	  				<div id="def-hasValue-sparql" class="def def-sparql">
	  					<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
ASK {
	FILTER NOT EXISTS { ?this ?predicate ?hasValue }
}</pre>
	  				</div>
	  				<pre class="example">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .

ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
	  			</section>
	  			<section>
	  				<h4>sh:minCount, sh:maxCount</h4>
	  				<div>
	  					(Grouped together because we may add sh:count too)
	  				</div>
	  			</section>
	  			<section>
	  				<h4>sh:nodeType</h4>
	  				<div>
	  					Probably put node types vocabulary here (sh:IRI, sh:BlankNode etc)
	  				</div>
	  			</section>
	  			<section>
	  				<h4>sh:valueShape</h4>
	  			</section>
	  			<section>
	  				<h4>sh:valueType</h4>
	  			</section>
	  		</section>
	  		<section>
	  			<h3>Inverse Property Constraints (sh:inverseProperty)</h3>
	  		</section>
    	</section>
    	
    	<section>
    		<h2>Union/Or Constraints</h2>
    		<div>Where to put this best?</div>
    	</section>
    	
    	<section>
    		<h2>Shape Selection</h2>
    		<p>
    			(Explain that applications may chose to invoke shape checking for any
    			resource-shape tuple, even if there are no link triples.
    			The rest of the chapter is assuming that the graph itself is used to look up this linkage.)
    		</p>
    		<div class="issue">
    			There are multiple proposals on how to associate resources with their shapes, in particular
    			based on rdf:type or sh:nodeShape.
    			The WG may chose to:
    			<ul>
    				<li>Only support one of these patterns</li>
    				<li>Support both of these patterns</li>
    				<li>Support a more general mechanism that allows arbitrary selectors</li>
    			</ul>
    		</div>
    		<section>
    			<h3>Shape selection based on sh:nodeShape</h3>
    			<p>
    				(To avoid any potential unwanted interactions with existing RDFS/OWL data)
    			</p>
    		</section>
    		<section>
    			<h3>Shape selection based on rdf:type</h3>
    			<p>
    				(For easier interaction with existing RDFS/OWL data)
    			</p>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Macros/Templates (general mechanism, SPARQL as one example)</h2>
    		<p>
    			Templates can be used to encapsulate and parameterize reusable constraints based on arguments.
    			Templates can be instantiated anywhere where a constraint would appear (sh:constraint etc).
    			SHACL includes several templates that were deemed to be of general use, including the property
    			constraint templates.
    		</p>
    	</section>
    	
    	<section>
    		<h2>Functions (general mechanism, SPARQL as one example)</h2>
    		<div>
    			Functions define operations that produce an RDF node based on arguments.
    			Functions can be called within SPARQL queries to encapsulate complex
    			logic of other SPARQL queries or control logic in other execution languages such as JavaScript. 
    		</div>
    	</section>
    	
    	<section>
    		<h2>Graph Management (includes etc)</h2>
    	</section>
    	
    	<section>
			<h2>Contexts (which shapes when)</h2>
			<div>
				It is possible to annotate shapes and constraints with one or more sh:Context resources via sh:context.
				These can be used to activate/deactivate certain constraints during evaluation.
				Maybe each graph could also serve as context.
			</div>
    	</section>
    	
    	<section>
    		<h2>Profiles (ShEx etc)</h2>
    		<div>
    			A Profile is a set of shape templates.
    			Profiles can be used to define controlled sub-dialects of SHACL, e.g. with desirable complexity.
    			Once you are in a Profile, you cannot use extensions such as SPARQL any more.
    		</div>
    	</section>
    	
    	<section>
    		<h2>Supported Operations and their Algorithms/Definition</h2>
    		<div>
    			For now, see <a href="https://www.w3.org/2014/data-shapes/wiki/LDOM_Algorithm">Algorithm wiki page</a>.
    		</div>
    	</section>
    	
    	<section>
    		<h2>sh:sparql</h2>
    		<p>
    			SPARQL-specific details
    		</p>
    		<section>
    			<h3>SPARQL-based Constraints</h3>
    			<div>Including the role of ?this, and how ASK, SELECT, CONSTRUCT map into Constraint Violations</div>
    		</section>
    		<section>
    			<h3>SPARQL-based Templates</h3>
    		</section>
    		<section>
    			<h3>SPARQL-based Functions</h3>
    		</section>
    		<section>
    			<h3>Built-in Functions (sh:hasShape etc)</h3>
    		</section>
    	</section>
    	
  	</body>
</html>
