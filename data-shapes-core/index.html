<!DOCTYPE html>
<html>
	<head>
		<title>SHACL Specification</title>
		<meta charset='utf-8'>
		<script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
		<script class='remove'>
			var respecConfig = {
				specStatus: "unofficial",
				shortName:  "shacl-core",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/"
					},
					{
						name:       "Eric Prud'hommeaux",
						url:        "http://www.w3.org/People/Eric/",
						company:    "W3C/MIT",
						companyURL: "http://www.w3.org/"
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
				wgPublicList: "public-data-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
			};
		</script>
		<style>
			.todo {
				color: red;
			}
			pre {
				tab-size: 4;
			}
			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}

      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				SHACL (Shapes Constraint Language) is an RDF vocabulary for describing RDF graph structures.
				Some of these graph structures are captured as "shapes", which are expected to correspond to nodes in RDF graphs.
				Shapes identify predicates and their associated cardinalities, datatypes and other constraints.
				Additional constraints can either be stated globally or be associated with shapes using SPARQL or other languages which complement SHACL.
				SHACL shapes can be used to communicate data structures associated with some process or interface, generate or validate data, or drive user interfaces.
			</p>
			<p>
				This document defines the semantics of SHACL and binds them to an RDF vocabulary.
				The accompanying <a href="../data-shapes-primer/no-class-templates.html">primer</a> provides an informal overview of SHACL, describing by example the behavior of components of the SHACL language.
			</p>	
		</section>
	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				SHACL (Shapes Constraint Language) provides structural constraints for <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
				SHACL constraints are grouped into conjunctions called "shapes", which may also be referenced by constraints in other shapes.
				These constraints restrict the predicates of <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a> connecting nodes in the graph.
				SHACL can restrict the number of these triples and the permitted object datatype or object terms, as well as require that the subject or object match some shape
				as well as many other conditions.
			</p>
			
			<p>
				SHACL definitions are represented in RDF and can be serialized in multiple RDF formats.
				The example snippets in this document use Turtle [[turtle]] and JSON-LD [[json-ld]] notation.
				The reader should be familiar with basic RDF concepts [[rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[sparql11-overview]].
			</p>

			<section>
				<h3>What are Shapes and Constraints (normative)</h3>
				<p>
					A <code>shape</code> describes the triples coming into and out of the <code>focus node</code> in an RDF graph.
					A shape has <code>constraints</code> attached to it which describe the <code>focus node</code>'s triples.
					Some of these <code>constraints</code> can be about a specific property only, these are called <code>property constraints</code>.
				</p>
				<p>
					A <code>property constraint</code> has a <code>predicate</code> which identifies the triple's predicate and may have a <code>minimum cardinality</code> and <code>maximum cardinality</code>, to indicate how many triples with that predicate are expected.
					The following attributes are used to constrain the object of each of triples with that predicate:
				</p>
				<ul>
					<li><code>node type</code>: identifies the RDF node type (IRI, RDF literal, or Blank Node).</li>
					<li><code>value type</code>: identifies the datatype of an RDF literal.</li>
					<li><code>allowed value</code>: enumerates specific expected values.</li>
					<li><code>value shape</code>: asserts that the object is described by another shape.</li>
				</ul>
			</section>
			
			<section>
				<h3>What can you do with Shapes (informative)</h3>
				<p>
					SHACL shapes act as a selection criteria for RDF graphs.
					One use of shapes is to define requirements form input data or an application or suite of applications.
					It can also be used to declare the structre of data in some graph or at some SPARQL endpoint.
					Another use is to drive form generation which prompts users to enter data to construct graphs.
					The semantics for shapes are described here in terms of "matching" some data against a shape with the expectation that this functionality is inherent to these uses.
				</p>
			</section>
			
			<section>
				<h3>How Shapes work (Macros/Templates, SPARQL and other executable languages)</h3>
			</section>
		</section>

		<section>
        <h2>Matching a Shape (normative)</h2>
			<div class="issue">
    			There is no agreement in the WG on how the semantics of SHACL should be defined.
    			Currently discussed options include:
    			<ol>
    				<li>Based on <a href="http://labra.github.io/Haws/ldom/index">a ShEx-like Grammar</a></li>
    				<li>Based on SPARQL (plus an extension mechanism for other languages like JavaScript)</li>
    			</ol>
    			This section here is reflecting the first option above only.
			</div>

        <section>
			<h2>Typings</h2>
			
The semantics of SHACL consits of assigning typings to nodes in an RDF graph.
A typing is a map from RDF nodes (iri's or bNodes) to sets of labels in a Schema.
We define the following operations on shape typings:

<table>
<tbody><tr>
<td>{}</td><td>empty shape typing</td>
</tr>
<tr>
<td><i>iri -&gt; label :: typing</i></td>
<td>the result of assigning <i>iri</i> to <i>label</i> in <i>typing</i></td>
</tr>
<tr>
<td><i>t1</i> ++ <i>t2</i></td>
<td>combination of typings <i>t1</i> and <i>t2</i></td>
</tr>
<tr>
<td><i>contains(t,<code>focus node</code>,label)</i></td>
<td>returns true if the typing <i>t</i> asserts that <code>focus node</code> has shape <i>label</i></td>
</tr>

</tbody></table>
</section>

<section id="Context">
<h2>Context</h2>
<p>The shape schema validator acts in a context.
A context is a tuple <i>(s, g, t)</i> where
 <i>s</i> is a Schema, 
 <i>g</i> is an RDF Graph and
 <i>t</i> is a Typing. 
</p> 
</section>


    	<section>
<h3>Match focus node</h3>

<i>ctx |- matchNode(<code>focus node</code>, label)</i> checks if a <code>focus node</code> conforms
 with the shape associated with <i>label</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.

<table class="rule">
<tbody><tr>
<td rowspan="2">matchNode</td>
<td class="up">
 ctx.schema(label) = shape &nbsp;&nbsp;&nbsp; 
 ctx.graph.triplesAround(<code>focus node</code>) = ts &nbsp;&nbsp;&nbsp;
 ctx { <code>focus node</code> -&gt; label } |- matchShape(ts, shape) = (t,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchNode(<code>focus node</code>,label) = (t,cs,rs)</td></tr>
</tbody></table>
</section>


<section id="MatchShape">
<h3>Match Shape</h3>
<p>
<i>ctx |- matchShape(triples, shape)</i> checks if a set of triples <i>triples</i> conforms
 with <i>shape</i> in context <i>ctx</i>. 
 If it conforms, it returns <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.
</p>

<p>The empty shape matches any set of triples without any constraint.</p>
<table class="rule">
<tbody><tr>
<td rowspan="2">Empty</td>
<td class="up">
 &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,Empty) = (ctx.typing,{},ts)</td></tr>
</tbody></table>

<p>There are five possibilities for cardinality: </p>

<ul>
<li>
<p>When the cardinality is {0,unbounded} 
 it matches any set of triples:</p>
<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_unbounded1</td>
<td class="up">
  &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,basicArc {0,unbounded}) = (ctx.typing,{},ts)</td></tr>
</tbody></table>

</li><li>
<p>When the cardinality is <i>{m,unbounded}</i> for <i>m &gt; 0</i> it matches if
 there is one triple that matches and if the rest of triples matches 
 with a cardinality of <i>{m - 1, unbounded}</i></p>
<p>Notice that it only matches if there are at least one triple</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_unbounded2</td>
<td class="up">
m &gt; 0 &nbsp;&nbsp;&nbsp;
ctx |- matchArc(t,basicArc) = t1 &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts,basicArc {m - 1,unbounded}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t:ts, basicArc {m,unbounded}) = (t1 ++ t2,t:cs,rs)</td></tr>
</tbody></table>

</li><li>

<p>When the cardinality is <i>{0, n}</i> for <i>n &gt;= 0</i> it can match if there 
is not triple that matches or if there 
is one triple that matches and the rest of triples matches with a cardinality of <i>{0, n-1}</i></p>

<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_bounded1</td>
<td class="up">
n &gt;= 0 &nbsp;&nbsp;&nbsp;
ctx |- not (matchArcAny(ts,p,v)) 
</td>
</tr>
<tr><td>ctx |- matchShape(ts, BasicArc {0, n}) = (ctx.typing,{},ts)</td></tr>
</tbody></table>

</li><li> 
<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_bounded2</td>
<td class="up">
n &gt;= 0 &nbsp;&nbsp;&nbsp;
matchArc(t,basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts,basicArc {0, n - 1}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t::ts, basicArc {0, n}) = (t1 ++ t2, t::cs, rs)</td></tr>
</tbody></table>

</li><li>
<p>If the cardinality if <i>{m, n}</i> it matches if there is one triple that matches 
 and if the rest of triples match with the cardinality <i>{m - 1, n - 1}</i></p>
 
<table class="rule">
<tbody><tr>
<td rowspan="2">BasicArc_bounded3</td>
<td class="up">
m &gt; 0, n &gt;= m &nbsp;&nbsp;&nbsp;
matchBasicArc(t, basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts, basicArc {m-1, n-1} ) = (t2, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(t::ts, basicArc {m, n}) = (t1 ++ t2, t::cs, rs)</td></tr>
</tbody></table>

</li></ul>

<p>If the shape is a conjunction it matches if it matches the first element and 
   then, the second with the remaining triples</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">And</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t1, cs1, rs1) &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts, e2) = (t2, cs2, rs2)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, And(e1, e2) = (t1 ++ t2, cs1 union cs2, rs1 intersection rs2)</td></tr>
</tbody></table>

<p>If the shape is a disjunction it matches if either the first element matches or the second, matching is the union</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">Or_1</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</tbody></table>

<table class="rule">
<tbody><tr>
<td rowspan="2">Or_2</td>
<td class="up">
ctx |- matchShape(ts, e2) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</tbody></table>

<p class="issue">exclusive OR to enable <a href="http://www.w3.org/2015/02/19-shapes-minutes">graph coverage</a> or <a href="https://www.w3.org/2014/data-shapes/wiki/Requirements#Expressivity:_Closed_Shapes">closed shapes</a></p>

<p>If the shape is a negation of a shape it matches if the shape does not match</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">Not</td>
<td class="up">
ctx |- not(matchShape(ts,e))
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Not(e)) = (t, ts, {})</td></tr>
</tbody></table>

<p>A set of triples matches a closed shape if the set of triples matches the shape
 and there are no remaining triples</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">Close</td>
<td class="up">
ctx |- matchShape(ts,e) = (t,cs,{})
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Closed(e)) = (t, cs, {})</td></tr>
</tbody></table>

</section>

<section id="MatchBasicArc">
<h3>Match BasicArc</h3>
<p>ctx|-matchBasicArc(triple,basicArc</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">ObjectArc</td>
<td class="up">
ctx |- matchValue(o,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, Arc p v) = t&lt;/s,p,o&gt;</td></tr>
</tbody></table>

<table class="rule">
<tbody><tr>
<td rowspan="2">SubjectArc</td>
<td class="up">
ctx |- matchValue(s,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, InvArc p v) = t&lt;/s,p,o&gt;</td></tr>
</tbody></table>

</section>

<section id="MatchValue">
<h3>Match value</h3>

<table class="rule">
<tbody><tr>
<td rowspan="2">valueSet</td>
<td class="up">
x in set
</td>
</tr>
<tr><td>ctx |- matchValueSet(x, ValueSet(set)) = ctx.typing</td></tr>
</tbody></table>

<table class="rule">
<tbody><tr>
<td rowspan="2">valueObjectType</td>
<td class="up">
x hastype t
</td>
</tr>
<tr><td>ctx |- matchValueType(x, ValueType(t)) = ctx.typing</td></tr>
</tbody></table>

<p>ValueRef handles references to shapes. There are two cases, 
  the first initial case, when the context already contains the declaration
  that <i>x</i> has shape <i>label</i> just returns the current typing.</p>
  
<table class="rule">
<tbody><tr>
<td rowspan="2">valueRef_1</td>
<td class="up">
 contains(ctx.typing, x, label)
</td>
</tr>
<tr><td>ctx |- matchValueRef(x, ValueRef(label)) = ctx.typing</td></tr>
</tbody></table>

<p>The second case, when the context does not contain the declaration that <i>x</i> has the shape <i>label</i>
 is solved by trying to match <i>x</i> with shape <i>label</i> in the graph.</p>
 
<table class="rule">
<tbody><tr>
<td rowspan="2">valueRef_2</td>
<td class="up">
not(contains(ctx, x, label)) &nbsp; &nbsp; &nbsp;
ctx |- matchNode(x,v) = (t,_,_)
</td>
</tr>
<tr><td>ctx |- matchValueRef(x, ValueRef(label)) = t</td></tr>
</tbody></table>

</section>

<section id="MatchArcAny">
<h3>MatchArcAny</h3>
<p><i>matchArcAny</i> takes a set of triples and a basic arc and checks if there is some triple
 in that set that matches with the basic arc.
 The result is a boolean</p>
 
<p>It has two possibilities. Either it matches the first triple in the set (<i>matchArc_1</i>)
 or it matches any of the rest of triples in the set (<i>matchArc_2</i>)</p>

<table class="rule">
<tbody><tr>
<td rowspan="2">matchArcAny_1</td>
<td class="up">
ctx |- matchBasicArc(t,basicArc) = (_,_,_)
</td>
</tr>
<tr><td>ctx |- matchArcAny(t:ts, basicArc)</td></tr>
</tbody></table>
 
<table class="rule">
<tbody><tr>
<td rowspan="2">matchArcAny_2</td>
<td class="up">
ctx |- matchArcAny(ts,basicArc)
</td>
</tr>
<tr><td>ctx |- matchArcAny(t:ts, basicArc)</td>
</tr>
</tbody>
</table>

			</section>
		</section>

		<section id="violations">
			<h2>Constraint Violations Vocabulary (normative)</h2>
			<p>
				The output of a SHACL constraint checking operation is a set of <em>constraint violations</em>.
				SHACL includes an RDF vocabulary to represent such constraint violations together with
				structural information that may provide guidance on how to fix the violation, as well as
				human-readable messages.
			</p>
			<p>
				The following code snippet represents a valid constraint violation that may have been produced
				by a constraint checking engine:
			</p>
			<pre class="example">
ex:ExampleConstraintViolation
	a sh:Error ;
	sh:root ex:MyCurrentNode ;
	sh:path ex:someProperty ;
	sh:value ex:someInvalidValue ;
	sh:message "Incorrect value: expected something else here." .
			</pre>
			<section id="violations-types">
				<h3>Types of Constraints Violations</h3>
				<p>
					A constraint violation is represented by a IRI or blank node that has exactly one
					asserted <code>rdf:type</code>.
					The <code>rdf:type</code> arc of a constraint violation must point to one of the subclasses
					of the ("abstract") base class <code>sh:ConstraintViolation</code>.
					The SHACL core vocabulary includes the following constraint violation types: 
				</p>
				<table style="border-collapse: collapse; border-color: #000000" border="1" cellpadding="5">
					<tr>
						<th>Constraint&nbsp;Violation&nbsp;Class</th>
						<th>Superclass</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:Warning</code></td>
						<td><code>sh:ConstraintViolation</code></td>
						<td>A non-critical constraint violation indicating a warning.</td>
					</tr>
					<tr>
						<td><code>sh:Error</code></td>
						<td><code>sh:ConstraintViolation</code></td>
						<td>A constraint violation indicating an error.</td>
					</tr>
					<tr>
						<td><code>sh:FatalError</code></td>
						<td><code>sh:Error</code></td>
						<td>
							An error that cannot be recovered and further evaluation may terminate immediately.
							Engines may decide to perform fatal checks first.
						</td>
					</tr>
				</table>
				<p>
					SHACL extensions may define additional violation types, as long as they are rooted in
					<code>sh:ConstraintViolation</code>.
					The <code>rdfs:subClassOf</code> relationship between these types indicates specialization,
					e.g. <code>sh:FatalError</code> is a subclass of <code>sh:Error</code> meaning that every
					fatal error should also be regarded as an error.
				</p>
			</section>
			<section id="violations-structure">
				<h3>Structural Violation Metadata</h3>
				<p>
					SHACL constraint violations may include machine-readable metadata that points at
					the cause of the violation.
				</p>
				<section id="violations-structure-root">
					<h4>sh:root</h4>
					<p>
						Constraint violations may have a single value for the property <code>sh:root</code> to point to an
						IRI or blank node that has caused the violation.
					</p>
				</section>
				<section id="violations-structure-path">
					<h4>sh:path</h4>
					<p>
						Constraint violations may have one or more values for the property <code>sh:path</code>
						that describes a <em>path expression</em> that can be walked starting at the <code>sh:root</code>.
						If value of this property is a IRI, then the path produces all triples that have the root node as
						subject and the value as its predicate.
						If the value of <code>sh:path</code> is a blank node, then it must have properties that
						match either one of the following options: 
					</p>
					<ul>
						<li>
							<code>sh:inverse</code> describes an inverse path consisting of all paths that start
							at the current root node and walk the given predicate backwards, i.e. from object to subject.
							The values of <code>sh:inverse</code> must be the IRIs of properties.
							Blank nodes with <code>sh:inverse</code> may have the optional type <code>sh:InversePath</code>.
						</li>
						<li>
							<code>sh:path1</code> and <code>sh:path2</code> describe a sequence path consisting of
							two other paths.  The values of these properties must be property IRIs or blank nodes
							of the same recursive path structure.  The path produces the concatenation of the two sub-paths.
							Blank nodes with <code>sh:path1</code> and <code>sh:path2</code> may have the optional type <code>sh:SequencePath</code>.
						</li>
					</ul>
					<p>
						The following example describes a path equivalent to the SPARQL 1.1 Property Path [[sparql11-query]]
						<code>ex:firstProperty/((^ex:inverseProperty)/ex:lastProperty)</code>
					</p>
					<pre class="example">
ex:ExampleConstraintViolationWithPath
	a sh:Error ;
	sh:root ex:MyCurrentNode ;
	sh:path [
		sh:path1 ex:firstProperty ;
		sh:path2 [
			ex:path1 [ sh:inverse ex:inverseProperty ] ;
			ex:path2 ex:lastProperty
		]
	] .</pre>
				</section>
				<section id="violations-structure-value">
					<h4>sh:value</h4>
					<p>
						Constraint violations may have one or more values of the property <code>sh:value</code> to
						point at specific nodes that caused the violation.
						These nodes SHOULD be accessible via at least one <code>sh:path</code> starting at the
						specific <code>sh:root</code> node.
					</p>
				</section>
				<section id="violations-structure-source">
					<h4>sh:source</h4>
					<p>
						Constraint violations may point at one <code>sh:Constraint</code> that has caused
						the violation, specified via the property <code>sh:source</code>.
						SHACL constraint checking engines SHOULD automatically insert the <code>sh:source</code>
						based on the currently evaluated constraint, unless the constraint violation already has
						such a value.
					</p>
				</section>
				<section id="violations-structure-detail">
					<h4>sh:detail</h4>
					<p>
						The property <code>sh:detail</code> may link a (parent) constraint violation with one or more other
						(child) constraint violations that provide further details about the cause of the (parent) violation.
						Depending on the capabilities of the constraint checking engine, this may include failures of
						nested constraints that have been evaluated via <code>sh:valueShape</code>.
					</p>
				</section>
			</section>
			<section id="violations-message">
				<h3>Human-readable Violation Messages (sh:message)</h3>
				<p>
					Constraint violations may have values for the property <code>sh:message</code> to communicate
					additional textual details to humans.
					While <code>sh:message</code> may have multiple values, there SHOULD not be two values
					with the same language tag.
				</p>
			</section>
		</section>

		<section id="constraints">
			<h2>Constraints</h2>
			<p>
				The (abstract) root class for representing SHACL constraints is <code>sh:Constraint</code>.
				There are two kinds of constraints built into SHACL, represented by the following subclasses of
				<code>sh:Constraint</code>:
			</p>
			<ul>
				<li>
					<code>sh:NativeConstraint</code> represents constraints that are directly backed by a
					<em>native executable</em>, e.g. a SPARQL query, that produces constraint violations.
				</li>
				<li>
					<code>sh:TemplateConstraint</code> represents constraints that are backed by a native executable
					that is encapsulated into a <em>template</em> (aka <em>macro</em>).
				</li>
			</ul>
			<p>
				There is another dimension to constraint definitions that is orthogonal to the distinction between
				native and template constraints:
			</p>
			<ul>
				<li>
					<code>sh:GlobalConstraint</code> represents constraints that are evaluated on the whole graph.
				</li>
				<li>
					<code>sh:LocalConstraint</code> represents constraints that evaluated on a given focus node.
					Local constraints are usually grouped into shapes but may also be declared as stand-alone
					entities with their own IRIs so that they can be shared between multiple shapes. 
				</li>
			</ul>
			<p>
				Based on those two dimensions, SHACL can represent four kinds of constraints overall:
			</p>
			<ul>
				<li><a href="#constraints-global-native">Global native constraints</a></li>
				<li><a href="#constraints-global-template">Global template constraints</a></li>
				<li><a href="#constraints-local-native">Local native constraints</a></li>
				<li><a href="#constraints-local-template">Local template constraints</a></li>
			</ul>
			<section id="constraints-global-native">
				<h3>Global Native Constraints</h3>
				<p>
					The following example illustrates the syntax for a global native constraint.
					Note that the constraint does not need to have the explicit type <code>sh:NativeConstraint</code>
					because it has a <code>sh:sparql</code> query that serves as a native executable.
				</p>
				<pre class="example">
ex:ExampleGlobalSPARQLConstraint
	a sh:GlobalConstraint ;
	sh:message "There needs to be at least one instance of ex:SomeClass." ;
	sh:sparql """
		ASK {
			FILTER NOT EXISTS { ?any rdf:type ex:SomeClass } .
		}
		""" .</pre>
			</section>
			<section id="constraints-global-template">
				<h3>Global Template Constraints</h3>
				<p>
					The following example illustrates the syntax for a global template constraint and the template
					that it instantiates.
					Note that the constraint does not need to have the explicit type <code>sh:GlobalConstraint</code>
					because it is an instance of the template <code>ex:ExampleGlobalConstraintTemplate</code> which
					is declared as a subclass of <code>sh:GlobalConstraint</code>.
				</p>
				<pre class="example">
ex:ExampleGlobalTemplateConstraint
	a ex:ExampleGlobalConstraintTemplate ;
	ex:exampleArgument ex:SomeClass .
	
ex:ExampleGlobalConstraintTemplate
	a sh:ConstraintTemplate ;
	rdfs:subClassOf sh:GlobalConstraint ;
	sh:argument [
		sh:predicate ex:exampleArgument ;
		sh:valueType rdfs:Class ;
		rdfs:label "The class that needs to have at least one instance." ;
	] ;
	sh:message "There needs to be at least one instance of the given class" ;
	sh:sparql """
		ASK {
			FILTER NOT EXISTS { ?any rdf:type ?exampleArgument }
		}
		""" .</pre>
			</section>
			<section id="constraints-local-native">
				<h3>Local Native Constraints</h3>
				<p>
					The following example illustrates the syntax for a local native constraint.
					Note that the constraint does not need to have the explicit type <code>sh:NativeConstraint</code>
					because it has a <code>sh:sparql</code> query that serves as a native executable.
					In contrast to global constraints, note that the variable <code>?this</code> is used to
					refer to the focus node.
				</p>
				<pre class="example">
ex:ExampleLocalSPARQLConstraint
	sh:message "At least one value of ex:someProperty expected." ;
	sh:sparql """
		ASK {
			FILTER NOT EXISTS { ?this ex:someProperty ?anyValue } .
		}
		""" .</pre>
			</section>
			<section id="constraints-local-template">
				<h3>Local Template Constraints</h3>
				<p>
					The following example illustrates the syntax for a local template constraint and the
					template that it instantiates.
				</p>
				<pre class="example">
ex:ExampleLocalTemplateConstraint
	a ex:ExampleLocalConstraintTemplate ;
	ex:exampleArgument ex:someProperty .

ex:ExampleLocalConstraintTemplate
	sh:message "At least one value of the given property expected." ;
	rdfs:subClassOf sh:LocalConstraint ;
	sh:argument [
		sh:predicate ex:exampleArgument ;
		sh:valueType rdf:Property ;
		rdfs:label "The property for which the focus node needs to have at least one instance." ;
	] ;
	sh:sparql """
		ASK {
			FILTER NOT EXISTS { ?this ?exampleArgument ?anyValue } .
		}
		""" .</pre>
			</section>
		</section>

		<section id="shapes">
			<h2>General Structure of Shapes</h2>
			<div class="issue">
				There is no agreement in the WG on the relationship of sh:Shape with RDFS classes.
				Proposals include:
				<ul>
					<li>Keep them completely separate, users only instantiate sh:Shape and use sh:extends</li>
					<li>Have rdfs:Class rdfs:subClassOf sh:Shape, use either sh:extends or rdfs:subClassOf</li>
					<li>Have sh:Shape rdfs:subClassOf rdfs:Class, use rdfs:subClassOf</li>
					<li>Allow both approaches in parallel: either rdfs:Class/subClassOf or sh:Shape/extends</li>
					<li>Allow both and have sh:classShape to point from a class to its shape(s)</li>
				</ul>
				In the absence of such an agreement, this document uses sh:Shape in all examples.
			</div>
			<p>
				Shapes are instances of the class <code>sh:Shape</code>
				(or, depending on the outcome of the ISSUE above, <code>rdfs:Class</code>).
				The <code>rdf:type</code> triple of a shape can be omitted when it can be deduced from
				the context, e.g. values of <code>sh:valueShape</code> do not require a type triple.
			</p>
			<section id="shapes-labels">
				<h3>Shape Labels and Comments</h3>
				<p>
					Like many other types of RDF resources, shapes SHOULD have human-readable labels
					via <code>rdfs:label</code>.
					The property <code>rdfs:comment</code> is recommended for documentation and definition purposes.
				</p>
			</section>
			<section id="shapes-private">
				<h3>Private Shapes (sh:private)</h3>
				<p>
					A shapes may have its property <code>sh:private</code> set to <code>true</code> to
					indicate that the shape is not meant to be directly referenced from outside of the
					graph (or namespace) that it has been defined in.
					Editing tools SHOULD actively discourage the use of private shapes.
				</p>
			</section>
			<section id="shapes-specialization">
				<h3>Shape Specialization Mechanism (sh:extends/rdfs:subClassOf)</h3>
				<p>
					Shape declarations can specialize other shapes.
					If a (sub) shape is declared to specialize another (super) shape then all constraints
					attached to the super-shape must also apply to the sub-shape.
					In other words, the set of nodes that match a sub-shape is a sub-set of those that
					match a super-shape.
				</p>
				<p>
					In the currently discussed proposals, the property <code>sh:extends</code> would be used
					for instances of <code>sh:Shape</code> if <code>sh:Shape</code> is not declared to be a
					subclass of <code>rdfs:Class</code>.
					In all other cases, the property <code>rdfs:subClassOf</code> would be used to link
					a sub-shape with its super-shape(s).
				</p>
			</section>
			<section id="shapes-abstract">
				<h3>Abstract Shapes (sh:abstract)</h3>
				<p>
					A shape may have its property <code>sh:abstract</code> set to <code>true</code> to
					indicate that the shape SHOULD only serve as base of further specializations.
					Abstract shapes SHOULD not be "instantiated" directly.
				</p>
			</section>
			<section id="shapes-final">
				<h3>Final Shapes (sh:final)</h3>
				<p>
					A shape may have its property <code>sh:final</code> set to <code>true</code> to
					indicate that the shape SHOULD not have further specializations.
				</p>
			</section>
		</section>
		
		<section>
			<h2>Constraints on Shapes</h2>
			<p>
				A <code>property constraint</code> for a triple with the <code>focus node</code> as a subject is attached to the <code>shape</code> via with <span class="type">sh:</span><span class="constant">property</span>;
				a <code>property constraint</code> for a triple with the <code>focus node</code> as a object is attached to the <code>shape</code> via with <span class="type">sh:</span><span class="constant">inverseProperty</span>.
			</p>
			<p>
				A <code>constraint</code>'s <code>minimum cardinality</code> and <code>maximum cardinality</code> are identified by <span class="type">sh:</span><span class="constant">minCount</span> and <span class="type">sh:</span><span class="constant">maxCount</span> respectively.
				The RDF properties for constraining objects are:
			</p>
			<ul>
				<li><code>node type</code>: <span class="type">sh:</span><span class="constant">nodeType</span>.</li>
				<li><code>value type</code>: <span class="type">sh:</span><span class="constant">valueType</span>.</li>
				<li><code>allowed value</code>: <span class="type">sh:</span><span class="constant">allowedValue</span>.</li>
				<li><code>value shape</code>: <span class="type">sh:</span><span class="constant">valueShape</span>.</li>
			</ul>

			<section>
				<h3>General Constraints (sh:constraint)</h3>
				<div>
						(This section describes arbitrary constraints attached to shapes, more general than property constraints)
				</div>
			</section>

			<section>
			<h3>Property Constraints (sh:property)</h3>
			<p>
					(This section describes the various facets supported by sh:PropertyConstraints.
					General structure with sh:predicate etc)
					TODO: Where to describe rdfs:label, rdfs:comment and sh:defaultValue?
				</p>
				<section>
					<h4>sh:allowedValues</h4>
				</section>
				<section>
					<h4>sh:hasValue</h4>
					<p>
						The property constraint <code>sh:hasValue</code> can be used to verify
						that the focus node has a given RDF node among the values of the given
						predicate.
					</p>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							An <code>sh:Error</code> must be reported if there is no triple that has
							the <code>focus node</code> as its subject, the <code>sh:predicate</code>
							as its predicate and the <code>sh:hasValue</code> as its object.
						</div>
					</div>
					<div id="def-hasValue-sparql" class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
ASK {
	FILTER NOT EXISTS { ?this ?predicate ?hasValue }
}</pre>
					</div>
					<pre class="example">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .

ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
				</section>
				<section>
					<h4>sh:minCount, sh:maxCount</h4>
					<div>
						(Grouped together because we may add sh:count too)
					</div>
				</section>
				<section>
					<h4>sh:nodeType</h4>
					<div>
						Probably put node types vocabulary here (sh:IRI, sh:BlankNode etc)
					</div>
				</section>
				<section>
					<h4>sh:valueShape</h4>
				</section>
				<section>
					<h4>sh:valueType</h4>
				</section>
			</section>
			<section>
				<h3>Inverse Property Constraints (sh:inverseProperty)</h3>
			</section>
		</section>
		
		<section>
			<h2>Union/Or Constraints</h2>
			<div>Where to put this best?</div>
		</section>
		
		<section>
			<h2>Shape Selection</h2>
			<p>
				(Explain that applications may chose to invoke shape checking for any
				resource-shape tuple, even if there are no link triples.
				The rest of the chapter is assuming that the graph itself is used to look up this linkage.)
			</p>
			<div class="issue">
				There are multiple proposals on how to associate resources with their shapes, in particular
				based on rdf:type or sh:nodeShape.
				The WG may chose to:
				<ul>
					<li>Only support one of these patterns</li>
					<li>Support both of these patterns</li>
					<li>Support a more general mechanism that allows arbitrary selectors</li>
				</ul>
			</div>
			<section>
				<h3>Shape selection based on sh:nodeShape</h3>
				<p>
					(To avoid any potential unwanted interactions with existing RDFS/OWL data)
				</p>
			</section>
			<section>
				<h3>Shape selection based on rdf:type</h3>
				<p>
					(For easier interaction with existing RDFS/OWL data)
				</p>
			</section>
		</section>
		
		<section>
			<h2>Macros/Templates (general mechanism, SPARQL as one example)</h2>
			<p>
				Templates can be used to encapsulate and parameterize reusable constraints based on arguments.
				Templates can be instantiated anywhere where a constraint would appear (sh:constraint etc).
				SHACL includes several templates that were deemed to be of general use, including the property
				constraint templates.
			</p>
		</section>
		
		<section>
			<h2>Functions (general mechanism, SPARQL as one example)</h2>
			<div>
				Functions define operations that produce an RDF node based on arguments.
				Functions can be called within SPARQL queries to encapsulate complex
				logic of other SPARQL queries or control logic in other execution languages such as JavaScript. 
			</div>
		</section>
		
		<section>
			<h2>Graph Management (includes etc)</h2>
		</section>
		
		<section>
			<h2>Contexts (which shapes when)</h2>
			<div>
				It is possible to annotate shapes and constraints with one or more sh:Context resources via sh:context.
				These can be used to activate/deactivate certain constraints during evaluation.
				Maybe each graph could also serve as context.
			</div>
		</section>

		<section>
			<h2>Profiles (ShEx etc)</h2>
			<div>
				A Profile is a set of shape templates.
				Profiles can be used to define controlled sub-dialects of SHACL, e.g. with desirable complexity.
				Once you are in a Profile, you cannot use extensions such as SPARQL any more.
			</div>
		</section>

		<section>
			<h2>Supported Operations and their Algorithms/Definition</h2>
			<div>
				For now, see <a href="https://www.w3.org/2014/data-shapes/wiki/LDOM_Algorithm">Algorithm wiki page</a>.
			</div>
		</section>

		<section>
			<h2>sh:sparql</h2>
			<p>
				SPARQL-specific details
			</p>
		<section>
				<h3>SPARQL-based Constraints</h3>
				<div>Including the role of ?this, and how ASK, SELECT, CONSTRUCT map into Constraint Violations</div>
			</section>
			<section>
				<h3>SPARQL-based Templates</h3>
			</section>
			<section>
				<h3>SPARQL-based Functions</h3>
			</section>
			<section>
				<h3>Built-in Functions (sh:hasShape etc)</h3>
			</section>
		</section>

	</body>
</html>
