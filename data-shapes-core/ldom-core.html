<!DOCTYPE html>
<html>
  	<head>
       	<title>LDOM Core Specification</title>
    	<meta charset='utf-8'>
    	<script src='//www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
	    <script class='remove'>
	      var respecConfig = {
	          specStatus: "unofficial",
	          shortName:  "ldom-core",
	          editors: [
	                {   name:       "Holger Knublauch",
	                    url:        "http://knublauch.com/",
	                    company:    "TopQuadrant, Inc.",
	                    companyURL: "http://topquadrant.com/" }
	          ],
	          wg:           "RDF Data Shapes Working Group",
	          wgURI:        "https://www.w3.org/2014/data-shapes/wiki/Main_Page",
	          wgPublicList: "public-data-shapes",
	          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
	      };
	    </script>
		<style>
			.template-body {
				background-color: #fcfaee;
			}
			.todo {
				color: red;
			}
		    pre {
				tab-size: 4;
		    }
			th {
				text-align: left;
			}
		</style>  		
  	</head>
  	<body>
    
    	<section id="abstract">
			<p class="todo">
				TODO: For now, see <a href="../data-shapes-primer/">Primer</a>
	  		</p>
		</section>
    
    	<section id="introduction">
      		<h2>Introduction</h2>
      		<p>
      			LDOM is an RDF vocabulary to represent structural constraints on RDF graphs.
      			<em>Constraints</em> are usually backed by verifiable conditions (e.g. SPARQL queries)
      			but	may also contain structural definitions that can be used for other purposes
      			such as building user interface forms.
      			Constraints may apply globally to a whole graph, or to a dedicated starting node.
      			Constraints that have the same starting node can be grouped into <em>Shapes</em>.
      			Shapes may be arranged in an extension hierarchy.
      		</p>
      		<p>
      			RDF resources may be associated with shapes that they are supposed to validate against.
      			LDOM supports a flexible mechanism to define those resource-shape associations.
      			When an LDOM compliant engine is asked to validate a given graph, it can use different
      			<em>shape selectors</em> that instruct the engine how to find the shapes for a given resource.
      			Applications may also trigger the LDOM validation process with information retrieved from
      			outside of the RDF graph itself, e.g. from request metadata.
      		</p>
      		<p>
      			The following example illustrates a typical shape declaration consisting of one constraint:
      		</p>
      		<pre class="example">
	ex:Shape
		a ldom:Shape ;
		ldom:property [
			ldom:predicate ex:property ;
			ldom:minCount 1 ;
		] .</pre>
			<p>
				The next example resource contains an instance that matches the shape above:
			</p>
			<pre class="example">
	ex:Resource
		ex:property "value" .</pre>
			<p>
				The graph <em>may</em> contain triples that establish a relationship between that
				resource and its applicable shapes: 
			</p>
			<pre class="example">
	ex:Resource
		ex:shape ex:Shape ;
		ex:property "value" .</pre>
			<p>
				A Shape Selector can define that the LDOM engine shall use the property <code>ex:shape</code>
				to select the shapes for a given resource.
			</p>
    	</section>
    	
    	<section>
    		<h2>SPARQL Functions</h2>
    		
    		<section>
	    		<h3>Built-in Functions</h3>
	    		<p class="todo">
	    			TODO: Maybe enumerate the built-in functions and what they do.
	    			Probably better to just enumerate them in the appendix.
	    		</p>
    		</section>
    		
    		<section>
	    		<h3>User-Defined Functions</h3>
	    		<p class="todo">
	    			TODO: Explain syntax for user-defined SPARQL functions with ldom:sparql as body.
	    			List of actual built-in functions of the system vocab may go into the appendix
	    			together with their SPARQL bodies.
	    		</p>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Templates</h2>
    		<p class="todo">
    			TODO: Explain syntax for templates that encapsulate a SPARQL query
    		</p>
    		<section>
	    		<h2>Templates Syntax</h2>
	    		<p class="todo">
	    			TODO: Explain general syntax for templates: ldom:argument, ldom:sparql
	    		</p>
    		</section>
    		<section>
    			<h2>Template Inheritance</h2>
    			<p class="todo">
    				TODO: templates can be organized in subclass hierarchy so that
    				a single template instance can combine multiple multiple SPARQL queries.
    			</p>
    		</section>
    		<section>
	    		<h2>Template Calls</h2>
	    		<p class="todo">
	    			TODO: Explain how template calls (instances of templates) are represented
	    			and how they are instantiated with pre-bound variables.
	    		</p>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Constraint Violations Vocabulary</h2>
    		<p class="todo">
    			TODO: Introduce ldom:ConstraintViolation and its subclasses and properties
    		</p>
    		<section>
    			<h3>Constraint Violation Types</h3>
	    		<p class="todo">
	    			TODO: Introduce ldom:Error, ldom:Warning etc
	    		</p>
    		</section>
    		<section>
    			<h3>Constraint Violation Properties</h3>
	    		<p class="todo">
	    			TODO: Introduce ldom:root, ldom:path, ldom:message etc
	    		</p>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Global Constraints</h2>
    		<p class="todo">
    			TODO: Explain ldom:GlobalConstraint and its meaning
    		</p>
    		<section>
    			<h3>Global Constraints using SPARQL</h3>
	    		<section>
	    			<h4>Constraints using SPARQL ASK Queries</h4>
	    		</section>
	    		<section>
	    			<h4>Constraints using SPARQL SELECT Queries</h4>
	    		</section>
	    		<section>
	    			<h4>Constraints using SPARQL CONSTRUCT Queries</h4>
	    		</section>
    		</section>
    		<section>
    			<h3>Global Constraints using Templates</h3>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Shapes and Classes</h2>
    		<p class="todo">
    			TODO: Explain ldom:Shape and rdfs:Class
    		</p>
    		<section>
    			<h3>ldom:Shape</h3>
    		</section>
    		<section>
    			<h3>rdfs:Class</h3>
    			<p class="todo">
    				TODO: ldom:abstract, ldom:private etc
    			</p>
    		</section>
    		<section>
    			<h3>ldom:constraint</h3>
    		</section>
    		<section>
    			<h3>ldom:property, ldom:inverseProperty, ldom:argument</h3>
    			<p class="todo">
    				TODO: Explain that those can only be used for templates, and only subclasses
    				of specific types such as ldom:PropertyConstraint.
    			</p>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Property Constraints</h2>
    		<p class="todo">
    			TODO: These are used at ldom:property for a given property (ldom:predicate).
    		</p>
   			<section id="property-cardinality">
   				<h3>Cardinality (ldom:minCount, ldom:maxCount)</h3>
   				<p>
   					Property constraints may have the properties <code>ldom:minCount</code>
   					and <code>ldom:maxCount</code> to limit the number of triples
   					that have the given <code>ldom:predicate</code> as predicate
   					and <code>?this</code> as subject.
   					The values of <code>ldom:minCount</code> and <code>ldom:maxCount</code>
   					must be comparable to <code>xsd:integer</code>.
   					Default value of <code>ldom:minCount</code> is 0 and for
   					<code>ldom:maxCount</code> infinite.
   				</p>
   				<p>
   					The following example...
   				</p>
   				<pre class="example">
ex:Rectangle
	ldom:property [
		ldom:predicate ex:height ;
		ldom:minCount 1 ;
		ldom:maxCount 1 ;
	] ; ...</pre>
				<p>
					The interpretation of <code>ldom:minCount</code> and <code>ldom:maxCount</code>
					must be equivalent to the following SPARQL query:
				</p>
				<pre class="template-body">
CONSTRUCT {
	_:error a ldom:Error ;
		ldom:root ?this ;
		ldom:path ?predicate .
}
WHERE {
	BIND (ldom:valueCount(?this, ?predicate) AS ?count) .
	FILTER ((?count &lt; ?minCount) || (bound(?maxCount) &amp;&amp; (?count &gt; ?maxCount))) .
}</pre>
   			</section>
   			<section id="property-hasValue">
   				<h3>ldom:hasValue</h3>
   				<p>
   					Property constraints may have the property <code>ldom:hasValue</code>
   					to verify that there is a triple that has the current node <code>?this</code>
   					as subject, the specified <code>ldom:predicate</code> as predicate,
   					and the specified <code>ldom:hasValue</code> as its object.
   				</p>
   				<p>
   					The following example defines a shape matching all nodes that have
   					the gender <code>ex:male</code>.
   				</p>
   				<pre class="example">
ex:MalePerson
	ldom:property [
		ldom:predicate ex:gender ;
		ldom:hasValue ex:male ;
	] ; ...</pre>
				<p>
					The interpretation of <code>ldom:hasValue</code> must be equivalent to the
					following SPARQL query:
				</p>
				<pre class="template-body">
CONSTRUCT {
	_:error a ldom:Error ;
		ldom:root ?this ;
		ldom:path ?predicate ;
		ldom:value ?hasValue .
}
WHERE {
	FILTER NOT EXISTS { ?this ?predicate ?hasValue }
}</pre>
   			</section>
   			<section>
   				<h3>Value type</h3>
   			</section>
   			<section>
   				<h3>Etc</h3>
   			</section>
    	</section>
    	
    	<section>
    		<h2>Inverse Property Constraints</h2>
    		<p class="todo">
    			Also need a section for ldom:OrConstraint somewhere
    		</p>
    	</section>
    	
    	<section>
    		<h2>Graphs and Contexts</h2>
    		<section>
    			<h3>ldom:Graph</h3>
    		</section>
    		<section>
    			<h3>ldom:include and ldom:library</h3>
    		</section>
    		<section>
    			<h3>ldom:context</h3>
    		</section>
    	</section>
    	
    	<section>
    		<h2>Constraint Checking Algorithm (Operations)</h2>
    		<p class="todo">
    			TODO. For now see <a href="https://www.w3.org/2014/data-shapes/wiki/LDOM_Algorithm">LDOM Algorithm Wiki Page</a>
    		</p>
    	</section>
    	
    	<section>
    		<h2>Profiles</h2>
    		<p class="todo">
    			TODO: Explain that ldom:Profiles can group templates together
    		</p>
    	</section>
    	
    	<section>
    		<h2>Test Case Vocabulary</h2>
    		<p class="todo">
    			TODO: Vocabulary to declare test cases and what a test engine need to do with them.
    			This could also go into another deliverable together with actual test cases
    			defined for LDOM itself.
    		</p>
    	</section>
    	
  	</body>
</html>
