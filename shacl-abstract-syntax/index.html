<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SHACL Core Abstract Semantics</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async="async" class='remove'></script>
    <script src="https://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="local.css" />
    <script class='remove'>
      var respecConfig = {
      specStatus: "ED",
      edDraftURI:  "http://w3c.github.io/data-shapes/semantics/",
      shortName:  "shacl-semantics",
      editors: [
        { name:       "Eric Prud'hommeaux",
          url:        "http://www.w3.org/People/Eric/",
          company:    "W3C/MIT",
          companyURL: "http://www.w3.org/",
          w3cid: "2112" },
        { name:       "Iovka Boneva",
          url:        "http://www.lifl.fr/~boneva/",
          company:    "ERCIM",
          companyURL: "http://www.ercim.org/",
          w3cid: "69659" },
        { name:       "Karen Coyle",
          url:        "http://kcoyle.net/",
          company:    "DCMI",
          companyURL: "http://dublincore.org/",
          w3cid: "44865" }
      ],
      wg:           "RDF Data Shapes Working Group",
      wgURI:        "https://www.w3.org/2014/data-shapes",
      wgPublicList: "public-rdf-shapes",
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
      localBiblio:  {
      "xyz": {
      title:    "Sample Custom Reference",
      href:     "http://example.org/",
      "authors": [
      "S. Steyskal"
      ],
      publisher: "xyz"
      }
      }
      };
    </script>
    <style>
      .todo {
      color: red;
      }
      pre {
      tab-size: 4;
      }
      th {
      text-align: left;
      }
      .comment {
      /* font-lock-comment-face */
      color: #b22222;
      }
      .constant {
      /* font-lock-constant-face */
      color: #008b8b;
      }
      .function-name {
      /* font-lock-function-name-face */
      color: #0000ff;
      }
      .keyword {
      /* font-lock-keyword-face */
      color: #a020f0;
      }
      .string {
      /* font-lock-string-face */
      color: #8b2252;
      }
      .type {
      /* font-lock-type-face */
      color: #228b22;
      }
      .example {
      display: inline-block;
      }
      .example.wrapper {
      background-color: #fff;
      }
      .example.wrapper pre {
      background-color: #fcfaee;
      margin-left: 0;
      line-height: 1.2;
      }
      .example.wrapper .fail {
      background-color: #fceefa
      }
      .verticalDivider {
      float: left;
      width: .5em;
      border:thin solid #fff; /* disappears without this */
      }

      .highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
      .highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
      .lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
      .highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
      .lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
      .lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */

      .highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
      .lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
      .highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
      .lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }

      .new            { font-weight: bold; }
      .errorSite      { color: red; }

      h3 sup,h4 sup,.eval {
      font-weight: lighter;
      color: #307;
      }
      .emph{
      font-style: italic;
      }

      .testrm{
      font-style: normal;
      }

      .textbf{
      font-weight: bold;
      }

      .math{
      font-style: normal;
      font-family: sans-serif;
      }

      .new{
      color: #6600FF;
      }

      .block-name{
      font-weight: bold;
      }

      .abstrsynt{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F8F8;
      }

      .Definition{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F0F0;
      }


      .quote{
      margin-left: 3em;
      }

      .smaller{
      font-size: .83em;
      }

      pre.schema.hljs.css { color: #070; border: thin solid #0f0; }
        pre.data.hljs.css { color: #007; border: thin solid #00f; }
      th.schema { color: #070; }
        th.data { color: #007; }
      pre.schema:before { content: schema }
        pre.data:before { content: data   }
      table td { vertical-align: top; }
      table th { text-align: center; }
      table { border-collapse: collapse; }
      td, th { border-style: solid; }
      tr.pass { background-color: #cfc; }
      tr.fail { background-color: #fcc; }
      span.fail { background-color: #fcc; }
    </style>
  </head>
  <body>
    <section id='abstract'>
      This document defines the core SHACL (SHApes Constraint Language) abstract syntax.
    </section>

    <section id='sotd'>

      <p>
        This is a Working Draft.
        It is not decided whether this will be a WG Note or a WG Recommendation.
      </p>
    </section>

    <!-- taken from http://www.w3.org/2014/data-shapes/charter -->
    <section id="intro" class='informative'>
      <h2>Introduction</h2>
      <p>
        SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
        SHACL constraints are grouped into "shapes", which may also be referenced by constraints in other shapes.
        These constraints describe the <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a> connecting certain nodes in the graph.
      </p>

    </section>
	  <section id="notation">
	    <h2>Notation</h2>
      <p>
        The abstact syntax consists of statements defining data structures and labeled (named?) members of those data structures.
        Each member has either a single type (data type?) or two or more types that are a union (choice) of types.
        Each type is either a reference to another statement, an RDF type, or a SPARQL literal term (e.g. <a href="http://www.w3.org/TR/sparql11-query/#operandDataTypes"><code>numeric</code></a>), or the template type <code>Set</code>, which signifies a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">logical set</a> of a type.
        Sets are unordered and duplicate members have no significance; the set <code>(1, 1, 2, 3, 5)</code> is the same as the set <code>(5, 1, 3, 2)</code>.
      </p>
      <p>In this notation:</p>
     
      <div class="abstrsynt">
        <pre>Shape := label:IRI|BNode, scopes:Set[<a href="#dfn-Scope">Scope</a>], filters:Set[<a href="#dfn-Shape">Shape</a>], constraints:Set[<a href="#dfn-Constraint">Constraint</a>]</pre>
      </div>
      <p>
        This signifies that a <code>Shape</code> has four components called <code>label</code>, <code>scopes</code>, <code>filters</code>, <code>constraints</code>.
        The <code>label</code> is either a <code>IRI</code> or <code>BNode</code>,
        the <code>scopes</code> are a set of <a href="#dfn-Scope"><code>Scope</code>s</a>,
        the <code>filters</code> are a set of <a href="#dfn-Shape"><code>Shape</code>s</a>,
        and the <code>constraints</code> is a set of <a href="#dfn-Constraint"><code>Constraint</code>s</a>.
        <code>IRI</code> and <code>BNode</code> are defined in <a href="https://www.w3.org/TR/2014/REC-rdf11-mt-20140225/#notation">RDF 1.1 Semantics</a>.
        <a href="#Scope"><code>Scope</code></a>, <a href="#Shape"><code>Shape</code></a> and <a href="#Constraint"><code>Constraint</code></a> are defined terms within this document.
      </p>
      <p>
        The term definitions given in this document rely on matching triple patterns in the form <code>(subject, predicate, object)</code> where each position may be supplied by a constant, a previously defined term, or the underscore "<code>_</code>", which represents a previously undefined element or wildcard.
        This corresponds to a <a href="https://www.w3.org/TR/sparql11-query/#defn_TriplePattern">SPARQL Triple Pattern</a> where each "_" is replaced by a unique blank node.
        Matching such a triple pattern against a graph is defined by <a href="https://www.w3.org/TR/sparql11-query/#BGPsparql">SPARQL Basic Graph Pattern Matching</a> (BFP) with a BGP containing only that triple pattern.
      </p>
      <!-- 
	    <p>
        The following HTML tags and CSS classes are used to highlight the roles of text in this document:
	    </p>
	    <ul>
        <li>&lt;dfn&gt;<dfn id="dfn-shacl-defined-term">defined term</dfn>&lt;dfn&gt;</li>
        <li>&lt;a class="internalDFN"&gt;<a title="SHACL defined term" href="#dfn-shacl-defined-term" class="internalDFN">defined term</a>&lt;/a&gt;</li>
        <li><sup class="eval">eval</sup> &mdash; link to evaluation semantics</li>
	      </ul>
      -->
	  </section>

    <section>
      <h2>Schemas and Shapes</h2>
      The SHACL environment uses two inputs: a SHACL instance graph, and a data graph. 
      A SHACL instance consists of schemas and shapes. A Schema is a set of one or more Shapes. A Shape is a set of Scopes, Filters, and Constraints. Each shape has a label that is an IRI or BNode.
      Scopes define the nodes in the data graph that are selected as targets for comparison. 
      Filters provide further refinement of the scopes if needed.
      The targeted nodes in the data graph are called "focus nodes." 
 
      <div class="abstrsynt">
        <span class="math" id="dfn-Schema">Schema        := shapes:Set[<a href="#dfn-Shape">Shape</a>]</span><br/>
        <span class="math" id="dfn-Shape">Shape         := label:IRI|BNode, scopes:Set[<a href="#dfn-Scope">Scope</a>], filters:Set[<a href="#dfn-Shape">Shape</a>], constraints:Set[<a href="#dfn-Constraint">Constraint</a>]</span>
      </div>
        <p>
        	The SHACL instance identifies the nodes in the data graph that will be matched against the constraints through the Scopes and Filters. The data graph nodes that are identified by the scopes and filters are call "focus nodes". Focus nodes are all nodes in the graph that:
        </p>
        
      <ol>
        <li>match any of the scopes, and </li>
        <li>pass all of the filter Shapes. [deal with this somewhere (Scopes in filter Shapes have no effect.)]</li>
      </ol>
      <p>
      	The output of comparison of a SHACL graph to a data graph is called a "validation" result.
        Matching returns the set of errors returned from comparing each constraint against each "focus node" in the data graph.  
      <div class="abstrsynt">
        <span class="math" id="dfn-Scope">Scope         := <a href="#dfn-ScopeNode">ScopeNode</a>|<a href="#dfn-ScopeClass">ScopeClass</a>|<a href="#dfn-PropertyScope">PropertyScope</a>|<a href="#dfn-InversePropertyScope">InversePropertyScope</a></span>
      </div>
      <p>
        A SHACL scope designates which nodes in the data graph will be @@compared to the defined constraints.
        A Scope is defined either by matching a node label (ScopeNode) in the data graph, a type statement using rdf:type (ScopeClass) or a property IRI (PropertyScope).
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-ScopeNode">ScopeNode     := node:IRI|Bnode|literal # later demands told bnodes.@@?</span>
      </div>
      <p>
        A ScopeNode matches a node (any subject or object in a triple) in the data graph.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-ScopeClass">ScopeClass    := type:IRI</span>
      </div>
      <p>
        A ScopeClass matches any node in the data graph with the triple
        <code>(node, rdf:type, type)</code>. 
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-PropertyScope">PropertyScope := predicate:IRI</span>
      </div>
      <p>
        A PropertyScope matches any subject node in the data graph with a triple
        <code>(node, predicate, _)</code> where "_" is any node. 
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-InversePropertyScope">InversePropertyScope := predicate:IRI</span>
      </div>
      <p>
        A PropertyScope matches any object node in the data graph with a triple
        <code>(_, predicate, node)</code> where "_" is any node.
      </p>

    </section>
    <section>
      <h2 id="Constraints">Constraints</h2>
      <div class="abstrsynt">
        <span class="math" id="dfn-Constraint">Constraint    := <a href="#dfn-NodeConstraint">NodeConstraint</a>|<a href="#dfn-PropertyConstraint">PropertyConstraint</a>|<a href="#dfn-InversePropertyConstraint">InversePropertyConstraint</a></span>
      </div>
      <p>
      	Constraints in the Shapes graph define the conditions that will be compared against the graph identified as the focus node in the data graph.
      	Each type of Constraint selects a value node (the object or objects of the focus node)
        and tests it against a set of Paramenters in the Shapes graph. Parameters take
        arguments @@more here
        </p>
        <p></p>
        A Constraint is either PropertyConstraint or InversePropertyConstraint
        or a NodeConstraint. 
        </p>
        <p>
        Note that the Paramenter arguments include "numeric" which is the set of SPARQL numeric
        types enumerated in SPARQL Operand Data Types
        <a href="http://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL Operand Data Types</a>.
      </p>
      <p>@@heading Exceptions</p>
      <p>
        There are three exceptions: <a href="#dfn-MinCount">MinCount</a>, <a href="#dfn-MaxCount">MaxCount</a>, and <a href="#dfn-UniqueLang">UniqueLang</a> are
        evaluated against the set of all value nodes identified for testing
        by PropertyConstraint or InversePropertyConstraint.
      </p>

      <p>
        Three other Parameters, <a href="#dfn-QualifiedMinCount">QualifiedMinCount</a>, <a href="#dfn-QualifiedMaxCount">QualifiedMaxCount</a>, and
        <a href="#dfn-QualifiedValueShape">QualifiedValueShape</a>, are evaluated against the set of all value
        nodes identified for testing by PropertyConstraint or
        InversePropertyConstraint and for which the evaluation of all other
        Parameters returned no errors.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-NodeConstraint">NodeConstraint := parms:Set[<a href="#dfn-NCParameter">NCParameter</a>]</span>
      </div>
      <p>
        Testing a NodeConstraint against a focus node returns all of the
        errors from testing each NCParameter (Node Constraint Parameter) against the the value node
        where the value node is the focus node.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-PropertyConstraint">PropertyConstraint := predicate:IRI, parms:Set[<a href="#dfn-PCParameter">PCParameter</a>]</span>
      </div>
      <p>
        Testing a NodeConstraint against a focus node returns all of the errors
        from testing each NCParameter against each value node in the triple
        <code>(focus node, predicate, value node)</code>.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-InversePropertyConstraint">InversePropertyConstraint := predicate:IRI, parms:Set[<a href="#dfn-IPCParameter">IPCParameter</a>]</span>
      </div>
      <p>
        Testing a NodeConstraint against a focus node returns all of the errors
        from testing each NCParameter against each value node in the triple
        <code>(value node, predicate, focus node)</code>.
      </p>

    </section>
    <section>
      <h2 id="Parameters">Parameters</h2>
      <p>
        The specific ways a value or value set can be constrained are called <code>Parameters</code>.
        They are grouped below.
        Each group is 
      </p>
      <p>
        <dfn id="dfn-NCParameter">NCParameters</dfn>, <dfn id="dfn-PCParameter">PCParameters</dfn> and <dfn id="dfn-IPCParameter">IPCParameters</dfn> are listed in the first table in <a href="http://w3c.github.io/data-shapes/shacl/#h-constraints">SHACL table 1</a>.
        They are indicated in the Parameter groups below by "NC", "PC" and "IPC" respectively.
      </p>
      <section>
        <h3 id="NaryParameters">Nary Parameters</h3>
        <p>
          Nary Parameters evaluate the set of value nodes which were selected by the <a href="#dfn-Constraint">Constraints</a>.
        </p>
        <section>
          <h4 id="Cardinality">Cardinality: PC, ICP</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-MinCount">MinCount      := ref:numeric</span>
          </div>
          <p>
            Testing a MinCount parameter against a set of value nodes returns an
            error if the number of value nodes is less than ref.
          </p>
          
          <div class="abstrsynt">
            <span class="math" id="dfn-QualifiedMinCount">QualifiedMinCount := ref:numeric</span>
          </div>
          <p>
            As noted above, QualifiedMinCount takes a set of value nodes that
            have passed all non-cardinality tests. It's evaluation is the same
            as the evaluation of MinCount.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxCount">MaxCount      := ref:numeric</span>
          </div>
          <p>
            Testing a MaxCount parameter against a set of value nodes returns an
            error if the number of value nodes is greater than ref.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-QualifiedMaxCount">QualifiedMaxCount := ref:numeric</span>
          </div>
          <p>
            As noted above, QualifiedMaxCount takes a set of value nodes that
            have passed all non-cardinality tests. It's evaluation is the same
            as the evaluation of MaxCount.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-UniqueLang">UniqueLang    := b:boolean</span>
          </div>
          <p>
            Testing a UniqueLang parameter against a set of value nodes returns an
            error if two or more of the value nodes are RDFLiterals with the same
            language tag.
          </p>

        </section>
      </section>
      <section>
        <h3 id="UnaryParameters">Unary Parameters</h3>
        <p>
          Unary Parameters evaluate each node in the set of value nodes which were selected by the <a href="#dfn-Constraint">Constraints</a>.
        </p>

        <section>
          <h4 id="Logicaloperators">Logical operators: NC, PC, IPC</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-And">And           := shapes:Set[Shape]</span>
          </div>
          <p>
            Testing an And parameter against a value node returns the errors from
            testing each of shapes against the value node.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Example 1</span></div>
            <pre class="schema">
&lt;Person&gt; sh:property [ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .
&lt;Customer&gt; sh:property [ sh:predicate corp:custId; sh:datatype xsd:integer ] .
&lt;User&gt; sh:constraint [ sh:and (&lt;Person&gt; &lt;Customer&gt;) ] .</pre>
            <pre class="data">
&lt;user1&gt; foaf:name "Alice"; corp:custId 1234 .
<span class="fail">&lt;user2&gt; foaf:givenName "Alice"; corp:custId 1234.0 .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;User&gt;</td><td>&lt;user1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;User&gt;</td><td>&lt;user2&gt;</td><td>fail</td><td class="fail">no foaf:name supplied.<br/>"12345.0" is an xsd:double.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-Or">Or            := shapes:Set[Shape]</span>
          </div>
          <p>
            Testing an Or parameter against a value node returns an unspecified
            error if testing each of shapes against the value node returned an
            error.
          </p>
          
          <div class="abstrsynt">
            <span class="math" id="dfn-Not">Not           := shape:Shape</span>
          </div>
          <p>
            Testing an Or parameter against a value node returns an unspecified
            error if testing shape against the value node returned no
            error.
          </p>

        </section>
        <section>
          <h4 id="RDFtermtypeofvaluenode">RDF term type of value node: NC, PC, IPC</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-NodeKind">NodeKind      := kind:"IRI"|"blank node"|"literal"</span>
          </div>
          <p>
            Testing a NodeKind parameter against a value node returns an error if
          </p>
          <ul>
            <li>kind = "IRI" and value node is not an IRI</li>
            <li>kind = "blank node" and value node is not an blank node</li>
            <li>kind = "literal" and value node is not an RDFLiteral</li>
          </ul>

        </section>
        <section>
          <h4 id="RDFtermequivalence">RDF term equivalence: NC, PC, IPC</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-HasValue">HasValue      := val:RDF term @@ listed as PC, IPC as of 2016-06-30</span>
          </div>
          <p>
            Testing a HasValue parameter against a value node returns an error if
            the value node is a different RDF term than val.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-In">In            := vals:Set[RDF term]</span>
          </div>
          <p>
            Testing a HasValue parameter against a value node returns an error if
            the value node is not in vals.
          </p>

        </section>
        <section>
          <h4 id="Datatype">Datatype: NC, PC</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-Datatype">Datatype      := dt:IRI</span>
          </div>
          <p>
            Testing a Datatype parameter against a value node returns an error if
            the value node is not an RDFLiteral or of the datatype of the value
            node is not the same RDF term as dt.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-DatatypeIn">DatatypeIn    := dts:Set[IRI]</span>
          </div>
          <p>
            Testing a Datatype parameter against a value node returns an error if
            the value node is not an RDFLiteral or of the datatype of the value
            node is not the set dts.
          </p>

        </section>
        <section>
          <h4 id="XMLSchemastringfacets">XML Schema string facets: NC, PC, ICP</h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-MinLength">MinLength     := ref:numeric</span>
          </div>
          <p>
            Testing a MinLength paramenter against a value node returns an error
            if the lexical form of the value node is longer than ref.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxLength">MaxLength     := ref:numeric</span>
          </div>
          <p>
            Testing a MinLength paramenter against a value node returns an error
            if the lexical form of the value node is shorter than ref.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Pattern">Pattern       := pat:RDFLiteral</span>
          </div>
          <p>
            Testing a Pattern paramenter against a value node returns an error
            if evaluating the SPARQL regex function with the lexical form of
            value node and pat is false or results in a type error.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Stem">Stem          := str:RDFLiteral</span>
          </div>
          <p>
            Testing a Stem parameter against a value node returns an error if
            the value node is not an IRI or the lexical form of the value node
            does not start with str.
          </p>

        </section>
        <section>
          <h4 id="XMLSchemanumericfacets">XML Schema numeric facets: NC, PC</h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-MaxExclusive">MaxExclusive  := ref:RDFLitera</span>
          </div>
          <p>
            Testing a MaxExclusive parameter against a value node returns an
            error if the evaluation of (value node > ref) in SPARQL1.1 Operator
            Mapping returns false or results in a type error.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxInclusive">MaxInclusive  := ref:RDFLiteral</span>
          </div>
          <p>
            Testing a MaxExclusive parameter against a value node returns an
            error if the evaluation of (value node >= ref) in SPARQL1.1 Operator
            Mapping returns false or results in a type error.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MinExclusive">MinExclusive  := ref:RDFLiteral</span>
          </div>
          <p>
            Testing a MaxExclusive parameter against a value node returns an
            error if the evaluation of (value node > ref) in SPARQL1.1 Operator
            Mapping returns false or results in a type error.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MinInclusive">MinInclusive  := ref:RDFLiteral</span>
          </div>
          <p>
            Testing a MaxExclusive parameter against a value node returns an
            error if the evaluation of (value node >= ref) in SPARQL1.1 Operator
            Mapping returns false or results in a type error.
          </p>

        </section>
        <section>
          <h4 id="Comparisonwithsiblingproperty">Comparison with sibling property: PC</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-Equals">Equals        := sibling:RDFLiteral</span>
          </div>
          <p>
            Testing an Equals parameter against a value node returns an
            error if there is no node v in (focus node, sibling, v) in the data
            graph or the evaluation of (value node = v) in SPARQL1.1 Operator
            Mapping returns false or results in a type error.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-LessThan">LessThan      := sibling:RDFLiteral</span>
          </div>
          <p>
            Testing an LessThan parameter against a value node returns an
            error if there is no node v in (focus node, sibling, v) in the data
            graph or the evaluation of (value node &lt; v) in SPARQL1.1 Operator
            Mapping returns false or results in a type error.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-LessThanEquals">LessThanEquals := sibling:RDFLiteral</span>
          </div>
          <p>
            Testing an LessThanEquals parameter against a value node returns an
            error if there is no node v in (focus node, sibling, v) in the data
            graph or the evaluation of (value node &lt;= v) in SPARQL1.1 Operator
            Mapping returns false or results in a type error.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Disjoint">Disjoint      := sibling:RDFLiteral</span>
          </div>
          <p>
            Testing an Disjoint parameter against a value node returns an
            error if any node v in (focus node, sibling, v) in the data graph
            or the evaluation of (value node &lt; v) in SPARQL1.1 Operator Mapping
            returns false or results in a type error.
          </p>

        </section>
        <section>
          <h4 id="Nestedshapeconstraints">Nested shape constraints: PC, IPC</h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-Shape">Shape         := nested:Shape @@  listed as NC, PC, IPC as of 2016-06-30</span>
          </div>
          <p>
            Testing a Shape parameter against a value node returns any errors
            returned when validating the value node as nested (c.f. definition
            of Shape above).
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-QualifiedValueShape">QualifiedValueShape := nested:Shape</span>
          </div>
          <p>
            As noted above, QualifiedValueShape takes a set of value nodes that
            have passed all non-cardinality tests. It's evaluation is the same
            as the evaluation of Shape.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Class">Class         := t:IRI @@ + subClassOf*</span>
          </div>
          <p>
            Testing a Class parameter against a value node returns any errors
            returned when validating the value node as a Shape with a single
            PropertyConstraint with a predicate(rdf:type) and HasValue(t).
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-ClassIn">ClassIn       := t:IRI @@ + subClassOf*</span>
          </div>
          <p>
            Testing a ClassIn parameter against a value node returns any errors
            returned when validating the value node as a Shape with a single
            PropertyConstraint with a predicate(rdf:type) and In(t).
          </p>
        </section>
      </section>
    </section>
    <script>
      $("m").wrapInner("<span class='math'/>").children(0).unwrap();
    </script>
  </body>
</html>
