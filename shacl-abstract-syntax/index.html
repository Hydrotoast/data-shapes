<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>SHACL Core Abstract Syntax and Semantics</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async="async" class='remove'></script>
    <script src="https://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="local.css" />
    <script class='remove'>
      var respecConfig = {
      specStatus: "ED",
      edDraftURI:  "http://w3c.github.io/data-shapes/semantics/",
      shortName:  "shacl-semantics",
      editors: [
        { name:       "Eric Prud'hommeaux",
          url:        "http://www.w3.org/People/Eric/",
          company:    "W3C/MIT",
          companyURL: "http://www.w3.org/",
          w3cid: "2112" },
        { name:       "Karen Coyle",
          url:        "http://kcoyle.net/",
          company:    "DCMI",
          companyURL: "http://dublincore.org/",
          w3cid: "44865" }
      ],
      wg:           "RDF Data Shapes Working Group",
      wgURI:        "https://www.w3.org/2014/data-shapes",
      wgPublicList: "public-rdf-shapes",
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
      localBiblio:  {
      "xyz": {
      title:    "Sample Custom Reference",
      href:     "http://example.org/",
      "authors": [
      "S. Steyskal"
      ],
      publisher: "xyz"
      }
      }
      };
    </script>
		<!-- <script src="https://www.w3.org/scripts/jquery/2.1/jquery.min.js"></script>  -->
    <style>
      .todo {
      color: red;
      }
      pre {
      tab-size: 4;
      }
      th {
      text-align: left;
      }
      .comment {
      /* font-lock-comment-face */
      color: #b22222;
      }
      .constant {
      /* font-lock-constant-face */
      color: #008b8b;
      }
      .function-name {
      /* font-lock-function-name-face */
      color: #0000ff;
      }
      .keyword {
      /* font-lock-keyword-face */
      color: #a020f0;
      }
      .string {
      /* font-lock-string-face */
      color: #8b2252;
      }
      .type {
      /* font-lock-type-face */
      color: #228b22;
      }
      .example {
      display: inline-block;
      }
      .example.wrapper {
      background-color: #fff;
      }
      .example.wrapper pre {
      background-color: #fcfaee;
      margin-left: 0;
      line-height: 1.2;
      }
      .example.wrapper .fail {
      background-color: #fceefa
      }
      .verticalDivider {
      float: left;
      width: .5em;
      border:thin solid #fff; /* disappears without this */
      }

      .highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
      .highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
      .lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
      .highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
      .lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
      .lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */

      .highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
      .lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
      .highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
      .lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }

      .new            { font-weight: bold; }
      .errorSite      { color: red; }

      h3 sup,h4 sup,.eval {
      font-weight: lighter;
      color: #307;
      }
      .emph{
      font-style: italic;
      }

      .testrm{
      font-style: normal;
      }

      .textbf{
      font-weight: bold;
      }

      .math{
      font-style: normal;
      font-family: sans-serif;
      }

      .new{
      color: #6600FF;
      }

      .block-name{
      font-weight: bold;
      }

      .abstrsynt{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F8F8;
      }
      .abstrsynt.squished{ padding-top: 0; padding-bottom: 0; border: none; margin-top: 0; margin-bottom: 0; }
      h2.squished,h3.squished,h4.squished { margin-top: 1ex; margin-bottom: 0; }

      .Definition{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F0F0;
      }


      .quote{
      margin-left: 3em;
      }

      .smaller{
      font-size: .83em;
      }

      pre.schema.hljs.css { color: #070; border: thin solid #0f0; }
        pre.data.hljs.css { color: #007; border: thin solid #00f; }
      th.schema { color: #070; }
        th.data { color: #007; }
      pre.schema:before { content: schema }
        pre.data:before { content: data   }
      table td { vertical-align: top; }
      table th { text-align: center; }
      table { border-collapse: collapse; }
      td, th { border-style: solid; }
      tr.pass { background-color: #cfc; }
      tr.fail { background-color: #fcc; }
      span.fail { background-color: #fcc; }

      .param { color: #3500c8; }
      .rdf { border-left: thick solid #77f; padding-left: .5em; }
    </style>
  </head>
  <body>
    <section id='abstract'>
      This document defines an abstract syntax for the core SHACL (SHApes Constraint Language). It is derived from 
      the <a href="http://www.w3.org/TR/shacl/">SHACL specification</a>[[!shacl]] and is a non-normative version of the content of that specification.
    </section>

    <section id='sotd'>

      <p>
        This is currently a Working Draft.
        It is not decided whether this will be a Working Group Note, a Working Group Recommendation, or an appendix to the SHACL specification.
      </p>
    </section>

    <!-- taken from http://www.w3.org/2014/data-shapes/charter -->
    <section id="intro" class='informative'>
      <h2>Introduction</h2>
      <p>
        SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>[[!rdf11-concepts]].
        SHACL constraints are grouped into "shapes", which may also be referenced by constraints in other shapes.
        These constraints describe the <a href="https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a>[[!rdf11-concepts]] connecting certain nodes in the graph.
      </p>

    </section>
	  <section id="notation">
	    <h2>Notation</h2>
      <p>
        The abstract syntax consists of statements defining data structures and labeled (named?) members of those data structures.
        Each member has either a single type (data type?) or two or more types that are a union (choice) of types.
        Each type is either a reference to another statement, an RDF type, or a <a href="https://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL literal term</a> (e.g. <code>numeric</code>)[[!sparql11-query]], or the template type <code>Set</code>, which signifies a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">logical set</a> of a type.
        Sets are unordered and duplicate members have no significance; the set <code>(1, 1, 2, 3, 5)</code> is the same as the set <code>(5, 1, 3, 2)</code>.
      </p>
      <p>In this notation:</p>
     
      <div class="abstrsynt">
        <span class="math">Shape := label:IRI|BNode, targetss:Set[<a href="#dfn-Target">Target</a>], filters:Set[<a href="#dfn-Shape">Shape</a>], constraints:Set[<a href="#dfn-Constraint">Constraint</a>]</span>
      </div>
      <p>
        This signifies that a <code>Shape</code> has four components called <code>label</code>, <code>targets</code>, <code>filters</code>, <code>constraints</code>.
        The <code>label</code> is either a <code>IRI</code> or <code>BNode</code>,
        the <code>targets</code> are a set of <a href="#dfn-Target"><code>Target</code>s</a>,
        the <code>filters</code> are a set of <a href="#dfn-Shape"><code>Shape</code>s</a>,
        and the <code>constraints</code> is a set of <a href="#dfn-Constraint"><code>Constraint</code>s</a>.
        <code>IRI</code> and <code>BNode</code> are <a href="https://www.w3.org/TR/2014/REC-rdf11-mt-20140225/#notation">defined in RDF 1.1 Semantics</a>[[!rdf11-mt]].
        <a href="#Scope"><code>Scope</code></a>, <a href="#Shape"><code>Shape</code></a> and <a href="#Constraint"><code>Constraint</code></a> are defined terms within this document.
      </p>
      <p>
        The term definitions given in this document rely on matching triple patterns in the form <code>(subject, predicate, object)</code> where each position may be supplied by a constant, a previously defined term, or the underscore "<code>_</code>", which represents a previously undefined element or wildcard.
        This corresponds to a <a href="https://www.w3.org/TR/sparql11-query/#defn_TriplePattern">SPARQL Triple Pattern</a> where each "_" is replaced by a unique blank node.
        Matching such a triple pattern against a graph is defined by <a href="https://www.w3.org/TR/sparql11-query/#BGPsparql">SPARQL Basic Graph Pattern Matching</a> (BFP) with a BGP containing only that triple pattern.
      </p>
      <button id="toggleRDF">Toggle RDF ("r")</button> <button id="toggleExamples">Toggle Examples ("e")</button> <button id="toggleSquished">Render only abstract syntax ("a")</button>

      <p class="rdf">
        Sections defining the RDF representation of SHACL with have a .rdf class.
      </p>
      <div class="example">
        <p>
          Results of validation are represented in a table associating node/shape pairs with a pass or fail and a reason for failure:
        </p>
      <table>
        <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
        <tr class="pass"><td>&lt;Shape1&gt;</td><td>&lt;node1&gt;</td><td>pass</td></tr>
        <tr class="fail"><td>&lt;Shape1&gt;</td><td>&lt;node2&gt;</td><td>fail</td><td class="fail">no <code>ex:state</code> supplied.</td></tr>
      </table>
      </div>
      <!-- 
	    <p>
        The following HTML tags and CSS classes are used to highlight the roles of text in this document:
	    </p>
	    <ul>
        <li>&lt;dfn&gt;<dfn id="dfn-shacl-defined-term">defined term</dfn>&lt;dfn&gt;</li>
        <li>&lt;a class="internalDFN"&gt;<a title="SHACL defined term" href="#dfn-shacl-defined-term" class="internalDFN">defined term</a>&lt;/a&gt;</li>
        <li><sup class="eval">eval</sup> &mdash; link to evaluation semantics</li>
	      </ul>
      -->
	  </section>

    <section>
      <h2>Schemas and Shapes</h2>
      <p>
      The SHACL environment uses two inputs: a SHACL instance graph, and a data graph. 
      A SHACL instance consists of schemas and shapes. A Schema is a set of one or more Shapes. A Shape is a set of Targets, Filters, and Constraints. Each shape has a label that is an IRI or BNode.
      Targets define the nodes in the data graph that are selected as targets for comparison. 
      Filters provide further refinement of the targets if needed.
      The targeted nodes in the data graph are called "focus nodes."
      </p>
 
      <div class="abstrsynt">
        <span class="math" id="dfn-Schema">Schema        := shapes:Set[<a href="#dfn-Shape">Shape</a>]</span><br/>
        <span class="math" id="dfn-Shape">Shape         := <code class="param">label</code>:IRI|BNode, <code class="param">targets</code>:Set[<a href="#dfn-Target">Target</a>], <code class="param">filters</code>:Set[<a href="#dfn-Shape">Shape</a>], <code class="param">constraints</code>:Set[<a href="#dfn-Constraint">Constraint</a>]</span>
      </div>
      <div class="rdf">
      <p>
        Shapes are represented in RDF as a subject node that is the shape's <code class="param">label</code> with a set of properties identifying the types of any <code class="param">targets</code>, <code class="param">filters</code> and <code class="param">constraints</code>.
        For a first example, a specific form of <a href="#dfn-Constraint">Constraint</a>, a <a href="#dfn-PathConstraint">PathConstraint</a><!-- <a href="#dfn-PropertyConstraint">PropertyConstraint</a> -->, which requires that conforming nodes have a <code>foaf:name</code> property with a value that is an RDF literal would look like this:
      </p>
      <pre class="schema">[ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .</pre>
      <p>
        A Shape with the <code class="param">label</code> IRI &lt;http://a.example/Person&gt; and only that <code class="param">constraint</code> would have a <code>sh:property</code> arc connecting the shape <code class="param">label</code> to the above <code class="param">constraint</code>:
      </p>
      <pre class="schema">&lt;Person&gt; sh:property [ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .</pre>
      <p>
        Here, <code>sh:property</code> identifies a <a href="#dfn-PathConstraint">PathConstraint</a> <!-- <a href="#dfn-PropertyConstraint">PropertyConstraint</a> --> <code class="param">constraint</code>; other properties identify other forms of <code class="param">targetss</code>, <code class="param">filters</code> and <code class="param">constraints</code>.
        These properties will be enumerated in the definitions below.
      </p>
      </div>
        <p>
        	The SHACL instance graph identifies the nodes in the data graph selected through <code class="param">targets</code> and <code class="param">filters</code> and that will be compared against the defined constraints.
          The data graph nodes that are identified by the <code class="param">targets</code> and <code class="param">filters</code> are call "focus nodes". Focus nodes are all nodes in the graph that:
        </p>
        
      <ol>
        <li>match any of the targets, and </li>
        <li>pass all of the filter Shapes. [deal with this somewhere (Targets in filter Shapes have no effect.)]</li>
      </ol>
      <p>
      	The output of comparison of a SHACL graph to a data graph is called a "validation" result.
        Matching returns the set of errors returned from comparing each constraint against each "focus node" in the data graph.
      </p>
    </section>

    <section>
      <h2 id="Constraints">Constraints</h2>
      <div class="abstrsynt">
        <span class="math" id="dfn-Constraint">Constraint    := <a href="#dfn-NodeConstraint">NodeConstraint</a>|<a href="#dfn-PathConstraint">PathConstraint</a><!-- <a href="#dfn-PropertyConstraint">PropertyConstraint</a>|<a href="#dfn-InversePropertyConstraint">InversePropertyConstraint</a> --></span>
      </div>
      <p>
      	Constraints in the Shapes graph define the conditions that will be compared against the node in the data graph identified as the focus node.
      	Each type of Constraint selects a value node (the object or objects of the focus node) and tests it against a set of Paramenters in the Shapes graph.
        Parameters take arguments @@more here
        </p>
        <p>
          A Constraint is either PathConstraint <!-- PropertyConstraint or InversePropertyConstraint --> or a NodeConstraint. 
        </p>
        <p>
          Note that the Paramenter arguments include "numeric" which is the set of SPARQL numeric types enumerated in SPARQL Operand Data Types <a href="http://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL Operand Data Types</a>.
      </p>
      <p class="note" title="Exceptions">
        There are three exceptions: <a href="#dfn-MinCount">MinCount</a>, <a href="#dfn-MaxCount">MaxCount</a>, and <a href="#dfn-UniqueLang">UniqueLang</a> are evaluated against the set of all value nodes identified for testing by PropertyConstraint <!-- PropertyConstraint or InversePropertyConstraint. -->
      </p>

      <p>
        Three other Parameters, <a href="#dfn-QualifiedMinCount">QualifiedMinCount</a>, <a href="#dfn-QualifiedMaxCount">QualifiedMaxCount</a>, and <a href="#dfn-QualifiedValueShape">QualifiedValueShape</a>, are evaluated against the set of all value nodes identified for testing by PathConstraint <!-- PropertyConstraint or InversePropertyConstraint --> and for which the evaluation of all other Parameters returned no errors.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-NodeConstraint">NodeConstraint := <code class="param">parms</code>:Set[<a href="#dfn-NCParameter">NCParameter</a>]</span>
      </div>
      <p>
        Testing a NodeConstraint against a focus node returns all of the errors from testing each NCParameter (Node Constraint Parameter) against the value node where the value node is the focus node.
      </p>

      <!-- 
      <div class="abstrsynt">
        <span class="math" id="dfn-PropertyConstraint">PropertyConstraint := <code class="param">predicate</code>:IRI, <code class="param">parms</code>:Set[<a href="#dfn-PCParameter">PCParameter</a>]</span>
      </div>
      <p>
        Testing a PropertyConstraint against a focus node returns all of the errors from testing each PCParameter against each value node in the triple <code>(focus node, predicate, value node)</code>.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-InversePropertyConstraint">InversePropertyConstraint := <code class="param">predicate</code>:IRI, <code class="param">parms</code>:Set[<a href="#dfn-IPCParameter">IPCParameter</a>]</span>
      </div>
      <p>
        Testing an InversePropertyConstraing against a focus node returns all of the errors from testing each IPCParameter against each value node in the triple <code>(value node, predicate, focus node)</code>.
      </p>
      -->

      <div class="abstrsynt">
        <span class="math" id="dfn-PathConstraint">PathConstraint := <code class="param">path</code>:<a href="https://www.w3.org/TR/sparql11-query/#pp-language">SPARQLPropertyPath</a>, <code class="param">parms</code>:Set[<a href="#dfn-PCParameter">PCParameter</a>]</span>
      </div>
      <p>
        A SPARQLPropertyPath is a property path as defined in [[!sparql11-query]].
        Testing a PathConstraint against a focus node returns all of the errors from testing each PCParameter against each value node in the <a href="https://www.w3.org/TR/sparql11-query/#defn_PropertyPathPattern">SPARQL1.1 Property Path Pattern</a> <code>(focus node, <code class="param">path</code>, value node)</code>.
        The <code class="param">path</code> is an expression in the <a href="https://www.w3.org/TR/sparql11-query/#pp-language">SPARQL1.1 Property Path language</a> excluding the forms of negation: <code>NegatedPropertySet</code>.
        Note that this includes <code>InversePath</code>.
      </p>

    </section>

    <section>
      <h2 id="Parameters">Parameters</h2>
      <p>
        The specific ways a value or value set can be constrained are called <code>Parameters</code>.
        They are grouped below.
        Each group is 
      </p>
      <p>
        <dfn id="dfn-NCParameter">NCParameters</dfn> and <dfn id="dfn-PCParameter">PCParameters</dfn> <!-- and <dfn id="dfn-IPCParameter">IPCParameters</dfn> --> are listed in the first table in <a href="http://w3c.github.io/data-shapes/shacl/#h-constraints">SHACL table 1</a>.
        They are indicated in the Parameter groups below by "NC" and "PC" <!-- and "IPC" --> respectively.
      </p>
      <section>
        <h3 id="UnaryParameters">Unary Parameters</h3>
        <p>
          Unary Parameters evaluate each node in the set of value nodes which were selected by the <a href="#dfn-Constraint">Constraints</a>.
        </p>

        <section>
          <h4 id="RDFtermtypeofvaluenode">RDF term type of value node: NC, PC <!-- , IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-NodeKind">NodeKind      := <code class="param">kind</code>:"IRI"|"blank node"|"literal"</span>
          </div>
          <p>
            Testing a NodeKind parameter against a value node returns an error if
          </p>
          <ul>
            <li><code class="param">kind</code> = "IRI" and value node is not an IRI</li>
            <li><code class="param">kind</code> = "blank node" and value node is not an blank node</li>
            <li><code class="param">kind</code> = "literal" and value node is not an RDFLiteral</li>
          </ul>
          <p class="rdf">
            A NodeKind parameter is connected to a constraint by the <code>sh:nodeKind</code> predicate; the node kinds are represented by the constants <code>sh:IRI</code>, <code>sh:BlankNode</code> and <code>sh:literal</code> respectively.
            The following combinations represent disjunctions of the above node kinds: <code>sh:BlankNodeOrIRI</code>, <code>sh:IRIOrLiteral</code>, <code>sh:BlankNodeOrLiteral</code>, <code>sh:IRIOrLiteral</code>, <code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code>.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 1</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:state; sh:nodeKind sh:IRI ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:state ex:HunkyDory .
<span class="fail">&lt;issue2&gt; ex:taste ex:GoodEnough .</span>
<span class="fail">&lt;issue3&gt; ex:state "just fine" .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">no <code>ex:state</code> supplied.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be an IRI, literal found.</td></tr>
            </table>
          </div>

        </section>

        <section>
          <h4 id="RDFtermequivalence">RDF term equivalence: NC, PC <!-- , IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-HasValue">HasValue      := <code class="param">val</code>:RDF term @@ listed as PC <!-- , IPC --> as of 2016-06-30</span>
          </div>
          <p>
            Testing a HasValue parameter against a value node returns an error if
            the value node is a different RDF term than <code class="param">val</code>.
          </p>
          <p class="rdf">
            A HasValue parameter is connected to a constraint by the <code>sh:hasValue</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 2</span></div>
            <pre class="schema">
&lt;ResolveIssueShape&gt; sh:property [ sh:predicate ex:state; sh:hasValue ex:Resolved ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:state ex:Resolved .
<span class="fail">&lt;issue2&gt; ex:taste ex:Resolved .</span>
<span class="fail">&lt;issue3&gt; ex:state ex:Unresolved .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;ResolvedIssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;ResolvedIssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">no <code>ex:state</code> supplied.</td></tr>
              <tr class="fail"><td>&lt;ResolvedIssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be <code>ex:Resolved</code>, <code>ex:Unresolved</code> found.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-In">In            := <code class="param">vals</code>:Set[RDF term]</span>
          </div>
          <p>
            Testing a In parameter against a value node returns an error if the value node is not in the set <code class="param">vals</code>.
          </p>
          <p class="rdf">
            An In parameter in RDF is represented as an RDF collection connected to a constraint by the <code>sh:in</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 3</span></div>
            <pre class="schema">
&lt;NoActionIssueShape&gt; sh:property [ sh:predicate ex:state; sh:in (ex:Resolved, ex:Rejected) ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:state ex:Resolved .
<span class="fail">&lt;issue2&gt; ex:taste ex:Resolved .</span>
<span class="fail">&lt;issue3&gt; ex:state ex:Unresolved .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">no <code>ex:state</code> supplied.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be <code>ex:Resolved</code>, <code>ex:Unresolved</code> found.</td></tr>
            </table>
          </div>
          <p class="issue">Why have a special property for singleton value sets?</p>
        </section>

        <section>
          <h4 id="Datatype">Datatype: NC, PC</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-Datatype">Datatype      := <code class="param">dt</code>:IRI</span>
          </div>
          <p>
            Testing a Datatype parameter against a value node returns an error if the value node is not an RDFLiteral or of the datatype of the value node is not the same RDF term as <code class="param">dt</code>.
          </p>
          <p class="rdf">
            A Datatype parameter is connected to a constraint by the <code>sh:datatype</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 4</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:submittedOn; sh:datatype xsd:dateTime ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedOn "2016-07-08"^^xsd:date .
<span class="fail">&lt;issue2&gt; ex:date "2016-07-08"^^xsd:date .</span>
<span class="fail">&lt;issue3&gt; ex:submittedOn "2016-07-08T01:23:45Z"^^xsd:dateTime .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">no <code>ex:submittedOn</code> supplied.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:submittedOn</code> expected to be an <code>xsd:date</code>, <code>xsd:dateTime</code> found.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-DatatypeIn">DatatypeIn    := <code class="param">dts</code>:Set[IRI]</span>
          </div>
          <p>
            Testing a Datatype parameter against a value node returns an error if the value node is not an RDFLiteral or of the datatype of the value node is not the set <code class="param">dts</code>.
          </p>
          <p class="issue">Does DatatypeIn have enough use cases to warrant a special property rather than an <a href="#dfn-Or">or</a> of multiple <a href="#dfn-Datatype"></a> constraints?</p>

        </section>

        <section>
          <h4 id="XMLSchemastringfacets">XML Schema string facets: NC, PC <!-- , IPC --></h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-MinLength">MinLength     := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            Testing a MinLength paramenter against a value node returns an error if the lexical form of the value node is longer than <code class="param">ref</code>.
          </p>
          <p class="rdf">
            A MinLength parameter is connected to a constraint by the <code>sh:minLength</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 5</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:submittedBy; sh:minLength 20 ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedBy &lt;http://a.example/bob&gt; . <span class="comment"># 20 characters</span>
<span class="fail">&lt;issue2&gt; ex:submitter "Robert W. Smith Esquire" .</span> <span class="comment"># 23 characters</span>
<span class="fail">&lt;issue3&gt; ex:submittedBy "Bob" .</span> <span class="comment"># 3 characters</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">no <code>ex:submittedBy</code> supplied.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:submittedOn</code> expected to be MinLength 20 characters, 3 characters found.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxLength">MaxLength     := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            Testing a MaxLength paramenter against a value node returns an error if the lexical form of the value node is shorter than <code class="param">ref</code>.
          </p>
          <p class="rdf">
            A MaxLength parameter is connected to a constraint by the <code>sh:maxLength</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Pattern">Pattern       := <code class="param">pat</code>:RDFLiteral, <code class="param">flagstr</code>:RDFLiteral</span>
          </div>
          <p>            
            A Pattern parameter is evaluated against the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL regex function</a> with the lexical form of value node as the <code class="param">text</code> parameter, <code class="param">pat</code> as the <code class="param">pattern</code> parameter and <code class="param">flagstr</code> as the <code class="param">flags</code> parameter.
            The test returns an error is the result is false or produces a type error.
          </p>
          <p class="rdf">
            A Pattern parameter is connected to a constraint by the <code>sh:pattern</code> predicate.
            An optional <code>sh:flags</code> property can supply the <code class="param">flags</code> parameter.
            It is an error for a constraint to have more than one <code>sh:flags</code> property or a single <code>sh:flags</code> property and more than one <code>sh:pattern</code> property.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 6</span></div>
            <pre class="schema">
&lt;IssueShape1&gt; sh:property [ sh:predicate ex:submittedBy; sh:pattern "^HtTp://" ; sh:flags "i" ] .
&lt;IssueShape2&gt; sh:property [ sh:predicate ex:submittedBy; sh:pattern " +" ; sh:flags "@" ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedBy &lt;http://a.example/bob&gt; . <span class="comment"># matches &lt;IssueShape1&gt;'s case-insensitive pattern</span>
&lt;issue2&gt; ex:submittedBy "http://hahaha!" . <span class="comment"># also matches &lt;IssueShape1&gt;'s pattern</span>
<span class="fail">&lt;issue3&gt; ex:submittedBy &lt;mailto:bob@example.com&gt; .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape1&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="pass"><td>&lt;IssueShape1&gt;</td><td>&lt;issue2&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape1&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>mailto:bob@example.com</code> does not match the pattern <code>/^HtTp:\/\//i</code></td></tr>
              <tr class="fail"><td>&lt;IssueShape2&gt;</td><td>&lt;issue1&gt;</td><td>fail</td><td class="fail"><code>@</code> is not a valid flag string.</td></tr>
              <tr class="fail"><td>&lt;IssueShape2&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>@</code> is not a valid flag string.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-Stem">Stem          := <code class="param">str</code>:RDFLiteral</span>
          </div>
          <p>
            Testing a Stem parameter against a value node returns an error if the value node is not an IRI or the lexical form of the value node does not start with <code class="param">str</code>.
          </p>

        </section>

        <section>
          <h4 id="XMLSchemanumericfacets">XML Schema numeric facets: NC, PC</h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-MinInclusive">MinInclusive  := <code class="param">ref</code>:RDFLiteral</span>
          </div>
          <p>
            Testing a MinInclusive parameter against a value node returns an error if the evaluation of (value node &gt;= <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A MinInclusive parameter is connected to a constraint by the <code>sh:minInclusive</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 7</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:confirmations; sh:minInclusive 1 ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:confirmations 1 .
&lt;issue2&gt; ex:confirmations 0 .
<span class="fail">&lt;issue3&gt; ex:confirmations "ii"^^ex:romanNumeral .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>0</code> is less than <code>1</code>.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:romanNumeral</code> is not a numeric datatype.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-MinExclusive">MinExclusive  := <code class="param">ref</code>:RDFLiteral</span>
          </div>
          <p>
            Testing a MinExclusive parameter against a value node returns an error if the evaluation of (value node &gt; <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A MinExclusive parameter is connected to a constraint by the <code>sh:minExclusive</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxInclusive">MaxInclusive  := <code class="param">ref</code>:RDFLiteral</span>
          </div>
          <p>
            Testing a MaxInclusive parameter against a value node returns an error if the evaluation of (value node &lt;= <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>         
          <p class="rdf">
            A MaxInclusive parameter is connected to a constraint by the <code>sh:maxInclusive</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxExclusive">MaxExclusive  := <code class="param">ref</code>:RDFLitera</span>
          </div>
          <p>
            Testing a MaxExclusive parameter against a value node returns an error if the evaluation of (value node &lt <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A MaxExclusive parameter is connected to a constraint by the <code>sh:maxExclusive</code> predicate.
          </p>

        </section>

        <section>
          <h4 id="Comparisonwithsiblingproperty">Comparison with sibling property: PC</h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-LessThan">LessThan      := <code class="param">sibling</code>:RDFLiteral</span>
          </div>
          <p>
            Testing a LessThan parameter against a value node returns an error if there is no node v in <code>(focus node, <code class="param">sibling</code>, v)</code> in the data graph or the evaluation of (value node &lt; v) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A LessThan's <code class="param">sibling</code> parameter is connected to a constraint by the <code>sh:lessThan</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 4</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:submittedOn; sh:lessThan ex:reproducedOn ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedOn "2016-07-08T10:23:45Z"^^xsd:dateTime ;
         ex:reproducedOn "2016-07-08T13:53:00Z"^^xsd:dateTime .
<span class="fail">&lt;issue2&gt; ex:submittedOn "2016-07-08T10:23:45Z"^^xsd:dateTime ;</span>
         ex:reproducedOn "2016-07-08T09:53:00Z"^^xsd:dateTime .
<span class="fail">&lt;issue3&gt; ex:submittedOn "2016-07-08T10:23:45Z"^^xsd:dateTime ;</span>
         ex:reproducedOn "2016-07-12"^^xsd:date .</pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>ex:submittedOn</code> not less than <code>ex:reproducedOn</code>.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:reproducedOn</code> not comparable with <code>ex:submittedOn</code>.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-Equals">Equals        := <code class="param">sibling</code>:RDFLiteral</span>
          </div>
          <p>
            Testing an Equals parameter against a value node returns an error if there is no node v in <code>(focus node, <code class="param">sibling</code>, v)</code> in the data graph or the evaluation of (value node = v) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A Equal's <code class="param">sibling</code> parameter is connected to a constraint by the <code>sh:equals</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-LessThanOrEquals">LessThanEquals := <code class="param">sibling</code>:RDFLiteral</span>
          </div>
          <p>
            Testing a LessThanOrEquals parameter against a value node returns an error if there is no node v in <code>(focus node, <code class="param">sibling</code>, v)</code> in the data graph or the evaluation of (value node &lt;= v) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A LessThanOrEqual's <code class="param">sibling</code> parameter is connected to a constraint by the <code>sh:lessThanOrEquals</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Disjoint">Disjoint      := <code class="param">sibling</code>:RDFLiteral</span>
          </div>
          <p>
            Testing an Disjoint parameter against a value node returns an error if any node v in <code>(focus node, <code class="param">sibling</code>, v)</code> in the data graph or the evaluation of (value node &lt; v) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A Disjoint's <code class="param">sibling</code> parameter is connected to a constraint by the <code>sh:disjoint</code> predicate.
          </p>

        </section>

        <section>
          <h4 id="Logicaloperators">Logical operators: NC, PC <!-- , IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-And">And           := <code class="param">shapes</code>:Set[Shape]</span>
          </div>
          <p>
            Testing an And parameter against a value node returns the errors from testing each member of the set <code class="param">shapes</code> against the value node.
          </p>
          <p class="rdf">
            An And parameter is an RDF Collection of <code class="param">shapes</code> connected to a constraint by the <code>sh:and</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 8</span></div>
            <pre class="schema">
&lt;Person&gt; sh:property [ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .
&lt;Customer&gt; sh:property [ sh:predicate corp:custId; sh:datatype xsd:integer ] .
&lt;User&gt; sh:constraint [ sh:and (&lt;Person&gt; &lt;Customer&gt;) ] .</pre>
            <pre class="data">
&lt;user1&gt; foaf:name "Alice"; corp:custId 1234 .
<span class="fail">&lt;user2&gt; foaf:givenName "Alice"; corp:custId 1234.0 .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;User&gt;</td><td>&lt;user1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;User&gt;</td><td>&lt;user2&gt;</td><td>fail</td><td class="fail">no foaf:name supplied.<br/>"12345.0" is an xsd:double.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-Or">Or            := <code class="param">shapes</code>:Set[Shape]</span>
          </div>
          <p>
            Testing an Or parameter against a value node returns an unspecified error if testing each member of the set <code class="param">shapes</code> against the value node returned an error.
          </p>
          <p class="rdf">
            An Or parameter is an RDF Collection of <code class="param">shapes</code> connected to a constraint by the <code>sh:or</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Not">Not           := <code class="param">shape</code>:Shape</span>
          </div>
          <p>
            Testing a Not parameter against a value node returns an unspecified error if testing <code class="param">shape</code> against the value node returned no error.
          </p>
          <p class="rdf">
            A Not parameter is a single <code class="param">shape</code> connected to a constraint by the <code>sh:not</code> predicate.
          </p>

        </section>
        <section>
          <h4 id="Nestedshapeconstraints">Nested shape constraints: PC <!-- , IPC --></h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-Shape">Shape         := nested:Shape @@  listed as NC, PC <!-- , IPC --> as of 2016-06-30</span>
          </div>
          <p>
            Testing a Shape parameter against a value node returns any errors returned when validating the value node as nested (c.f. definition of Shape above).
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-QualifiedValueShape">QualifiedValueShape := nested:Shape</span>
          </div>
          <p>
            As noted above, QualifiedValueShape takes a set of value nodes that have passed all non-cardinality tests. It's evaluation is the same as the evaluation of Shape.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Class">Class         := t:IRI @@ + subClassOf*</span>
          </div>
          <p>
            Testing a Class parameter against a value node returns any errors returned when validating the value node as a Shape with a single PathConstraint <!-- PropertyConstraint --> with a predicate(rdf:type) and HasValue(t).
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-ClassIn">ClassIn       := t:IRI @@ + subClassOf*</span>
          </div>
          <p>
            Testing a ClassIn parameter against a value node returns any errors returned when validating the value node as a Shape with a single PathConstraint <!-- PropertyConstraint --> with a predicate(rdf:type) and In(t).
          </p>
        </section>
      </section>
      <section>
        <h3 id="N-aryParameters">N-ary Parameters</h3>
        <p>
          N-ary Parameters evaluate the set of value nodes which were selected by the <a href="#dfn-Constraint">Constraints</a>.
        </p>
        <section>
          <h4 id="Cardinality">Cardinality: PC <!-- , IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-MinCount">MinCount      := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            Testing a MinCount parameter against a set of value nodes returns an error if the number of value nodes is less than <code class="param">ref</code>.
          </p>
          
          <div class="abstrsynt">
            <span class="math" id="dfn-QualifiedMinCount">QualifiedMinCount := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            As noted above, QualifiedMinCount takes a set of value nodes that have passed all non-cardinality tests.
            It's evaluation is the same as the evaluation of MinCount.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxCount">MaxCount      := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            Testing a MaxCount parameter against a set of value nodes returns an error if the number of value nodes is greater than <code class="param">ref</code>.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-QualifiedMaxCount">QualifiedMaxCount := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            As noted above, QualifiedMaxCount takes a set of value nodes that
            have passed all non-cardinality tests. It's evaluation is the same
            as the evaluation of MaxCount.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-UniqueLang">UniqueLang    := <code class="param">b</code>:boolean</span>
          </div>
          <p>
            Testing a UniqueLang parameter against a set of value nodes returns an error if <code class="param">b</code> is <code>true</code> and two or more of the value nodes are RDFLiterals with the same language tag.
          </p>

        </section>
      </section>
    </section>

    <section>
      <h2 id="Targets">Targets</h2>
      <p>
        A SHACL target designates which nodes in the data graph will be @@compared to the defined constraints.
        A Target is defined either by matching a node label (TargetNode) in the data graph, a type statement using rdf:type (TargetClass) or a subject IRI (TargetSubjectsOf) or an object IRI (TargetObjectsOf.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-Target">Target         := <a href="#dfn-TargetNode">TargetNode</a>|<a href="#dfn-TargetClass">TargetClass</a>|<a href="#dfn-TargetSubjectsOf">TargetSubjectsOf</a>|<a href="#dfn-TargetObjectsOf">TargetObjectsOf</a></span>
      </div>

      <p>
        The simplest form of Target directly identifies nodes the data graph:
      </p>
      <div class="abstrsynt">
        <span class="math" id="dfn-TargetNOde">TargetNode     := <code class="param">node</code>:IRI|literal|BNode # latter demands told bnodes.@@?</span>
      </div>
      <p>
        A TargetNode matches <code class="param">node</code> if <code class="param">node</code> appears as a node (any subject or object in a triple) in the data graph.
      </p>
      <p class="rdf">
        A TargetNode is connected to a shape by the <code>sh:targetNode</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 1</span></div>
        <p>
          In a graph with multiple nodes:
        </p>
        <pre class="data">
&lt;http://a.example/Alice&gt; foaf:name "Alice" ; foaf:knows &lt;http://a.example/Bob&gt; .
&lt;http://a.example/Bob&gt; foaf:name "Bob" .
&lt;http://a.example/Sue&gt; foaf:name "Sue" .</pre>
        <p>
          <code>sh:targetNode</code> could select a subset of them to be tested against the &lt;Person&gt; and &lt;Name&gt; shapes:
        </p>
        <pre class="schema">
&lt;PersonShape&gt; sh:targetNode &lt;http://a.example/Bob&gt;, &lt;http://a.example/Sue&gt; .
&lt;NameShape&gt; sh:targetNode "Alice", "Bob" .</pre>
      </div>

      <div class="abstrsynt">
        <span class="math" id="dfn-TargetClass">TargetClass    := <code class="param">type</code>:IRI</span>
      </div>
      <p>
        A TargetClass matches any node in the data graph with the triple
        <code>(node, rdf:type, <code class="param">type</code>)</code>
        or any node which is of a type which is a transitive <code>rdfs:subClassOf</code> <code class="param">type</code>.
      </p>
      <p class="rdf">
        A TargetClass is connected to a shape by the <code>sh:targetClass</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 2</span></div>
        <p>
          In a graph with nodes of types <code>ex:student</code>, <code>ex:teacher</code> and <code>ex:class</code>:
        </p>
        <pre class="data">
&lt;http://a.example/Alice&gt; a ex:student .
&lt;http://a.example/Bob&gt; a ex:professor . ex:professor rdfs:subClassOf ex:teacher .
&lt;http://a.example/Art&gt; a ex:class .</pre>
        <p>
          <code>sh:targetClass</code> selects the  a subset of them to be tested against the &lt;IssueShape&gt; shape:
        </p>
        <pre class="schema">
&lt;IssueShape&gt; sh:targetNode &lt;http://a.example/Bob&gt; , &lt;http://a.example/Sue&gt; .</pre>
      </div>

      <div class="abstrsynt">
        <span class="math" id="dfn-TargetSubjectOf">TargetSubjectOf := <code class="param">predicate</code>:IRI</span>
      </div>
      <p>
        A TargetSubjectsOf matches any subject node in the data graph with a triple
        <code>(node, <code class="param">predicate</code>, _)</code> where "_" is any node. 
      </p>

      <p class="rdf">
        A TargetSubjectsOf is connected to a shape by the <code>sh:targetSubjectsOf</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 3</span></div>
        <p>
          In a graph with some triples with <code>ex:issueStatus</code> predicates:
        </p>
        <pre class="data">
&lt;http://a.example/Issue1&gt; ex:submittedOn "2015-07-08" ; ex:issueStatus "fixed" .
&lt;http://a.example/Issue1&gt; ex:submittedOn "2015-07-09" .
&lt;http://a.example/Issue1&gt; ex:submittedOn "2015-07-10" ; ex:issueStatus "unresolvable" .</pre>
        <p>
          <code>sh:targetSubjectOf</code> selects the nodes that appear as subjects in triples with <code class="param">predicate</code> as a predicate:
        </p>
        <pre class="schema">
&lt;IssueShape&gt; sh:targetSubjectsOf ex:issueStatus .</pre>
      </div>
      
  <div class="abstrsynt">
        <span class="math" id="dfn-TargetObjectsOf">TargetObjectsOf := <code class="param">predicate</code>:IRI</span>
      </div>
      <p>
        A TargetObjectsOf matches any object node in the data graph with a triple
        <code>(_, <code class="param">predicate</code>, node)</code> where "_" is any node. 
      </p>

      <p class="rdf">
        A TargetObjectsOf is connected to a shape by the <code>sh:targetObjectsOf</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 4</span></div>
        <p>
          In a graph with some triples with <code>ex:issueStatus</code> predicates:
        </p>
        <pre class="data">
&lt;http://a.example/Issue1&gt; ex:submittedOn "2015-07-08" ; ex:issueStatus "fixed" .
&lt;http://a.example/Issue1&gt; ex:submittedOn "2015-07-09" .
&lt;http://a.example/Issue1&gt; ex:submittedOn "2015-07-10" ; ex:issueStatus "unresolvable" .</pre>
        <p>
          <code>sh:targetObjectsOf</code> selects the nodes that appear as subjects in triples with <code class="param">predicate</code> as a predicate:
        </p>
        <pre class="schema">
&lt;IssueShape&gt; sh:targetSubjectOf ex:issueStatus .</pre>
      </div>
    
    </section>

    <script>
      $("m").wrapInner("<span class='math'/>").children(0).unwrap();
    </script>
    <script>
      var toggledElts = {
        "r": $(".rdf"),
        "e": $(".example")
      };
      function toggle (l) {
        var visibleTop = $(window).scrollTop();
        var v = l.is(":visible");
        if (!v)
          l.toggle();
        var adj = 0;
        for (var i = 0; i < l.length; ++i) {
          var elt = l.slice(i, i+1);
          if (elt.offset().top >= visibleTop) // stop when we pass the current scroll top.
            break;
          //adj += elt.outerHeight(true);
          adj += elt.outerHeight(false) + (elt.outerHeight(true) - elt.outerHeight(false))/2;
        }
        $(window).scrollTop(visibleTop + (v ? 0 - adj : adj)); // move the scroll top.
        if (v)
          l.toggle();
      }
      var rdfElts = $(".rdf");
      $("#toggleRDF").on("click", e => { toggledElts["r"].toggle(toggledElts["r"]); });
      $("#toggleExamples").on("click", e => { toggledElts["e"].toggle(toggledElts["e"]); });
      $("html > body").keypress(function (evt) {
        if (evt.ctrlKey)
          return true; // don't interfere with browser control keys.
        var k = String.fromCharCode(evt.which).toLowerCase();
    	  if (k in toggledElts)
    	    return toggle(toggledElts[k]);
        if (k === "a")
          toggleASonly(k);
    	  return true;
      });debugger;
      var toggleSquished = $("#toggleSquished").on("click", toggleASonly);
      function toggleASonly (k) {
        var applyTo = toggleSquished.parent().nextAll();
        var toSquish = applyTo.find(".abstrsynt,h2,h3,h4");
        var toToggle = applyTo.find("p,ul,ol,pre,div.issue,div.example");
        toggle(toToggle);
        if (toSquish.hasClass("squished")) {
          // toToggle.show();
          toSquish.removeClass("squished");
        } else {
          // toToggle.hide();
          toSquish.addClass("squished");
        }
      }
    </script>
  </body>
</html>
