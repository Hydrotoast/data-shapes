<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <title>Core SHACL Semantics</title>
    <meta charset='utf-8'></meta>
    <script src='//www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <link rel="stylesheet" type="text/css" href="local.css" />
    <script class='remove'>
      var respecConfig = {
          specStatus: "ED",
          edDraftURI:  "http://w3c.github.io/data-shapes/semantics/#dfn-shacl-shape",
          shortName:  "shacl-semantics",
          editors: [
                {   name:       "Iovka Boneva",
                    url:        "http://cristal.univ-lille.fr/~boneva/",
                    company:    "University of Lille / Inria",
                    companyURL: "http://www.inria.fr/" },
                    {   name:       "Eric Prud'hommeaux",
                    url:        "http://www.w3.org/People/Eric/",
                    company:    "W3C/MIT",
                    companyURL: "http://www.w3.org/" }
          ],
          wg:           "RDF Data Shapes Working Group",
          wgURI:        "https://www.w3.org/2014/data-shapes",
          wgPublicList: "public-rdf-shapes",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
		  localBiblio:  {
			"xyz": {
				title:    "Sample Custom Reference",
				href:     "http://example.org/",
				"authors": [
					"S. Steyskal"
				],
				publisher: "xyz"
		    }
		  }
      };
    </script>
		<style>
			.todo {
				color: red;
			}
		    pre {
				tab-size: 4;
		    }
			th {
				text-align: left;
			}
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .example {
        display: inline-block;
      }
      .example.wrapper {
        background-color: #fff;
      }
      .example.wrapper pre {
        background-color: #fcfaee;
        margin-left: 0;
        line-height: 1.2;
      }
      .example.wrapper .fail {
        background-color: #fceefa
      }
      .verticalDivider {
        float: left;
        width: .5em;
        border:thin solid #fff; /* disappears without this */
      }

.highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
.highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
.lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
.lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
.highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
.highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
.lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
.lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */

.highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
.lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
.highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
.lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }

.new            { font-weight: bold; }
.errorSite      { color: red; }

h3 sup,h4 sup,.eval {
  font-weight: lighter;
  color: #307;
}
.emph{
    font-style: italic;
}

.testrm{
    font-style: normal;
}

.textbf{
    font-weight: bold;
}

.math{
    font-style: normal;
    font-family: sans-serif;
}

.block-name{
    font-weight: bold;
}

.abstrsynt{
margin-left: 0;
margin-right: 2ex;
margin-top: 0.1ex;
margin-bottom: 0.1ex;
/* border: double 1px #888888; */
border: thin solid #888888;
padding: 1ex 2ex 0.5ex 2ex;
page-break-inside: avoid;
background-color: #F0F8F8;
}

.Definition{
margin-left: 0;
margin-right: 2ex;
margin-top: 0.1ex;
margin-bottom: 0.1ex;
/* border: double 1px #888888; */
border: thin solid #888888;
padding: 1ex 2ex 0.5ex 2ex;
page-break-inside: avoid;
background-color: #F0F0F0;
}


.quote{
    margin-left: 3em;
}

.smaller{
    font-size: .83em;
}
		</style>
  </head>
  <body>
    <section id='abstract'>
      This document defines the core SHACL (SHApes Constraint Language), a language for constraining RDF instance graphs.
    </section>

    <section id='sotd'>

      <p>
        Proposal to RDF Data Shapes WG
      </p>
    </section>

    <!-- taken from http://www.w3.org/2014/data-shapes/charter -->
    <section id="intro" class='informative'>
      <h2>Introduction</h2>
			<p>
				SHACL provides structural constraints for <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
				SHACL constraints are grouped into "shapes", which may also be referenced by constraints in other shapes.
				These constraints describe the <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a> connecting certain nodes in the graph.
				SHACL can constrain the number of triples with a particular predicate and the permitted object datatype or object terms, require that the subject or object match some shape or lexical and datatype conditions.
			</p>

    </section>
<!--
    <section id="notation">
      <h2>Notation</h2>
      <p>
        The following HTML tags and CSS classes are used to highlight the roles of text in this document:
      </p>
      <ul>
        <li>&lt;dfn&gt;<dfn id="dfn-shacl-defined-term">defined term</dfn>&lt;dfn&gt;</li>
        <li>&lt;a class="internalDFN"&gt;<a title="SHACL defined term" href="#dfn-shacl-defined-term" class="internalDFN">defined term</a>&lt;/a&gt;</li>
        <li><sup class="eval">eval</sup> &mdash; link to evaluation semantics</li>
      </ul>
    </section>
-->

    <section>
      <h2>Abstract Syntax</h2>
      <div>
        <h2>2.1 RDF abstract syntax</h2>
        <p>
          This document uses the following labels for terms in the RDF abstract syntax:
        </p>

        <ul>
          <li><code>Iri</code> - <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri">RDF IRI</a></li>
          <li><code>Blank</code> - <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node">RDF blank node</a></li>
          <li><code>Lit</code> - <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">RDF literal</a></li>
        </ul>
      </div>
<h2 id="Simple_shape_expression_schemas">Simple shape expression
schemas</h2>
The abstract syntax of shape expression schemas is given below. For
now we use a simplified definition of one non-terminal, namely
<span class="math">ShConstr</span>, which is indicated by the
temporary rule <span class="math">ShConstrTemp</span>. We make this
simplification in order to make defining the semantics easier, and
we give the complete definition in Section <a href=
"#sec__complex_shape_constraints">sec: complex shape
constraints</a>.
<div class="abstrsynt"><span class="math">Schema ::=
Rule+</span><br />
<span class="math">Rule ::= ShapeLabel ShapeDefinition
ExtensionCondition*</span><br />
<span class="math">ShapeLabel ::=</span> an identifier<br /></div>
A Schema is composed of at least one rule (<span class=
"math">Rule</span>). Every rule associates with a label
(<span class="math">ShapeLabel</span>), a shape definition
(<span class="math">ShapeDefinition</span>), and possibly a number
of additional conditions (<span class=
"math">ExtensionCondition</span>) defined using an extension
mechanism.
<div class="abstrsynt"><span class="math">ShapeDefinition ::=
ClosedShape | OpenShape</span><br />
<span class="math">ClosedShape ::= 'close' ShapeExpr</span><br />
<span class="math">OpenShape ::= 'open' InclPropSet?
ShapeExpr</span><br />
<span class="math">InclPropSet ::= PropertiesSet</span><br />
<span class="math">PropertiesSet ::= set of IRI</span><br /></div>
A shape definition is either a closed shape (<span class=
"math">ClosedShape</span>), or an open shape (<span class=
"math">OpenShape</span>). Both closed and open shapes are defined
by a shape expression (<span class="math">ShapeExpr</span>). Open
shapes can have associated set of included properties (<span class=
"math">InclPropSet</span>): properties of which arbitrary extra
occurances are permitted. Closed and open shapes will be
distinguished thanks the keywords <span class="math">close</span>
and <span class="math">open</span>, respectively.
<div class="abstrsynt"><span class="math">ShapeExpr ::=
EmptyShape</span><br />
<span class="math">| (TripleConstraint | InverseTripleConstraint)
Cardinality</span><br />
<span class="math">| DisjunctiveShape</span><br />
<span class="math">| GroupShape</span><br />
<span class="math">EmptyShape ::= 'emptyshape'</span><br /></div>
A shape expression is either the empty shape (<span class=
"math">EmptyShape</span>) represented by the keyword <span class=
"math">emptyshape</span>, or a triple constraint (<span class=
"math">TripleConstraint</span>) or an inverse <span class=
"math">triple</span> constraint (<span class=
"math">InverseTripleConstraint</span>) followed by a cardinality
constraint (<span class="math">Cardinality</span>), or a
disjunctive shape (<span class="math">DisjunctiveShape</span>), or
a grouping shape (<span class="math">GroupShape</span>.
<div class="abstrsynt"><span class="math">TripleConstraint ::= IRI
ValConstr | IRI ShConstr</span><br />
<span class="math">InverseTripleConstraint ::= 'inverse'
TripleConstraint</span><br />
<span class="math">Cardinality ::= '[' MinCardinality ';'
MaxCardinality ']'</span><br />
<span class="math">MinCardinality ::=</span> a natural number<br />
<span class="math">MaxCardinality ::=</span> a natural number
<span class="math">| 'unbound'</span><br /></div>
Triple constraints are used to specify constraints to be satisfied
by the triples having the focus node as subject, and the associated
cardinality specifies how many triples satisfying the triple
constraint are required. Inverse triple constraints play a similar
role, but define constraints to be satisfied by the triples having
the focus node as object. We will write <span class=
"math">a::C</span> for the triple constraint with IRI <span class=
"math">a</span>, and with value or shape constraint <span class=
"math">C</span>. Cardinalities will be written as an interval in
square brackets, and which maximum bound can be the special value
<span class="math">unbound</span>. In the examples, we omit writing
the cardinality when the minimal and the maximal cardinality are
both equal to one. That is, we write simply <span class=
"math">a::C</span> for <span class="math">a::C[1;1]</span>.
<div class="abstrsynt"><span class="math">ValConstr ::= ValueSet |
LiteralDatatype XSFacet? | NodeKind</span><br />
<span class="math">ShConstrTemp ::= ShapeLabel</span><br />
<span class="math">ValueSet ::=</span> set of literals and
<span class="math">IRI</span><br />
<span class="math">LiteralDatatype ::=</span> an RDF literal
datatype<br />
<span class="math">NodeKind ::= 'iri' | 'blank' | 'literal' |
'nonliteral'</span><br />
<span class="math">XSFacet ::=</span> an XSD restriction</div>
Triple constraint can constraint the object of a triple in two
different ways. Either they require the object to a have some
particular value (value constraint), or they require the object
node to satisfy a shape constraint. A value constraint can be
specified in three different ways: as a set of concrete values,
that can be IRI or literals; or as a literal data possibly XSD
facet restriction attached to it; or as a kind of the node, among
IRI, Blank, literal or non literal.
<div class="abstrsynt"><span class="math">DisjunctiveShape ::=
ShapeExpr ('|' ShapeExpr)*</span><br />
<span class="math">GroupShape ::= ShapeExpr (','
ShapeExpr)*</span><br /></div>
Complex shape expressions can be built thanks to two operators:
disjunction, and grouping. A disjunctive shape (<span class=
"math">DisjunctiveShape</span>) requires that one of the disjunct
shape expressions is satisfied. A group shape (<span class=
"math">GroupShape</span>) requires for the neighbourhood of the
focus node to be split in as many sets of triples as there are
sub-expressions, and every such set of triples must satisfy
constraint given by the corresponding sub-expression.
<div class="abstrsynt"><span class="math">ExtensionCondition ::=
ExtLangName ExtDefinition</span><br />
<span class="math">ExtLangName ::=</span> an identifier<br />
<span class="math">ExtDefinition ::=</span> a string<br /></div>
Finally, an extension mechanism allows to attach additional
constraints to be satisfied by the nodes of given shape. Each such
condition can be written in some extension language (<span class=
"math">ExtLangName</span>), and the actual constraint is a Boolean
function definition in the corresponding language.
    </section>
<!--
    <section>
      <h2>Abstract Syntax</h2>
			<p>
				A <dfn id="dfn-shacl-shape">shape</dfn> <sup><a title="shape matches" href="#dfn-shacl-shape-matches">eval</a></sup> describes the triples whose subject or object is some <dfn id="dfn-shacl-focus-node">focus node</dfn> in an RDF graph.
				A shape has zero or one <dfn id="dfn-shacl-triple-constraint">triple constraints</dfn> attached to it which describe the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>'s triples.
        A triple constraint is one of the following:
      </p>
      <ul>
        <li><a title="triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> defines the characteristics of matching triples associated with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>.</li>
        <li><a title="inverse triple constraint" href="#dfn-shacl-inverse-property-constraint" class="internalDFN">inverse triple constraint</a> defines the characteristics of matching triples associated with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>.</li>
        <li><a title="group shape" href="#dfn-shacl-and-constraint" class="internalDFN">group shape</a> defines matching of a set of <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraints</a>.</li>
        <li><a title="disjunctive shape" href="#dfn-shacl-or-constraint" class="internalDFN">disjunctive shape</a> defines matching of a set of <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraints</a>.</li>
      </ul>
      <p>
			</p>
      <section>
        <h3>Triple Constraint <sup><a title="SHACL triple constraint matches" href="#dfn-shacl-property-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
				  A <dfn id="dfn-shacl-property-constraint">triple constraint</dfn> has a <dfn id="dfn-shacl-predicate">predicate</dfn> which identifies the triple's predicate and may have a <dfn id="dfn-shacl-min-card">minimum cardinality</dfn> and/or <dfn id="dfn-shacl-max-card">maximum cardinality</dfn>, to indicate how many triples with that predicate are expected.
				  The triple constraint also has zero or one <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">term constraints</a> which apply to the <em>object</em> of <a title="SHACL conjunct" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a>.
			  </p>
        <section id="dfn-shacl-term-constraint">
          <h4>Term Constraints</h4>
          <p>
            Where a triple constraint describes matching <a title="RDF Triples" href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple" class="externalDFN">RDF Triples</a> [[!RDF11-CONCEPTS]], a term constraint describes matching <a title="RDF Term" href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term" class="externalDFN">RDF Terms</a> [RDF Concepts].
          </p>
			  <ul>
				  <li><dfn id="dfn-shacl-node-type">node type</dfn> <sup><a title="SHACL node type matches" href="#dfn-node-type-matches" class="internalDFN">eval</a></sup>: identifies the RDF Node type (<a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a>, <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a>, or <a title="RDF Blank Node" href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node" class="externalDFN">Blank Node</a>).</li>
				  <li><dfn id="dfn-shacl-datatype">datatype</dfn> <sup><a title="SHACL datatype matches" href="#dfn-datatype-matches" class="internalDFN">eval</a></sup>: identifies the <a title="datatype IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri" class="externalDFN">datatype IRI</a> of an <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a>.</li>
				  <li><dfn id="dfn-shacl-value-set">value set</dfn> <sup><a title="SHACL value set matches" href="#dfn-shacl-value-set-matches" class="internalDFN">eval</a></sup>: a set of permissible <a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a>, <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a> values called <dfn id="dfn-shacl-allowed-value">allowed values</dfn>.</li>
				  <li><dfn id="dfn-shacl-value-shape">value shape</dfn> <sup><a title="SHACL valu shape matches" href="#dfn-shacl-value-shape-matches" class="internalDFN">eval</a></sup>: identifies a <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a> and asserts that the term is described by that shape.</li>
			  </ul>
        </section>
      </section>

      <section>
        <h3>Inverse Triple Constraint <sup><a title="SHACL inverse triple constraint matches" href="#dfn-shacl-inverse-property-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
          The <dfn id="dfn-shacl-inverse-property-constraint">inverse triple constraint</dfn> is comprised of the same components as the triple constraint except it may NOT have:
			  </p>
        <ul>
          <li>a <a title="SHACL conjunct" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> constraint</li>
          <li>a <a title="value set" href="#dfn-shacl-value-set" class="internalDFN">value set</a> with any <a title="SHACL conjunct" href="#dfn-shacl-allowed-value" class="internalDFN">allowed value</a> which is an RDF Literal</li>
        </ul>
        <p>
				  <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">Term constraints</a> apply to the <em>subject</em> of <a title="SHACL conjunct" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a>.
        </p>
      </section>

      <section>
        <h3>Group Shape <sup><a title="SHACL group shape matches" href="#dfn-shacl-and-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
          The <dfn id="dfn-shacl-and-constraint">group shape</dfn> is a set of properties called <dfn id="dfn-shacl-conjunct">conjuncts</dfn>.
			  </p>
      </section>

      <section>
        <h3>Disjunctive Shape <sup><a title="SHACL disjunctive shape matches" href="#dfn-shacl-or-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
          The <dfn id="dfn-shacl-or-constraint">disjunctive shape</dfn> is a set of properties called <dfn id="dfn-shacl-conjunct">disjuncts</dfn>.
			  </p>
      </section>
    </section>
-->
    <section>
      <h2>RDF Vocabulary</h2>
			<p>
        The SHACL abstract syntax above can be represented in an RDF graph.
        RDF graphs are subject to the constraints in the abstract syntax above, e.g. that a triple constraint may have at most one term constraint.
      </p>

      <p>
        SHACL <code>triple constraints</code> can be parsed with a SPARQL query:
      </p>

      <div style="border-left: medium solid #ddd;">
        <pre>
<span class="keyword">PREFIX</span> <span class="type">sh:</span><span class="function-name">&lt;<a href="http://www.w3.org/ns/shacl#">http://www.w3.org/ns/shacl#</a>&gt;</span><span class="comment">
</span><span class="keyword">PREFIX</span> <span class="type">xsd:</span><span class="function-name">&lt;<a href="http://www.w3.org/2001/XMLSchema#">http://www.w3.org/2001/XMLSchema#</a>&gt;</span><span class="comment">
</span><span class="keyword">PREFIX</span> <span class="type">rdf:</span> <span class="function-name">&lt;<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</a>&gt;</span><span class="comment">
</span>
<span class="keyword">SELECT</span> <span class="variable-name">?entry</span> <span class="variable-name">?isShape</span> <span class="variable-name">?choice</span> <span class="variable-name">?group</span> 
(IF(Bound(<span class="variable-name">?property</span>),                      <span class="comment"># compile TripleConstraint
</span>    CONCAT(<span class="string">"ShapeExpr(TripleConstraint("</span>,
      <span class="string">"IRI("</span>, STR(<span class="variable-name">?predicate</span>), <span class="string">"), "</span>,
      IF(Bound(<span class="variable-name">?valueType</span>),      CONCAT(<span class="string">"ValueType(IRI("</span>,STR(<span class="variable-name">?valueType</span>),<span class="string">"))"</span>),   <span class="comment"># valueType
</span>        IF(Bound(<span class="variable-name">?nodeKind</span>),     CONCAT(<span class="string">"NodeKind(IRI("</span>,STR(<span class="variable-name">?nodeKind</span>),<span class="string">"))"</span>),     <span class="comment"># nodeKind
</span>          IF(Bound(<span class="variable-name">?shapeLabel</span>), CONCAT(<span class="string">"ShapeLabel(IRI("</span>,STR(<span class="variable-name">?shapeLabel</span>),<span class="string">"))"</span>), <span class="comment"># valueShape
</span>                                 CONCAT(<span class="string">"ValueSet("</span>,<span class="keyword">GROUP</span>_CONCAT(CONCAT(          <span class="comment"># allowedValue
</span>                                     IF(IsLiteral(<span class="variable-name">?allowedValue</span>), <span class="string">"Literal"</span>, <span class="string">"IRI"</span>), <span class="comment"># IRIs and Literals
</span>                                           <span class="string">"("</span>, STR(<span class="variable-name">?allowedValue</span>), <span class="string">")"</span>)
                                   ),<span class="string">")"</span>)
      ))),
     <span class="string">"))["</span>,if(Bound(<span class="variable-name">?min1</span>), STR(<span class="variable-name">?min1</span>), <span class="string">"1"</span>),<span class="string">","</span>,if(Bound(<span class="variable-name">?max1</span>), STR(<span class="variable-name">?max1</span>), <span class="string">"INF"</span>),<span class="string">"]"</span>), <span class="comment"># cardinality
</span>    <span class="string">""</span>) <span class="keyword">AS</span> <span class="variable-name">?TripleConstraint</span>)
where { 
  {
    <span class="variable-name">?entry</span> <span class="type">sh:</span><span class="constant">property</span> <span class="variable-name">?property</span> .
    <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">predicate</span> <span class="variable-name">?predicate</span> ;
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">minCount</span> <span class="variable-name">?min1</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">maxCount</span> <span class="variable-name">?max1</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">valueType</span> <span class="variable-name">?valueType</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">nodeKind</span> <span class="variable-name">?nodeKind</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">valueShape</span> <span class="variable-name">?shapeLabel</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">allowedValue</span> <span class="variable-name">?allowedValue</span>
               <span class="keyword">FILTER</span> (IsIRI(<span class="variable-name">?allowedValue</span>) || IsLiteral(<span class="variable-name">?allowedValue</span>)) }
  } <span class="keyword">UNION</span> {
    <span class="variable-name">?entry</span> <span class="type">sh:</span><span class="constant">choice</span> <span class="variable-name">?choice</span>
  } <span class="keyword">UNION</span> {
    <span class="variable-name">?entry</span> <span class="type">sh:</span><span class="constant">propertyGroup</span> <span class="variable-name">?group</span>
  }
  <span class="keyword">OPTIONAL</span> { <span class="variable-name">?entry</span> <span class="keyword">a</span> <span class="type">sh:</span><span class="constant">Shape</span>
    <span class="keyword">BIND</span>(true <span class="keyword">AS</span> <span class="variable-name">?isShape</span>)
  }
} <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="variable-name">?entry</span> <span class="variable-name">?isShape</span> <span class="variable-name">?property</span> <span class="variable-name">?predicate</span> <span class="variable-name">?choice</span> <span class="variable-name">?group</span>
           <span class="variable-name">?min1</span> <span class="variable-name">?max1</span> <span class="variable-name">?valueType</span> <span class="variable-name">?nodeKind</span> <span class="variable-name">?shapeLabel</span>
        </pre>
      </div>

      <p>
        This produces a hierarchy table with five columns: <code>entry</code>, <code>isShape</code>, <code>choice</code>, <code>group</code>, <code>TripleConstraint</code>. The abstract syntax is built in two steps:
      </p>

      <ol>
        <li>compose a map of <code>entry</code> to list of tuples of <code>isShape</code>, <code>choice</code>, <code>group</code>, <code>TripleConstraint</code></li>
        <li>
          starting with entries where <code>isShape</code> is true, compose a <code>Rule(entry, GroupShape())</code>.<br/>
          The <code>embed(entry, collection)</code> function takes an entry and a GroupShape or DisjuntiveShape:<br/>
          for each mapping e with a key of entry:
          <ul>
            <li>If choice is bound, add a new DisjunctiveShape to <code>collection</code> and invoke <code>embed</code> with choice and the DisjuntiveShape.</li>
            <li>else if group is bound, add a new GroupShape to <code>collection</code> and invoke <code>embed</code> with group and the DisjuntiveShape.</li>
            <li>else TripleConstraint is added to <code>collection</code>.</li>
          </ul>
        </li>
      </ol>

      <p>
        RDF node types are identified by the following IRIs:
      </p>
      <div class="center">
        <table class="allname" style="text-align: left" border="2" cellpadding="5">
          <caption> <span class="caption">Table 2.</span> RDF Node Type Identifiers
          </caption>
          <tbody>
            <tr><th>RDF node type</th>                                                                                                                                <th>SHACL identifier</th></tr>
            <tr><td><a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a></td> <td class="name"><span class="type">sh:</span><span class="constant">IRI</span></td></tr>
            <tr><td><a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">Literal</a></td> <td class="name"><span class="type">sh:</span><span class="constant">Literal</span></td></tr>
            <tr><td><a title="RDF Blank Node" href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node" class="externalDFN">Blank Node</a></td> <td class="name"><span class="type">sh:</span><span class="constant">BNode</span></td></tr>
          </tbody>
        </table>
      </div>

      <section>
        <h3>RDF instance example</h3>
        <p>
          The following example represents a shape <code><span class="function-name">my:UserShape</span></code> composed of an <a title="SHACL group shape" href="#dfn-shacl-and-constraint" class="internalDFN">group shape</a> with two <a title="SHACL conjunct" href="#dfn-shacl-conjunct" class="internalDFN">conjuncts</a>:
        </p>
        <ol>
          <li>An <a title="SHACL disjunctive shape" href="#dfn-shacl-or-constraint" class="internalDFN">disjunctive shape</a> with two <a title="SHACL disjunct" href="#dfn-shacl-disjunct" class="internalDFN">disjuncts</a>:
          <ol>
            <li>A <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> with a <a title="SHACL predicate" href="#dfn-shacl-predicate" class="internalDFN">predicate</a> of <span class="type">foaf:</span><span class="constant">name</span>, a <a title="SHACL datatype" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> of <span class="type">xsd:</span><span class="constant">string</span>, a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> of 1, a <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a> of 1.</li>
            <li>A <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> with a <a title="SHACL predicate" href="#dfn-shacl-predicate" class="internalDFN">predicate</a> of <span class="type">foaf:</span><span class="constant">givenName</span>, a <a title="SHACL datatype" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> of <span class="type">xsd:</span><span class="constant">string</span>, a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> of 1, no <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a>.</li>
          </ol>
          </li>
          <li>A <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> with a <a title="SHACL predicate" href="#dfn-shacl-predicate" class="internalDFN">predicate</a> of <span class="type">foaf:</span><span class="constant">mbox</span>, a <a title="SHACL node type" href="#dfn-shacl-node type" class="internalDFN">node type</a> of RDF IRI, a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> of 1, no <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a>.</li>
        </ol>
    		  <pre class="schema turtle"><span class="comment"># shapes (Turtle)</span>
<span class="function-name">my:UserShape</span> <span class="keyword">a</span> <span class="type">sh:</span><span class="constant">Shape</span> ;
    <span class="type">sh:</span><span class="constant">choice</span> [
        <span class="type">sh:</span><span class="constant">property</span> [
            <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">name</span> ;
            <span class="type">sh:</span><span class="constant">valueType</span> <span class="type">xsd:</span><span class="constant">string</span> ;
            <span class="type">sh:</span><span class="constant">minCount</span> 1 ; <span class="type">sh:</span><span class="constant">maxCount</span> 1
        ] ;
    
        <span class="type">sh:</span><span class="constant">property</span> [
            <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">givenName</span> ;
            <span class="type">sh:</span><span class="constant">valueType</span> <span class="type">xsd:</span><span class="constant">string</span> ;
            <span class="type">sh:</span><span class="constant">minCount</span> 1
        ] ;
    ] ;                                          
    <span class="type">sh:</span><span class="constant">property</span> [
        <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">mbox</span> ;
        <span class="type">sh:</span><span class="constant">nodeType</span> <span class="type">sh:</span><span class="constant">IRI</span> ;
        <span class="type">sh:</span><span class="constant">minCount</span> 1
    ] <span class="keyword">.</span></pre>
  </section>

    </section>

    <section id="associations">
    	<h2>Associating Data with Shapes</h2>
      <p>
        SHACL defines two predicates, <span class="type">sh:</span><span class="constant">nodeShape</span> and <span class="type">sh:</span><span class="constant">classShape</span>.
        The former asserts that a particular node in some graph conforms to a specific shape.
        The latter asserts that every node of some type conforms to a specific shape.
        It is expected that different communities will develop many more associations, much as the WSDL community created an association between input and output documents and an XML schema which described them.
      </p>

      <div class="issue">
        <p>
          The <span class="type">sh:</span><span class="constant">classShape</span> predicate describes a way to associate shapes with classes.
          It is currently unclear what is implied by attaching shape properties (e.g. <span class="type">sh:</span><span class="constant">property</span>) directly to a class e.g.:
        </p>
        <pre>
<span class="type">clinic1234:</span><span class="constant">CompletePatientRecord</span> <span class="keyword">a</span> <span class="type">owl:</span><span class="constant">Class</span> ;
  <span class="type">sh:</span><span class="constant">property</span> [
    <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">clinic1234:</span><span class="constant">phone</span> ;
    <span class="type">sh:</span><span class="constant">valueType</span> <span class="type">xsd:</span><span class="constant">string</span> ;
    <span class="type">sh:</span><span class="constant">minCount</span> 1 ; <span class="type">sh:</span><span class="constant">maxCount</span> 1
  ] <span class="keyword">.</span></pre>

      </div>

      <div class="issue">
        <p>
          It's unclear whether an structure associating nodes returned from a SPARQL query would constitued a <a href="http://www.w3.org/2014/data-shapes/wiki/Requirements#Global_Constraints">global constraint</a>, e.g.
        </p>
        <pre>[ <span class="type">sd:</span><span class="constant">endpoint</span> <span class="function-name">&lt;http://www.example/sparql/&gt;</span> ;
  <span class="type">sd:</span><span class="constant">defaultDataset</span> [
    <span class="type">sd:</span><span class="constant">defaultGraph</span> [
      <span class="type">sd:</span><span class="constant">Graph</span> [
        <span class="type">sh:</span><span class="constant">query</span> """SELECT ?s { ... }""" ;
        <span class="type">sh:</span><span class="constant">hasShape</span> <span class="type">ex:</span><span class="constant">IssueShape</span>
      ] ] ] ] <span class="keyword">.</span></pre>
      </div>
    </section>

    <section id="evaluation">
      <h2>evaluation</h2>
<section>
<h2 id="Declarative_semantics_of_simple_shape_expression_schemas">
Declarative semantics of simple shape expression schemas</h2>
Recall that a triple constraint is either a shape constraint
(<span class="math">ShConstr</span>), or a value constraint
(<span class="math">ValConstr</span>). Remark also that every value
constraint, no matter its kind (value set, or literal data type, or
node type), defines a set of values; we call them the <span class=
"emph">allowed</span> values of the constraint. For instance, the
allowed values of the literal data type constraint <span class=
"math">int</span> are all the literal integer values; the allowed
values of the <span class="math">nonliteral</span> value constraint
are all IRI and all blank nodes.
<div class="Definition"><span class="block-name">Definition</span>
[Triple matches constraint] <a id="def__triple_matches_constraint"
name="def__triple_matches_constraint"></a> We say that a triple
<span class="math">(n, p, u)</span> <span class=
"emph">matches</span> a triple constraint <span class=
"math">a::C</span> iff
<ul>
<li><span class="math">a::C</span> is a value constraint, and
<span class="math">p = a</span>, and <span class="math">u</span>
belongs to the set of allowed values for <span class=
"math">C</span>, or</li>
<li><span class="math">a::C</span> is a shape constraint,
<span class="math">u</span> in an IRI, and <span class="math">p =
a</span>.</li>
</ul>
</div>
-
<div class="Definition"><span class="block-name">Definition</span>
[Set of triples satisfies a shape expression] <a id=
"def__set_of_triples_satisfies_a_shape_expression" name=
"def__set_of_triples_satisfies_a_shape_expression"></a> Let
<span class="math">Neigh</span> be a set of triples, and let
<span class="math">Expr</span> be a shape expression (as defined by
<span class="math">ShapeExpr</span>). We say that <span class=
"math">Neigh</span> <span class="emph">satisfies</span>
<span class="math">Expr</span> iff:
<ul>
<li><span class="math">Expr</span> is the empty shape <span class=
"math">emptyshape</span> and <span class="math">Neigh</span> is the
empty set, or</li>
<li><span class="math">Expr</span> is a triple constraint
<span class="math">a::C[m;M]</span> (where <span class=
"math">m</span> and <span class="math">M</span> are the minimal and
the maximal cardinality, respectively), every triple in
<span class="math">Neigh</span> matches <span class=
"math">a::C</span>, and the number of elements of <span class=
"math">Neigh</span> is in the bounds given by <span class=
"math">[m;M]</span>;</li>
<li><span class="math">Expr</span> is a disjunctive shape, let
<span class="math">Expr = Expr<sub>1</sub> | Expr<sub>2</sub> | ...
| Expr<sub>k</sub></span>, and <span class="math">Neigh</span>
satisfies <span class="math">Expr<sub>1</sub></span>, or
<span class="math">Neigh</span> satisfies <span class=
"math">Expr<sub>2</sub></span>, ... or <span class=
"math">Neigh</span> satisfies <span class=
"math">Expr<sub>k</sub></span>;</li>
<li><span class="math">Expr</span> is a grouping, let <span class=
"math">Expr = Expr<sub>1</sub>, ... , Expr<sub>k</sub></span>, and
<span class="math">Neigh</span> can be split into k disjoint sets
of triples <span class="math">Neigh = Neigh<sub>1</sub> &cup; ...
&cup; Neigh<sub>k</sub></span> s.t. <span class=
"math">Neigh<sub>i</sub></span> satisfies <span class=
"math">Expr<sub>i</sub></span> for all <span class="math">i</span>
in <span class="math">1..k</span>.</li>
</ul>
</div>
Note that for disjunctive shapes, satisfying one or the other of
the <span class="math">Expr<sub>i</sub></span> is not exclusive
(similarly to logical disjunction). The above definition can be
written using the following set of inference rules. We denote
<span class="math">Neigh |- Expr</span> the fact that <span class=
"math">Neigh</span> satisfies <span class="math">Expr</span>.
newpage <img src="inference-simple-schema.png" /> If a set of
triples <span class="math">Neigh</span> satisfies a shape
expression <span class="math">Expr</span>, then one can construct
(at least one) proof tree which root is <span class="math">Neigh |-
Expr</span>, using the above induction rules. Given such proof
tree, it can be shown that every triple <span class="math">(n, p,
u)</span> in <span class="math">Neigh</span> appears in the
conclusion of exactly one application of rule-empty. For every
triple <span class="math">(n, p, u)</span> in <span class=
"math">Neigh</span>, let <span class="math">wm((n, p, u))</span> be
the triple constraint <span class="math">p::C</span> that appears
in the conclusion of the same rule application as <span class=
"math">(n, p, u)</span>. We call <span class="math">wm</span> a
<span class="emph">witness mapping</span> (for the fact that
<span class="math">Neigh</span> satisfies <span class=
"math">Expr</span>). Note that every proof tree defines a unique
witness mapping. For an RDF graph <span class="math">G</span> and a
node <span class="math">n</span> in <span class="math">G</span>,
the <span class="emph">out-going neighbourhood</span> of
<span class="math">n</span> in <span class="math">G</span> is the
set of triples <span class="math">(n, p, u)</span> that belong to
the graph <span class="math">G</span>. This set is denoted
<span class="math">out(G,n)</span>. For a shape expression
<span class="math">Expr</span>, denote <span class=
"math">properties(Expr)</span> the set of properties that appear in
some triple constraint in <span class="math">Expr</span>. For a
schema <span class="math">S</span> and a shape label <span class=
"math">T</span> that appears in <span class="math">S</span>, denote
<span class="math">expr(T, S)</span> the shape expression that
defines the shape <span class="math">T</span> in the schema
<span class="math">S</span>, and denote <span class="math">incl(T,
S)</span> the set of included properties associated with the
definition of the shape <span class="math">T</span> in <span class=
"math">S</span>. Note that if <span class="math">T</span> is a
closed shape, then <span class="math">incl(T, S)</span> is empty.
On the implementation level, extension conditions are to be handled
by a plugin mechanism, in which the validation procedure delegates
checking of the extension condition to a registered plugin. The
result of evaluating the extension condition can be <span class=
"math">true</span>: the extension condition is satisfied, or
<span class="math">false</span>: the extension condition is not
satisfied, or <span class="math">error</span>: there was an error
during the execution, or <span class="math">undefined</span>: the
evaluation procedure didn't find the appropriate plugin. On the
semantics level, we suppose that for every extension language
<span class="math">lang</span>, there exists an oracle function
<span class="math">f<sub>lang</sub></span> that takes as parameters
an RDF graph, an IRI corresponding to a node of that graph, an a
string corresponding to the extension condition, and returns as
result one of <span class="math">true</span>, <span class=
"math">false</span>, <span class="math">error</span>, and
<span class="math">undefined</span>. For the unsupported extension
languages (the result is <span class="math">undefined</span>), the
default behaviour is to consider that the constraint is satisfied;
this however can be parametrized without consequence on the
semantics.
<div class="Definition"><span class="block-name">Definition</span>
[Typing, valid typing] <a id="def__typing__valid_typing" name=
"def__typing__valid_typing"></a> A <span class="emph">typing</span>
of a graph <span class="math">G</span> is a map that associates a
(possibly empty) set of shape labels with every node of
<span class="math">G</span>. For a shape expression schema
<span class="math">S</span> and a graph <span class=
"math">G</span>, a typing <span class="math">t</span> is called
<span class="emph">valid typing</span> of <span class=
"math">G</span> by <span class="math">S</span> if for every node
<span class="math">n</span> in <span class="math">G</span> and
every shape label <span class="math">T</span> in <span class=
"math">t(n)</span>, there exist three mutually disjoint sets
<span class="math">Matched</span>, <span class=
"math">OpenProp</span>, <span class="math">Rest</span> such that
<ol>
<li><a id="enum_1" name="enum_1"></a> <span class="math">out(G,n) =
Matched &cup; OpenProp &cup; Rest</span>, and</li>
<li><a id="enum_2" name="enum_2"></a> <span class="math">Rest =
{(n, p, u) &isin; out(G,n) | p &notin; properties(expr(T,
S))}</span>, and</li>
<li><a id="enum_3" name="enum_3"></a> <span class="math">Matched =
{(n, p, u) &isin; out(G,n) | (n, p, u)</span> matches <span class=
"math">a::C</span> for some triple constraint <span class=
"math">a::C</span> that appears in <span class="math">expr(T,
S)}</span>, and</li>
<li><a id="cond__shape_expression_is_satisfied" name=
"cond__shape_expression_is_satisfied"></a> [cond: shape expression
is satisfied] there exists a proof tree with corresponding witness
mapping <span class="math">wm</span> for the fact that <span class=
"math">Matched</span> satisfies <span class="math">expr(T,
S)</span> s.t., for all shape triple constraint <span class=
"math">a::C</span> that occurs in <span class="math">expr(T,
S)</span>, and for all triple <span class="math">(n, p, u)</span>
with <span class="math">wm((n, p, u)) = a::C</span>, we have
<span class="math">C &isin; t(u)</span>, and</li>
<li><a id="enum_4" name="enum_4"></a> for all triple <span class=
"math">(n, p, u)</span> in <span class="math">OpenProp</span>, we
have <span class="math">p &isin; incl(T, S)</span>, and</li>
<li><a id="enum_5" name="enum_5"></a> if <span class=
"math">T</span> is a closed shape, then <span class="math">Rest =
&empty;</span>, and</li>
<li><a id="enum_6" name="enum_6"></a> for all extension condition
<span class="math">(lang, cond)</span>, associated with the type
<span class="math">T</span>, <span class="math">f<sub>lang</sub>(G,
n, cond)</span> returns <span class="math">true</span> or
<span class="math">undefined</span>.</li>
</ol>
</div>
In the above definition, intuitively,
<ol>
<li><span class="math">out(G, n)</span> can be decomposed in three
disjoint sets <span class="math">Matched</span>, <span class=
"math">OpenProp</span>, <span class="math">Rest</span> s.t.</li>
<li><span class="math">Rest</span> contains exactly the triples
which property is not mentioned in <span class="math">expr(T,
S)</span>, and</li>
<li><span class="math">Matched</span> contains exactly the triples
that match some of the triple constraints that appear in
<span class="math">expr(T, S)</span>. Moreover</li>
<li><span class="math">Matched</span> needs to satisfy <span class=
"math">expr(T, S)</span>, and to propagate the shape constraints:
whenever a triple <span class="math">(n, p, u)</span> is a witness
for the shape constraint <span class="math">a::C</span>, the
required shape <span class="math">C</span> is indeed associated to
its object node <span class="math">u</span> by the valid typing
<span class="math">t</span>. Additionally,</li>
<li>the triples which properties appear in <span class=
"math">expr(T, S)</span>, but did not match any of the triple
constraints from <span class="math">expr(T, S)</span>, must have
their property among the allowed extra properties.
Additionally,</li>
<li>for closed shapes, non extra triples than those used for
satisfying <span class="math">expr(T, S)</span> are allowed. Remark
that, for closed shapes, <span class="math">incl(T, S)</span> is
empty, therefore <span class="math">OpenProp</span> is also empty.
Finally,</li>
<li>the node <span class="math">n</span> satisfies all the
extension constraints.</li>
</ol>
For a node <span class="math">n</span> in a graph <span class=
"math">G</span> and a schema <span class="math">S</span>, we say
that <span class="math">n</span> <span class="emph">satisfies
shape</span> <span class="math">T</span> from <span class=
"math">S</span> if there exists a valid typing <span class=
"math">t</span> of for graph <span class="math">G</span> by
<span class="math">S</span> s.t. <span class="math">T</span> is in
<span class="math">t(n)</span>.
</section>
<section>
<h2 id="Complex_shape_constraints">Complex shape constraints</h2>
<a id="sec__complex_shape_constraints" name=
"sec__complex_shape_constraints"></a> In the previous sections we
considered that a shape constraint is simply a shape label,
indicating the required shape for a node. In what follows, we
introduce more complex shape constraints as conjunctions and
disjunctions of required shapes, as defined by the following
abstract syntax.
<div class="abstrsynt"><span class="math">ShConstr ::=
DisjunctiveShapeConstr | ConjShapeConstraint</span><br />
<span class="math">DisjunctiveShapeConstr ::= ShapeLabel (or
ShapeLabel)*</span><br />
<span class="math">ConjShapeConstraint ::= ShapeLabel (and
ShapeLabel)*</span></div>
Extending the semantics to this new construct requires only a
slight modification of valid typing, namely the condition <a href=
"#cond__shape_expression_is_satisfied">cond: shape expression is
satisfied</a>. from Definition <a href=
"#def__typing__valid_typing">def: typing, valid typing</a> is to be
replaced by the following.
<div class="Definition"><span class="block-name">Definition</span>
[Valid typing with complex shape constraints] <a id=
"def__valid_typing_with_complex_shape_constraints" name=
"def__valid_typing_with_complex_shape_constraints"></a> there
exists a proof tree with corresponding witness mapping <span class=
"math">wm</span> for the fact that <span class=
"math">Matched</span> satisfies <span class="math">expr(T,
S)</span> s.t., for all shape triple constraint <span class=
"math">a::C</span> that occurs in <span class="math">expr(T,
S)</span>, and for all triple <span class="math">(n, p, u)</span>
with <span class="math">wm((n, p, u)) = a::C</span>, we have
<ul>
<li>if <span class="math">a::C</span> is a disjunctive shape
constraint, say <span class="math">C = T<sub>1</sub> or ldots or
T<sub>k</sub></span>, then <span class="math">T</span>i belongs to
<span class="math">t(u)</span> for some <span class=
"math">T</span>i among <span class="math">T<sub>1</sub>, ...
Tk</span>, and</li>
<li>if <span class="math">a::C</span> is a conjunctive shape
constraint, say <span class="math">C = T<sub>1</sub> and ldots and
T<sub>k</sub></span>, then <span class="math">{T<sub>1</sub>,
ldots, T<sub>k</sub>} &sube; t(u)</span>, that is, all the required
types belong to <span class="math">t(u)</span>.</li>
</ul>
</div>
</section>
<section>
<h2 id="Adding_a_one-of_constraint">Adding a one-of constraint</h2>
<section>
<h3 id="Syntax">Syntax</h3>
We add the one-of operator to the abstract syntax by the following.
<div class="abstrsynt"><span class="math">ShapeExpr ::=
EmptyShape</span><br />
<span class="math">| (TripleConstraint | InverseTripleConstraint)
Cardinality</span><br />
<span class="math">| DisjunctiveShape</span><br />
<span class="math">| GroupShape</span><br />
<span class="math">| OneSh</span><br />
<span class="math">OneSh ::= ShapeExpr ('&bull;'
ShapeExpr)*</span><br /></div>
We impose a syntactic restriction to the use of the one-of
operator, which is that all types that appear in the
sub-expressions of <span class="math">OneSh</span> are non
recursive. Formally, for a schema <span class="math">S</span>, the
<span class="emph">shapes dependency graph</span> of <span class=
"math">S</span> is the directed graph which nodes are the shape
labels that occur in <span class="math">S</span>, and that has an
edge from <span class="math">T1</span> to <span class=
"math">T2</span> iff the shape name <span class="math">T2</span>
appears in the shape definition for <span class="math">T1</span> in
<span class="math">S</span> (that is, there is a triple shape
constraint <span class="math">a::C</span> in <span class=
"math">expr(T1, S)</span> s.t. <span class="math">T2</span> is one
of the types in <span class="math">C</span>). We denote
<span class="math">depgr(S)</span> the dependency graph of
<span class="math">S</span>. Moreover, for a shape label
<span class="math">T</span> in <span class="math">S</span>, let
<span class="math">depgr(S, T)</span> be the sub-graph of
<span class="math">depgr(S)</span> induced by the set of nodes
<span class="math">T2</span> that are reachable from <span class=
"math">T</span> in <span class="math">depgr(S)</span>; here by
reachable we mean standard reachability in graphs. Given a schema
<span class="math">S</span> and a shape label <span class=
"math">T</span> in <span class="math">S</span>, we say that
<span class="math">T</span> is <span class="emph">recursion
free</span> in <span class="math">S</span> iff <span class=
"math">depgr(S, T)</span> is a directed acyclic graph. We now
impose the following syntactic restriction on schemas <span class=
"math">S</span> using the one-of operator.
<div class="quote">For all one-of sub-expression <span class=
"math">Expr<sub>1</sub> &bull; ... &bull; Expr<sub>k</sub></span>
that appears in some shape definition in <span class=
"math">S</span>, and for all shape label <span class=
"math">T</span> that appears in some of the <span class=
"math">Expr<sub>1</sub>, ..., Expr<sub>k</sub></span>, the type
<span class="math">T</span> is recursion free in <span class=
"math">S</span>.</div>
Schemas that do not satisfy this syntactic restriction are
considered invalid schemas. Remark also that it can be tested in
linear time in the size of the representation of the schema whether
a schema enjoys this syntactic restriction.
</section>
<section>
<h3 id="Semantics">Semantics</h3>
For defining the semantics of the one-of operator, we amend
Definition <a href=
"#def__set_of_triples_satisfies_a_shape_expression">def: set of
triples satisfies a shape expression</a> and Definition <a href=
"#def__valid_typing_with_complex_shape_constraints">def: valid
typing with complex shape constraints</a> in the following way.
<div class="Definition"><span class="block-name">Definition</span>
[Set of triples satisfies a shape expression using one-of operator]
<ul>
<li><span class="math">Expr</span> is a one-of shape, let
<span class="math">Expr = Expr<sub>1</sub> &bull; Expr<sub>2</sub>
&bull; ... &bull; Expr<sub>k</sub></span>, and <span class=
"math">Neigh</span> satisfies <span class=
"math">Expr<sub>1</sub></span>, or <span class="math">Neigh</span>
satisfies <span class="math">Expr<sub>2</sub></span>, ... or
<span class="math">Neigh</span> satisfies <span class=
"math">Expr<sub>k</sub></span>;</li>
</ul>
</div>
The corresponding inference rule is <img src=
"html-handmade-images/inference-oneof-rule.png" /> We now introduce a notation. Consider
a schema <span class="math">S</span> and a proof tree for some
<span class="math">Neigh |- Expr</span>, where <span class=
"math">Neigh</span> is a set of triples and <span class=
"math">Expr</span> is a shape definition in <span class=
"math">S</span>. Given a node <span class="math">r</span> in that
proof tree that corresponds to an application of rule-choice, let
<span class="math">Expr<sub>ri</sub></span> be the choice
sub-expression used in the proof in node <span class=
"math">r</span> (that is, node <span class="math">r</span> has the
shape of rule-choice above, and <span class=
"math">Expr<sub>ri</sub></span> is the <span class=
"math">Expr<sub>i</sub></span> in the premise of <span class=
"math">r</span> in the proof tree). We denote <span class=
"math">S<sub>ri</sub></span> the schema obtained from <span class=
"math">S</span> by removing the sub-expression <span class=
"math">Expr<sub>ri</sub></span> from <span class="math">S</span>.
We replace Definition <a href=
"#def__valid_typing_with_complex_shape_constraints">def: valid
typing with complex shape constraints</a> by the following:
<div class="Definition"><span class="block-name">Definition</span>
[Valid typing for schemas with one-of operator]
<div class="small">there exists a proof tree with corresponding
witness mapping <span class="math">wm</span> for the fact that
<span class="math">Matched</span> satisfies <span class=
"math">expr(T, S)</span> s.t., for all shape triple constraint
<span class="math">a::C</span> that occurs in <span class=
"math">expr(T, S)</span>, and for all triple <span class="math">(n,
p, u)</span> with <span class="math">wm((n, p, u)) = a::C</span>,
we have
<ul>
<li>if <span class="math">a::C</span> is a disjunctive shape
constraint, say <span class="math">C = T<sub>1</sub> or ... or
T<sub>k</sub></span>, then <span class="math">T<sub>i</sub></span>
belongs to <span class="math">t(u)</span> for some <span class=
"math">Ti</span> among <span class="math">T<sub>1</sub>, ...,
T<sub>k</sub></span>, and</li>
<li>if <span class="math">a::C</span> is a conjunctive shape
constraint, say <span class="math">C = T<sub>1</sub> and ... and
T<sub>k</sub></span>, then <span class="math">{T<sub>1</sub>,
ldots, T<sub>k</sub>} &sube; t(u)</span>, that is, all the required
types belong to <span class="math">t(u)</span>,<br /></li>
</ul>
</div>
and moreover
<ul>
<li>for all node <span class="math">r</span> of the proof tree that
correspons to an application of rule-choice, there does not exist a
valid typing of <span class="math">G</span> by <span class=
"math">S<sub>ri</sub></span>.</li>
</ul>
</div>
The newly added condition basically means that for all graph
<span class="math">G</span>, for all node <span class=
"math">n</span> in <span class="math">G</span>, for all schema
<span class="math">S</span>, and for all shape label <span class=
"math">T</span> in <span class="math">S</span>, all valid typings
<span class="math">t</span> of <span class="math">G</span> by
<span class="math">S</span> such that <span class="math">T &isin;
t(n)</span> agree on the one-of sub-expression <span class=
"math">Expr<sub>i</sub></span> in <span class="math">expr(T,
S)</span> used for witnessing that <span class="math">out(G,
n)</span> satisfies <span class="math">expr(T, S)</span>, for all
one-of expression <span class="math">Expr 1 &bull; ... &bull;
Expr<sub>k</sub></span> in <span class="math">expr(T, S)</span>.
This apparently very strong requirement is easy to check. Indeed,
even though the definition requires for all valid typings to agree,
we do not need to check all the valid typings. Because of the non
recursiveness restriction for schemas, it is sufficient to check a
small number of possible typings and conclude whether the property
holds for all valid typings.
</section>
</section>
</section>

<!--
    <section id="matching">
      <h2>Matching</h2>
      <p>
        This section defines the semantics of <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shapes</a> as a test to see if a <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> in an RDF graph fulfills the shapes constraints.
        Section 6 <a href="assoc">Associating Nodes with Shapes</a> defines facilities for associating a <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> with a <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a>.
      </p>
      <div class="defn">
        <dfn id="dfn-shacl-triple-constraint-matches">triple constraint matches</dfn>
        <p>
          Evaluating a <a title="SHACL constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraint</a> against a <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> produces a boolean value.
          Evaluation of each form of constraint is defined in <a href="#eval-triple-constraints">6.1 Triple Constraint Evaluation</a>.
        </p>
      </div>
      <div class="defn">
        <dfn id="dfn-shacl-shape-matches">shape matches</dfn>
        <p>
          If the <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a> has no <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraint</a>, the result is true.
          Otherwise, evaluation produces the result is the result of evaluating <a title="triple constraint matches" href="#dfn-shacl-triple-constraint-matches">triple constraint matches</a> on the <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraint</a> with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>.
        </p>
        <p>
          The set of failing triples for a shape is the set of failing triples for each constraint minus the passing triples for each constraint.
          A <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> <dfn id="dfn-shacl-matches">matches</dfn> a <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a> if there are no remaining failing triples.
          The result is a boolean value.
        </p>
      </div>
      <section id="eval-triple-constraints">
        <h3>Triple Constraint Evaluation</h3>

        <div class="defn">
          <dfn id="dfn-shacl-property-constraint-matches">triple constraint matches</dfn>
          <p>
            The <dfn id="dfn-shacl-matching-triples">matching triples</dfn> is the set of triples in the graph with the subject node of the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> and a predicate of the <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint's</a> predicate.
            Evaluation of a triple constraint produces true if each of the following is true:
          </p>
          <ul>
            <li>If the triple constraint has a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> greather than 0, the <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> number at least that minimum cardinality.</li>
            <li>If the triple constraint has a <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a> greather than 0, the <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> number no more than that maximum cardinality.</li>
            <li>If there is a <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">term constraint</a> present, for each object in <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a>, that object matches (see <a href="#eval-term-constraints">6.2 Term Constraint Evaluation</a>)</li>
          </ul>
        </div>

        <div class="defn">
          <dfn id="dfn-shacl-inverse-property-constraint-matches">inverse triple constraint matches</dfn>
          <p>
            The <a title="shacl matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> is the set of triples in the graph with the subject node of the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> and a predicate of the <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint's</a> predicate.
          </p>
        </div>

        <div class="defn">
          <dfn id="dfn-shacl-and-constraint-matches">group shape matches</dfn>
          <p>
            Evaluation of an <a title="group shape" href="#dfn-shacl-and-constraint" class="internalDFN">group shape</a> produces true if evaluation of each of the <a title="SHACL conjunct" href="#dfn-shacl-conjunct" class="internalDFN">conjuncts</a> with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> produces true.
          </p>
        </div>

        <div class="defn">
          <dfn id="dfn-shacl-or-constraint-matches">disjunctive shape matches</dfn>
          <p>
            Evaluation of an <a title="disjunctive shape" href="#dfn-shacl-or-constraint" class="internalDFN">disjunctive shape</a> produces true if evaluation of any of the constituent constraints with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> produces true.
          </p>
        </div>
      </section>

      <section id="eval-term-constraints">
        <h3>Term Constraint Evaluation</h3>

        <p>
          <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">Term constraints</a> are tested against the objects of <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> in <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraints</a> and the subjects of <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> in <a title="SHACL triple constraint" href="#dfn-shacl-inverse-property-constraint" class="internalDFN">inverse triple constraints</a>.
        </p>

        <div class="defn">
          <dfn id="dfn-node-type-matches">node type matches</dfn>
          <p>
            Evaluation of a <a title="SHACL node type" href="#dfn-shacl-node-type" class="internalDFN">node type</a> produces true if the evaluated term is of the same RDF Node type (<a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a>, <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a>, or <a title="RDF Blank Node" href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node" class="externalDFN">Blank Node</a>).
          </p>
        </div>

				<div class="defn">
          <dfn id="dfn-shacl-datatype-matches">datatype matches</dfn>
          <p>
            Evaluation of a <a title="SHACL datatype" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> produces true if the evaluated term is an <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a> with the same <a title="datatype IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri" class="externalDFN">datatype IRI</a>.
          </p>
        </div>

				<div class="defn">
          <dfn id="dfn-shacl-value-set-matches">value set matches</dfn>
          <p>
            Evaluation of a <a title="SHACL value set" href="#dfn-shacl-value-set" class="internalDFN">value set</a> produces true if the evaluated term is a member of the set of <a title="shacl allowed values" href="#dfn-shacl-allowed-value" class="internalDFN">allowed values</a>.
          </p>
        </div>

				<div class="defn">
          <dfn id="dfn-shacl-value-shape-matches">value shape matches</dfn>
          <p>
            Evaluation of a <a title="SHACL value shape" href="#dfn-shacl-value-shape" class="internalDFN">value shape</a> is the result of evaluating <a title="SHACL shape matches" href="#dfn-shacl-shape-matches" class="internalDFN">shape matches</a> where the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> is the evaluated term.
          </p>
        </div>

      </section>
    </section>
-->

    <!-- section>
      <h2>notes</h2>
      <p>
Adding examples...<br/>
<br/>
<b># empty</b><br/>
<br/>
empty: no constraint.<br/>
<br/>
Example:<br/>
<br/>
<br/>
Note:If we are using open shapes, it will match any node without constraint.<br/>
<br/>
(Maybe, the following comment can be omitted:<br/>
In case of closed shapes it would match a node without any incoming or outgoing edges.<br/>
)<br/>
<br/>
<br/>
<b># arc</b><br/>
<br/>
arc predicate value cardinality: match an arc in the graph with some cardinality.<br/>
<br/>
Two possibilities: unbounded cardinality and bounded cardinality<br/>
<br/>
## arc with unbounded cardinality<br/>
<br/>
arc predicate value {m, unbounded}: it will match a node that has at least m outgoing arcs and whose objects match with the value.<br/>
<br/>
In the axiomatic semantics, I look for m outgoing arcs that match the predicate and value...and return the remaining triples...I think I should reject if there are remaining triples that match the predicate but have values that don't match...
      </p>

<div class="issue">
<h3>Issue (RemainingTriples)</h3>
<p>
It is not clear what is the best semantics when there are remaining triples with the same predicate that don't match the object. Eric's proposal is to fail in that case. Which would mean that the semantics needs to consider that there are no remaining triples with the same predicate and a value that doesn't match. Current axiomatic semantics doesn't fail in that case as it considers those triples "remaining" triples...it would fail if we are using closed shapes.
</p>
<h4>Example:</h4>
<pre>
     schema   -&gt; &lt;shape&gt; { :shoeSize &lt;xsd:integer {1,1} }
     data  -&gt;       &lt;x&gt; :shoeSize "hi" . (should fail because the value doesn't match xsd:integer...
</pre>
<p>
[[<b>Eric</b>...Could you exlain here what you said about missing/failure in natural language...I know you said me in the Skype, but I would like to read it to have a more clear understanding on how you do it...so I could model that with the axiomatic semantics...]
</p>
</div>

<h3>arc with bounded cardinality</h3>
<p>
arc predicate value {m,n}: it will match a node that has between m and n outgoing arcs and whose objects match with the value.
</p>

<div class="issue">
<h3>Issue (remaining triples)</h3>
<p>
It has to review that there are no remaining triples that contain the predicate...
</p>
</div>

<h3>inverse arcs</h3>
<p>
There are also two possibilities: bounded and unbounded cardinality.
The semantics is mostly the same as "arc" but it matches the subjects instead ot the objects.
</p>
<h4>inverse arc with unbounded cardinality</h4>

<p>
inverseArc predicate value {m,unbounded}<br/>
<br/>
## inverse arc with bounded cardinality<br/>
<br/>
inverseArc predicate value {m,unbounded}<br/>
<br/>
# And, conjunction (or interleave)<br/>
<br/>
and(E1,...En): it matches if there are triples that match with E1 and there are triples that match with E2.
</p>

<div class="note">
<h4>Note</h4>
<p>
With this semantics, the same triple can be used to match parts of E1 and of E2.
</p>
<h4>Example:</h4>
<pre>
    schema: &lt;x&gt; { :a xsd:integer, :a . }
    data: &lt;x&gt; :a 1
</pre>
<p>
This example may look non-intuitive because it looks as if it would mean that the shape has two arcs, one with an integer and another with any value, but if there is a single arc with an integer which passes both conjunctions, it also pass.
</p>
</div>

<div class="issue">
<h3>Issue (Multioccurrence)</h3>
<p>
There is an issue when the same predicate occurs in the conjunction. For example:
</p>

<pre>
schema: &lt;x&gt; { :bioParent { :gender ("F") } {1,1} , :bioParent { :gender ("M") }&nbsp; {1,1} }
data: &lt;x&gt; :bioParent [ :gender "F" ] ; :bioParent [ :gender "M" ] .&nbsp; =&gt; Fail
data: &lt;x&gt; :bioParent [ :gender "F" ] ; :bioParent [ :gender "M" ] ; :bioParent [ :gender "Q" ] . =&gt; Fail
data: &lt;x&gt; :bioParent [ :gender "F" ] ; :bioParent [ :gender "M" ] ; :xxx [ :gender "Q" ] . =&gt; Fail should pass because open shapes...extra triples
</pre>

<p>
This issue depends on the "RemainingTriples" issue and the solution to that issue would solve this one.
</p>
</div>

<h3>Or, disjunction</h3>

<p>
or(E1...En): matches if the triples match any of E1...En shapes.<br/>
</p>

<h2>Extended features change that to "Issues"</h2>

<h3>Not</h3>
<p>
not(Shape): Matches if the triples don't match the Shape.
</p>

<div class="issue">
<h3>Issue (NegationShapes)</h3>
<p>
Negation of whole shapes can be difficult to handle when it is combined with recursive shapes.
</p>
<p class="todo">
Explain better and give some example...
</p>
<p>
We may define a simpler definition of negation which only negates arcs and not whole shapes.
</p>
</div>

<h3>noArc(Predicate,Value)</h3>
<p>
matches if there are no outgoing arc with that predicate and an object that matches that Value
</p>

<h3>noInverseArc(Predicate,Value)</h3>
<p>
matches if there are no incoming arc with that predicate and a subject that matches that value.
</p>

<h3>oneOf</h3>
<p>
oneOf(E1,E2) - matches if the triples match with E1 or they match with E2 but not with both.
</p>

<div class="issue">
<h3>Issue (Exclusive-or)</h3>
<p>
Exclusive Or seems to be more intuitive from use cases...for example, "a person has either full name or first name and given name, but not both. The main problem is that it needs negation.
</p>
</div>
<h3>Closed Shapes</h3>

<p>
close(E): matches if the triples match with node E and there are no remaining triples.
</p>

<h3>Issue</h3>
<p>
Maybe include also the notion of closed Schema
</p>
<h3>Cardinality on groups</h3>
<p>
group(E,cardinality): matches if the triples match with Shape E the number of times expressed by the cardinality
</p>

<h3>Extensibility mechanism</h3>

<p>
Extension(Language Code): matches if there is an external processor for language "Language" that process "Code" and returns true.
</p>

    </section -->

  </body>
</html>

