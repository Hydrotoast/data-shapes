<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <title>Core SHACL Semantics</title>
    <meta charset='utf-8'></meta>
    <script src='//www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <link rel="stylesheet" type="text/css" href="local.css" />
    <script class='remove'>
      var respecConfig = {
          specStatus: "ED",
          edDraftURI:  "http://w3c.github.io/data-shapes/semantics/#dfn-shacl-shape",
          shortName:  "shacl-semantics",
          editors: [
                {   name:       "Iovka Boneva",
                    url:        "http://cristal.univ-lille.fr/~boneva/",
                    company:    "University of Lille / Inria",
                    companyURL: "http://www.inria.fr/" },
                    {   name:       "Eric Prud'hommeaux",
                    url:        "http://www.w3.org/People/Eric/",
                    company:    "W3C/MIT",
                    companyURL: "http://www.w3.org/" }
          ],
          wg:           "RDF Data Shapes Working Group",
          wgURI:        "https://www.w3.org/2014/data-shapes",
          wgPublicList: "public-rdf-shapes",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
		  localBiblio:  {
			"xyz": {
				title:    "Sample Custom Reference",
				href:     "http://example.org/",
				"authors": [
					"S. Steyskal"
				],
				publisher: "xyz"
		    }
		  }
      };
    </script>
		<style>
			.todo {
				color: red;
			}
		    pre {
				tab-size: 4;
		    }
			th {
				text-align: left;
			}
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .example {
        display: inline-block;
      }
      .example.wrapper {
        background-color: #fff;
      }
      .example.wrapper pre {
        background-color: #fcfaee;
        margin-left: 0;
        line-height: 1.2;
      }
      .example.wrapper .fail {
        background-color: #fceefa
      }
      .verticalDivider {
        float: left;
        width: .5em;
        border:thin solid #fff; /* disappears without this */
      }

.highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
.highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
.lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
.lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
.highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
.highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
.lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
.lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */

.highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
.lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
.highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
.lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }

.new            { font-weight: bold; }
.errorSite      { color: red; }

.defn {
margin-left: 0;
margin-right: 2ex;
margin-top: 0.1ex;
margin-bottom: 0.1ex;
/* border: double 1px #888888; */
border: thin solid #888888;
padding: 1ex 2ex 0.5ex 2ex;
page-break-inside: avoid;
background-color: #F0F8F8;
}
h3 sup,h4 sup,.eval {
  font-weight: lighter;
  color: #307;
}
		</style>
  </head>
  <body>
    <section id='abstract'>
      This document defines the core SHACL (SHApes Constraint Language), a language for constraining RDF instance graphs.
    </section>

    <section id='sotd'>

      <p>
        Proposal to RDF Data Shapes WG
      </p>
    </section>

    <!-- taken from http://www.w3.org/2014/data-shapes/charter -->
    <section id="intro" class='informative'>
      <h2>Introduction</h2>
			<p>
				SHACL provides structural constraints for <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
				SHACL constraints are grouped into "shapes", which may also be referenced by constraints in other shapes.
				These constraints describe the <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a> connecting certain nodes in the graph.
				SHACL can constrain the number of triples with a particular predicate and the permitted object datatype or object terms, require that the subject or object match some shape or lexical and datatype conditions.
			</p>

    </section>
<!--
    <section id="notation">
      <h2>Notation</h2>
      <p>
        The following HTML tags and CSS classes are used to highlight the roles of text in this document:
      </p>
      <ul>
        <li>&lt;dfn&gt;<dfn id="dfn-shacl-defined-term">defined term</dfn>&lt;dfn&gt;</li>
        <li>&lt;a class="internalDFN"&gt;<a title="SHACL defined term" href="#dfn-shacl-defined-term" class="internalDFN">defined term</a>&lt;/a&gt;</li>
        <li><sup class="eval">eval</sup> &mdash; link to evaluation semantics</li>
      </ul>
    </section>
-->

    <section>
      <h2>Abstract Syntax</h2>
      <div>
        <h2>2.1 RDF abstract syntax</h2>
        <p>
          This document uses the following labels for terms in the RDF abstract syntax:
        </p>

        <ul>
          <li><code>Iri</code> - <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri">RDF IRI</a></li>
          <li><code>Blank</code> - <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node">RDF blank node</a></li>
          <li><code>Lit</code> - <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">RDF literal</a></li>
        </ul>
      </div>
<h2><a name="SECTION00012000000000000000" id=
"SECTION00012000000000000000"><span class=
"arabic">2</span>.<span class="arabic">2</span> Simple shape
expression schemas</a></h2>
<p>The abstract syntax of shape expression schemas is given below.
For now we use a simplified definition of one non-terminal, namely
<span class="textit">ShapeConstraint</span>, which is indicated by
the temporary rule <span class="textit">ShapeConstraintTemp</span>.
We make this simplification in order to make defining the semantics
easier, and we give the complete definition in
Section&nbsp;<a href="#sec:shex-full">1.4</a>.</p>
				<div class="defn">
<p><br />
<span class="textit">Schema</span>::= <span class=
"textit">Rule</span> +<br />
<span class="textit">Rule</span>::= <span class=
"textit">ShapeLabel</span> <span class=
"textit">ShapeDefinition</span><br />
<span class="textit">ShapeLabel</span>::= an identifier<br /></p>
        </div>
<p>A <span class="textit">Schema</span> is composed of at least one
rule (<span class="textit">Rule</span>). Every rule associates a
shape definition (<span class="textit">ShapeDefinition</span>) with
a label (<span class="textit">ShapeLabel</span>).</p>
				<div class="defn">
<p><br />
<span class="textit">ShapeDefinition</span>::= <span class=
"textit">ClosedShape</span> <span class="MATH"><img width="9"
height="32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class="textit">OpenShape</span><br />
<span class="textit">ClosedShape</span>::= '<span class=
"textsf">close</span>' <span class="textit">ShapeExpr</span><br />
<span class="textit">OpenShape</span>::= '<span class=
"textsf">open</span>' <span class="textit">InclPropSet</span>?
<span class="textit">ShapeExpr</span><br />
<span class="textit">InclPropSet</span>::= <span class=
"textit">PropertiesSet</span><br />
<span class="textit">PropertiesSet</span>::= set of <span class=
"textit">IRI</span><br /></p>
        </div>
<p>A shape definition is either a closed shape (<span class=
"textit">ClosedShape</span>), or an open shape (<span class=
"textit">OpenShape</span>). Both closed and open shapes are defined
by a shape expression (<span class="textit">ShapeExpr</span>). Open
shapes can have associated set of included properties (<span class=
"textit">InclPropSet</span>): properties of which arbitrary extra
occurances are permitted. Closed and open shapes will be
distinguished thanks the keywords <span class="textsf">close</span>
and <span class="textsf">open</span>, respectively.</p>
				<div class="defn">
<p><br />
<span class="textit">ShapeExpr</span>::= <span class=
"textit">EmptyShape</span><br />
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> (<span class=
"textit">TripleConstraint</span> <span class="MATH"><img width="9"
height="32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class=
"textit">InverseTripleConstraint</span>) <span class=
"textit">Cardinality</span><br />
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> <span class=
"textit">DisjunctiveShape</span><br />
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> <span class=
"textit">GroupShape</span><br />
<span class="textit">EmptyShape</span>::= '<span class=
"textsf">empty</span>'<br /></p>
        </div>
<p>A shape expression is either the empty shape (<span class=
"textit">EmptyShape</span>) represented by the keyword <span class=
"textsf">empty</span>, or a triple constraint (<span class=
"textit">TripleConstraint</span>) or an inverse triple constraint
(<span class="textit">InverseTripleConstraint</span>) followed by a
cardinality constraint (<span class="textit">Cardinality</span>),
or a disjunctive shape (<span class=
"textit">DisjunctiveShape</span>), or a grouping shape
(<span class="textit">GroupShape</span>).</p>
				<div class="defn">
<p><br />
<span class="textit">TripleConstraint</span>::= <span class=
"textit">IRI</span> <span class="textit">ValueConstraint</span>
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> <span class=
"textit">IRI</span> <span class=
"textit">ShapeConstraint</span><br />
<span class="textit">InverseTripleConstraint</span>::=
'<span class="textsf">inverse</span>' <span class=
"textit">TripleConstraint</span><br />
<span class="textit">Cardinality</span>::= '[' <span class=
"textit">MinCardinality</span>';' <span class=
"textit">MaxCardinality</span>']'<br />
<span class="textit">MinCardinality</span>::= a natural
number<br />
<span class="textit">MaxCardinality</span>::= a natural number
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> '<span class=
"textsf">unbound</span>'<br /></p>
        </div>
<p>Triple constraints are used to specify constraints to be
satisfied by the triples having the focus node as subject, and the
associated cardinality specifies how many triples satisfying the
triple constraint are required. Inverse triple constraints play a
similar role, but define constraints to be satisfied by the triples
having the focus node as object. We will write <span class=
"textit">a::C</span> for the triple constraint with IRI
<span class="textit">a</span>, and with value or shape constraint
<span class="textit">C</span>. Cardinalities will be written as an
interval in square brackets, and which maximum bound can be the
special value <span class="textsf">unbound</span>. In the examples,
we omit writing the cardinality when the minimal and the maximal
cardinality are both equal to one. That is, we write simply
<span class="textit">a::C</span> for <span class=
"textit">a::C</span>[1;1].</p>
				<div class="defn">
<p><br />
<span class="textit">ValueConstraint</span>::= <span class=
"textit">ValueSet</span> <span class="MATH"><img width="9" height=
"32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class="textit">LiteralDatatype</span>
<span class="textit">XSFacet</span>? <span class="MATH"><img width=
"9" height="32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class="textit">NodeKind</span><br />
<span class="textit">ShapeConstraintTemp</span>::= <span class=
"textit">ShapeLabel</span><br />
<span class="textit">ValueSet</span>::= set of literals and
<span class="textit">IRI</span><br />
<span class="textit">LiteralDatatype</span>::= an RDF literal
datatype<br />
<span class="textit">NodeKind</span>::= '<span class=
"textsf">iri</span>' <span class="MATH"><img width="9" height="32"
align="middle" border="0" src="img3.png" alt="$ \mid$" /></span>
'<span class="textsf">blank</span>' <span class="MATH"><img width=
"9" height="32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> '<span class="textsf">literal</span>'
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> '<span class=
"textsf">non-literal</span>'<br />
<span class="textit">XSFacet</span>::= an XSD restriction</p>
        </div>
<p>Triple constraint can constraint the object of a triple in two
different ways. Either they require the object to a have some
particular value (value constraint), or they require the object
node to satisfy a shape constraint. A value constraint can be
specified in three different ways: as a set of concrete values,
that can be IRI or literals; or as a literal data possibly XSD
facet restriction attached to it; or as a kind of the node, among
IRI, Blank, literal or non literal.</p>
				<div class="defn">
<p><br />
<span class="textit">DisjunctiveShape</span>::= <span class=
"textit">ShapeExpr</span> (<span class="MATH"><img width="9"
height="32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class="textit">ShapeExpr</span>)*<br />
<span class="textit">GroupShape</span>::= <span class=
"textit">ShapeExpr</span> (',' <span class=
"textit">ShapeExpr</span>)*<br /></p>
        </div>
<p>Finally, complex shape expressions can be built thanks to two
operators: disjunction, and grouping. A disjunctive shape
(<span class="textit">DisjunctiveShape</span>) requires that one of
the disjunct shape expressions is satisfied. A group shape
(<span class="textit">GroupShape</span>) requires for the
neighbourhood of the focus node to be split in as many sets of
triples as there are sub-expressions, and every such set of triples
must satisfy constraint given by the corresponding
sub-expression.</p>
<div class="todo"><b>Example <span class="arabic">1</span></b> &nbsp; The issues
example. Identify the triple constraints there.</div>
    </section>
<!--
    <section>
      <h2>Abstract Syntax</h2>
			<p>
				A <dfn id="dfn-shacl-shape">shape</dfn> <sup><a title="shape matches" href="#dfn-shacl-shape-matches">eval</a></sup> describes the triples whose subject or object is some <dfn id="dfn-shacl-focus-node">focus node</dfn> in an RDF graph.
				A shape has zero or one <dfn id="dfn-shacl-triple-constraint">triple constraints</dfn> attached to it which describe the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>'s triples.
        A triple constraint is one of the following:
      </p>
      <ul>
        <li><a title="triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> defines the characteristics of matching triples associated with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>.</li>
        <li><a title="inverse triple constraint" href="#dfn-shacl-inverse-property-constraint" class="internalDFN">inverse triple constraint</a> defines the characteristics of matching triples associated with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>.</li>
        <li><a title="group shape" href="#dfn-shacl-and-constraint" class="internalDFN">group shape</a> defines matching of a set of <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraints</a>.</li>
        <li><a title="disjunctive shape" href="#dfn-shacl-or-constraint" class="internalDFN">disjunctive shape</a> defines matching of a set of <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraints</a>.</li>
      </ul>
      <p>
			</p>
      <section>
        <h3>Triple Constraint <sup><a title="SHACL triple constraint matches" href="#dfn-shacl-property-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
				  A <dfn id="dfn-shacl-property-constraint">triple constraint</dfn> has a <dfn id="dfn-shacl-predicate">predicate</dfn> which identifies the triple's predicate and may have a <dfn id="dfn-shacl-min-card">minimum cardinality</dfn> and/or <dfn id="dfn-shacl-max-card">maximum cardinality</dfn>, to indicate how many triples with that predicate are expected.
				  The triple constraint also has zero or one <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">term constraints</a> which apply to the <em>object</em> of <a title="SHACL conjunct" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a>.
			  </p>
        <section id="dfn-shacl-term-constraint">
          <h4>Term Constraints</h4>
          <p>
            Where a triple constraint describes matching <a title="RDF Triples" href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple" class="externalDFN">RDF Triples</a> [[!RDF11-CONCEPTS]], a term constraint describes matching <a title="RDF Term" href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term" class="externalDFN">RDF Terms</a> [RDF Concepts].
          </p>
			  <ul>
				  <li><dfn id="dfn-shacl-node-type">node type</dfn> <sup><a title="SHACL node type matches" href="#dfn-node-type-matches" class="internalDFN">eval</a></sup>: identifies the RDF Node type (<a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a>, <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a>, or <a title="RDF Blank Node" href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node" class="externalDFN">Blank Node</a>).</li>
				  <li><dfn id="dfn-shacl-datatype">datatype</dfn> <sup><a title="SHACL datatype matches" href="#dfn-datatype-matches" class="internalDFN">eval</a></sup>: identifies the <a title="datatype IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri" class="externalDFN">datatype IRI</a> of an <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a>.</li>
				  <li><dfn id="dfn-shacl-value-set">value set</dfn> <sup><a title="SHACL value set matches" href="#dfn-shacl-value-set-matches" class="internalDFN">eval</a></sup>: a set of permissible <a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a>, <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a> values called <dfn id="dfn-shacl-allowed-value">allowed values</dfn>.</li>
				  <li><dfn id="dfn-shacl-value-shape">value shape</dfn> <sup><a title="SHACL valu shape matches" href="#dfn-shacl-value-shape-matches" class="internalDFN">eval</a></sup>: identifies a <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a> and asserts that the term is described by that shape.</li>
			  </ul>
        </section>
      </section>

      <section>
        <h3>Inverse Triple Constraint <sup><a title="SHACL inverse triple constraint matches" href="#dfn-shacl-inverse-property-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
          The <dfn id="dfn-shacl-inverse-property-constraint">inverse triple constraint</dfn> is comprised of the same components as the triple constraint except it may NOT have:
			  </p>
        <ul>
          <li>a <a title="SHACL conjunct" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> constraint</li>
          <li>a <a title="value set" href="#dfn-shacl-value-set" class="internalDFN">value set</a> with any <a title="SHACL conjunct" href="#dfn-shacl-allowed-value" class="internalDFN">allowed value</a> which is an RDF Literal</li>
        </ul>
        <p>
				  <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">Term constraints</a> apply to the <em>subject</em> of <a title="SHACL conjunct" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a>.
        </p>
      </section>

      <section>
        <h3>Group Shape <sup><a title="SHACL group shape matches" href="#dfn-shacl-and-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
          The <dfn id="dfn-shacl-and-constraint">group shape</dfn> is a set of properties called <dfn id="dfn-shacl-conjunct">conjuncts</dfn>.
			  </p>
      </section>

      <section>
        <h3>Disjunctive Shape <sup><a title="SHACL disjunctive shape matches" href="#dfn-shacl-or-constraint-matches" class="internalDFN">eval</a></sup></h3>
			  <p>
          The <dfn id="dfn-shacl-or-constraint">disjunctive shape</dfn> is a set of properties called <dfn id="dfn-shacl-conjunct">disjuncts</dfn>.
			  </p>
      </section>
    </section>
-->
    <section>
      <h2>RDF Vocabulary</h2>
			<p>
        The SHACL abstract syntax above can be represented in an RDF graph.
        RDF graphs are subject to the constraints in the abstract syntax above, e.g. that a triple constraint may have at most one term constraint.
      </p>

      <p>
        SHACL <code>triple constraints</code> can be parsed with a SPARQL query:
      </p>

      <div style="border-left: medium solid #ddd;">
        <pre>
<span class="keyword">PREFIX</span> <span class="type">sh:</span><span class="function-name">&lt;<a href="http://www.w3.org/ns/shacl#">http://www.w3.org/ns/shacl#</a>&gt;</span><span class="comment">
</span><span class="keyword">PREFIX</span> <span class="type">xsd:</span><span class="function-name">&lt;<a href="http://www.w3.org/2001/XMLSchema#">http://www.w3.org/2001/XMLSchema#</a>&gt;</span><span class="comment">
</span><span class="keyword">PREFIX</span> <span class="type">rdf:</span> <span class="function-name">&lt;<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</a>&gt;</span><span class="comment">
</span>
<span class="keyword">SELECT</span> <span class="variable-name">?entry</span> <span class="variable-name">?isShape</span> <span class="variable-name">?choice</span> <span class="variable-name">?group</span> 
(IF(Bound(<span class="variable-name">?property</span>),                      <span class="comment"># compile TripleConstraint
</span>    CONCAT(<span class="string">"ShapeExpr(TripleConstraint("</span>,
      <span class="string">"IRI("</span>, STR(<span class="variable-name">?predicate</span>), <span class="string">"), "</span>,
      IF(Bound(<span class="variable-name">?valueType</span>),      CONCAT(<span class="string">"ValueType(IRI("</span>,STR(<span class="variable-name">?valueType</span>),<span class="string">"))"</span>),   <span class="comment"># valueType
</span>        IF(Bound(<span class="variable-name">?nodeKind</span>),     CONCAT(<span class="string">"NodeKind(IRI("</span>,STR(<span class="variable-name">?nodeKind</span>),<span class="string">"))"</span>),     <span class="comment"># nodeKind
</span>          IF(Bound(<span class="variable-name">?shapeLabel</span>), CONCAT(<span class="string">"ShapeLabel(IRI("</span>,STR(<span class="variable-name">?shapeLabel</span>),<span class="string">"))"</span>), <span class="comment"># valueShape
</span>                                 CONCAT(<span class="string">"ValueSet("</span>,<span class="keyword">GROUP</span>_CONCAT(CONCAT(          <span class="comment"># allowedValue
</span>                                     IF(IsLiteral(<span class="variable-name">?allowedValue</span>), <span class="string">"Literal"</span>, <span class="string">"IRI"</span>), <span class="comment"># IRIs and Literals
</span>                                           <span class="string">"("</span>, STR(<span class="variable-name">?allowedValue</span>), <span class="string">")"</span>)
                                   ),<span class="string">")"</span>)
      ))),
     <span class="string">"))["</span>,if(Bound(<span class="variable-name">?min1</span>), STR(<span class="variable-name">?min1</span>), <span class="string">"1"</span>),<span class="string">","</span>,if(Bound(<span class="variable-name">?max1</span>), STR(<span class="variable-name">?max1</span>), <span class="string">"INF"</span>),<span class="string">"]"</span>), <span class="comment"># cardinality
</span>    <span class="string">""</span>) <span class="keyword">AS</span> <span class="variable-name">?TripleConstraint</span>)
where { 
  {
    <span class="variable-name">?entry</span> <span class="type">sh:</span><span class="constant">property</span> <span class="variable-name">?property</span> .
    <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">predicate</span> <span class="variable-name">?predicate</span> ;
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">minCount</span> <span class="variable-name">?min1</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">maxCount</span> <span class="variable-name">?max1</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">valueType</span> <span class="variable-name">?valueType</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">nodeKind</span> <span class="variable-name">?nodeKind</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">valueShape</span> <span class="variable-name">?shapeLabel</span> }
    <span class="keyword">OPTIONAL</span> { <span class="variable-name">?property</span> <span class="type">sh:</span><span class="constant">allowedValue</span> <span class="variable-name">?allowedValue</span>
               <span class="keyword">FILTER</span> (IsIRI(<span class="variable-name">?allowedValue</span>) || IsLiteral(<span class="variable-name">?allowedValue</span>)) }
  } <span class="keyword">UNION</span> {
    <span class="variable-name">?entry</span> <span class="type">sh:</span><span class="constant">choice</span> <span class="variable-name">?choice</span>
  } <span class="keyword">UNION</span> {
    <span class="variable-name">?entry</span> <span class="type">sh:</span><span class="constant">propertyGroup</span> <span class="variable-name">?group</span>
  }
  <span class="keyword">OPTIONAL</span> { <span class="variable-name">?entry</span> <span class="keyword">a</span> <span class="type">sh:</span><span class="constant">Shape</span>
    <span class="keyword">BIND</span>(true <span class="keyword">AS</span> <span class="variable-name">?isShape</span>)
  }
} <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="variable-name">?entry</span> <span class="variable-name">?isShape</span> <span class="variable-name">?property</span> <span class="variable-name">?predicate</span> <span class="variable-name">?choice</span> <span class="variable-name">?group</span>
           <span class="variable-name">?min1</span> <span class="variable-name">?max1</span> <span class="variable-name">?valueType</span> <span class="variable-name">?nodeKind</span> <span class="variable-name">?shapeLabel</span>
        </pre>
      </div>

      <p>
        This produces a hierarchy table with five columns: <code>entry</code>, <code>isShape</code>, <code>choice</code>, <code>group</code>, <code>TripleConstraint</code>. The abstract syntax is built in two steps:
      </p>

      <ol>
        <li>compose a map of <code>entry</code> to list of tuples of <code>isShape</code>, <code>choice</code>, <code>group</code>, <code>TripleConstraint</code></li>
        <li>
          starting with entries where <code>isShape</code> is true, compose a <code>Rule(entry, GroupShape())</code>. The <code>embed</code> function takes the entry and the GroupShape:<br/>
          for each mapping e with a key of entry
          <ul>
            <li>if choice is bound, </li>
            <li>starting with entries where <code>isShape</code> is true, compose a shape with a function <code>embed</code>:</li>
          </ul>
        </li>
      </ol>

      <p>
        RDF node types are identified by the following IRIs:
      </p>
      <div class="center">
        <table class="allname" style="text-align: left" border="2" cellpadding="5">
          <caption> <span class="caption">Table 2.</span> RDF Node Type Identifiers
          </caption>
          <tbody>
            <tr><th>RDF node type</th>                                                                                                                                <th>SHACL identifier</th></tr>
            <tr><td><a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a></td> <td class="name"><span class="type">sh:</span><span class="constant">IRI</span></td></tr>
            <tr><td><a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">Literal</a></td> <td class="name"><span class="type">sh:</span><span class="constant">Literal</span></td></tr>
            <tr><td><a title="RDF Blank Node" href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node" class="externalDFN">Blank Node</a></td> <td class="name"><span class="type">sh:</span><span class="constant">BNode</span></td></tr>
          </tbody>
        </table>
      </div>

      <section>
        <h3>RDF instance example</h3>
        <p>
          The following example represents a shape <code><span class="function-name">my:UserShape</span></code> composed of an <a title="SHACL group shape" href="#dfn-shacl-and-constraint" class="internalDFN">group shape</a> with two <a title="SHACL conjunct" href="#dfn-shacl-conjunct" class="internalDFN">conjuncts</a>:
        </p>
        <ol>
          <li>An <a title="SHACL disjunctive shape" href="#dfn-shacl-or-constraint" class="internalDFN">disjunctive shape</a> with two <a title="SHACL disjunct" href="#dfn-shacl-disjunct" class="internalDFN">disjuncts</a>:
          <ol>
            <li>A <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> with a <a title="SHACL predicate" href="#dfn-shacl-predicate" class="internalDFN">predicate</a> of <span class="type">foaf:</span><span class="constant">name</span>, a <a title="SHACL datatype" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> of <span class="type">xsd:</span><span class="constant">string</span>, a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> of 1, a <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a> of 1.</li>
            <li>A <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> with a <a title="SHACL predicate" href="#dfn-shacl-predicate" class="internalDFN">predicate</a> of <span class="type">foaf:</span><span class="constant">givenName</span>, a <a title="SHACL datatype" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> of <span class="type">xsd:</span><span class="constant">string</span>, a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> of 1, no <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a>.</li>
          </ol>
          </li>
          <li>A <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint</a> with a <a title="SHACL predicate" href="#dfn-shacl-predicate" class="internalDFN">predicate</a> of <span class="type">foaf:</span><span class="constant">mbox</span>, a <a title="SHACL node type" href="#dfn-shacl-node type" class="internalDFN">node type</a> of RDF IRI, a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> of 1, no <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a>.</li>
        </ol>
    		  <pre class="schema turtle"><span class="comment"># shapes (Turtle)</span>
<span class="function-name">my:UserShape</span> <span class="keyword">a</span> <span class="type">sh:</span><span class="constant">Shape</span> ;
    <span class="type">sh:</span><span class="constant">choice</span> [
        <span class="type">sh:</span><span class="constant">property</span> [
            <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">name</span> ;
            <span class="type">sh:</span><span class="constant">valueType</span> <span class="type">xsd:</span><span class="constant">string</span> ;
            <span class="type">sh:</span><span class="constant">minCount</span> 1 ; <span class="type">sh:</span><span class="constant">maxCount</span> 1
        ] ;
    
        <span class="type">sh:</span><span class="constant">property</span> [
            <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">givenName</span> ;
            <span class="type">sh:</span><span class="constant">valueType</span> <span class="type">xsd:</span><span class="constant">string</span> ;
            <span class="type">sh:</span><span class="constant">minCount</span> 1
        ] ;
    ] ;                                          
    <span class="type">sh:</span><span class="constant">property</span> [
        <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">mbox</span> ;
        <span class="type">sh:</span><span class="constant">nodeType</span> <span class="type">sh:</span><span class="constant">IRI</span> ;
        <span class="type">sh:</span><span class="constant">minCount</span> 1
    ] <span class="keyword">.</span></pre>
  </section>

    </section>

    <section id="associations">
    	<h2>Associating Data with Shapes</h2>
      <p>
        SHACL defines two predicates, <span class="type">sh:</span><span class="constant">nodeShape</span> and <span class="type">sh:</span><span class="constant">classShape</span>.
        The former asserts that a particular node in some graph conforms to a specific shape.
        The latter asserts that every node of some type conforms to a specific shape.
        It is expected that different communities will develop many more associations, much as the WSDL community created an association between input and output documents and an XML schema which described them.
      </p>

      <div class="issue">
        <p>
          The <span class="type">sh:</span><span class="constant">classShape</span> predicate describes a way to associate shapes with classes.
          It is currently unclear what is implied by attaching shape properties (e.g. <span class="type">sh:</span><span class="constant">property</span>) directly to a class e.g.:
        </p>
        <pre>
<span class="type">clinic1234:</span><span class="constant">CompletePatientRecord</span> <span class="keyword">a</span> <span class="type">owl:</span><span class="constant">Class</span> ;
  <span class="type">sh:</span><span class="constant">property</span> [
    <span class="type">sh:</span><span class="constant">predicate</span> <span class="type">clinic1234:</span><span class="constant">phone</span> ;
    <span class="type">sh:</span><span class="constant">valueType</span> <span class="type">xsd:</span><span class="constant">string</span> ;
    <span class="type">sh:</span><span class="constant">minCount</span> 1 ; <span class="type">sh:</span><span class="constant">maxCount</span> 1
  ] <span class="keyword">.</span></pre>

      </div>

      <div class="issue">
        <p>
          It's unclear whether an structure associating nodes returned from a SPARQL query would constitued a <a href="http://www.w3.org/2014/data-shapes/wiki/Requirements#Global_Constraints">global constraint</a>, e.g.
        </p>
        <pre>[ <span class="type">sd:</span><span class="constant">endpoint</span> <span class="function-name">&lt;http://www.example/sparql/&gt;</span> ;
  <span class="type">sd:</span><span class="constant">defaultDataset</span> [
    <span class="type">sd:</span><span class="constant">defaultGraph</span> [
      <span class="type">sd:</span><span class="constant">Graph</span> [
        <span class="type">sh:</span><span class="constant">query</span> """SELECT ?s { ... }""" ;
        <span class="type">sh:</span><span class="constant">hasShape</span> <span class="type">ex:</span><span class="constant">IssueShape</span>
      ] ] ] ] <span class="keyword">.</span></pre>
      </div>
    </section>

    <section id="evaluation">
      <h2>evaluation</h2>
<section>
<h2>Declarative
semantics of simple shape expression schemas</h2>
<p>Recall that a triple constraint is either a shape constraint
(<span class="textit">ShapeConstraint</span>), or a value
constraint (<span class="textit">ValueConstraint</span>). Remark
also that every value constraint, no matter its kind (value set, or
literal data type, or node type), defines a set of values; we call
them the <span class="textit">allowed</span> values of the
constraint. For instance, the allowed values of the literal data
type constraint <span class="textsf">int</span> are all the literal
integer values; the allowed values of the <span class=
"textsf">non-literal</span> value constraint are all IRI and all
blank nodes.</p>
<div><b>Definition <span class="arabic">1</span></b> &nbsp; [Triple
matches a triple constraint] <a name="def:matches" id=
"def:matches"></a>We say that a triple <span class="textit">(n, p,
u)</span> <span class="textit">matches</span> a triple constraint
<span class="textit">a::C</span> iff
<ul>
<li><span class="textit">a::C</span> is a value constraint, and
<span class="textit">p = a</span>, and <span class=
"textit">u</span> belongs to the set of allowed values for
<span class="textit">C</span>, or</li>
<li><span class="textit">a::C</span> is a shape constraint,
<span class="textit">u</span> in an IRI, and <span class="textit">p
= a</span>.</li>
</ul>
</div>
<div><b>Example <span class="arabic">2</span></b> &nbsp; Example of
matches.</div>
<div><b>Definition <span class="arabic">2</span></b> &nbsp; [Set of
triples satisfies a shape expression] <a name="def:satisfies" id=
"def:satisfies"></a> Let <span class="textit">Neigh</span> be a set
of triples, and let <span class="textit">Expr</span> be a shape
expression (as defined by <span class="textit">ShapeExpr</span>).
We say that <span class="textit">Neigh</span> <span class=
"textit">satisfies</span> <span class="textit">Expr</span> iff:
<ul>
<li><span class="textit">Expr</span> is the empty shape
<span class="textsf">empty</span> and <span class=
"textit">Neigh</span> is the empty set, or</li>
<li><span class="textit">Expr</span> is a triple constraint
<span class="textit">a::C</span>[m;M] (where m and M are the
minimal and the maximal cardinality, respectively), every triple in
<span class="textit">Neigh</span> matches <span class=
"textit">a::C</span>, and the number of elements of <span class=
"textit">Neigh</span> is in the bounds given by [m;M];</li>
<li><span class="textit">Expr</span> is a disjunctive shape, let
<span class="textit">Expr</span> = <span class="textit">Expr</span>
1 <span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> <span class=
"textit">Expr</span> 2 <span class="MATH"><img width="9" height=
"32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> ... <span class="MATH"><img width="9" height=
"32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class="textit">Expr</span> k, and
<span class="textit">Neigh</span> satisfies <span class=
"textit">Expr</span> 1, or <span class="textit">Neigh</span>
satisfies <span class="textit">Expr</span> 2, ... or <span class=
"textit">Neigh</span> satisfies <span class="textit">Expr</span>
k;</li>
<li><span class="textit">Expr</span> is a grouping, let
<span class="textit">Expr</span> = <span class="textit">Expr</span>
1, ... , <span class="textit">Expr</span> k, and <span class=
"textit">Neigh</span> can be split into k disjoint sets of triples
<span class="textit">Neigh</span> = <span class=
"textit">Neigh</span> 1 <span class="MATH"><img width="15" height=
"14" align="bottom" border="0" src="img1.png" alt=
"$ \cup$" /></span> ... <span class="MATH"><img width="15" height=
"14" align="bottom" border="0" src="img1.png" alt=
"$ \cup$" /></span> <span class="textit">Neigh</span> k s.t.
<span class="textit">Neigh</span> i satisfies <span class=
"textit">Expr</span> i for all i in 1..k.</li>
</ul>
</div>
<p>Note that for disjunctive shapes, satisfying one or the other of
the <span class="textit">Expr</span> i is not exclusive (similarly
to logical disjunction).</p>
<p>The above definition can be written using the following set of
inference rules. We denote <span class="textit">Neigh</span>
<span class="MATH"><img width="14" height="14" align="bottom"
border="0" src="img4.png" alt="$ \vdash$" /></span> <span class=
"textit">Expr</span> the fact that <span class=
"textit">Neigh</span> satisfies <span class=
"textit">Expr</span>.</p>
<p><img src="html-handmade-images/rule-empty.png" /><br />
<img src=
"html-handmade-images/rule-triple-constraint.png" /><br />
<img src="html-handmade-images/rule-disj.png" /><br />
<img src="html-handmade-images/rule-group.png" /><br /></p>
<p>If a set of triples <span class="textit">Neigh</span> satisfies
a shape expression <span class="textit">Expr</span>, then one can
construct (at least one) proof tree which root is <span class=
"textit">Neigh</span> <span class="MATH"><img width="14" height=
"14" align="bottom" border="0" src="img4.png" alt=
"$ \vdash$" /></span> <span class="textit">Expr</span>, using the
above induction rules. Given such proof tree, it can be shown that
every triple <span class="textit">(n, p, u)</span> in <span class=
"textit">Neigh</span> appears in the conclusion of exactly one
application of rule-empty. For every triple <span class=
"textit">(n, p, u)</span> in <span class="textit">Neigh</span>, let
<span class="textit">wm((n, p, u))</span> be the triple constraint
<span class="textit">p::C</span> that appears in the conclusion of
the same rule application as <span class="textit">(n, p, u)</span>.
We call <span class="textit">wm</span> a <span class=
"textit">witness mapping</span> (for the fact that <span class=
"textit">Neigh</span> satisfies <span class="textit">Expr</span>).
Note that every proof tree defines a unique witness mapping.</p>
<p>For an RDF graph <span class="textit">G</span> and a node
<span class="textit">n</span> in <span class="textit">G</span>, the
<span class="textit">out-going neighbourhood</span> of <span class=
"textit">n</span> in <span class="textit">G</span> is the set of
triples <span class="textit">(n, p, u)</span> that belong to the
graph <span class="textit">G</span>. This set is denoted
<span class="textit">out</span>(G,n). For a shape expression
<span class="textit">Expr</span>, denote <span class=
"textit">properties</span>(<span class="textit">Expr</span>) the
set of properties that appear in some triple constraint in
<span class="textit">Expr</span>. For a schema <span class=
"textit">S</span> and a shape label <span class="textit">T</span>
that appears in <span class="textit">S</span>, denote <span class=
"textit">expr</span>(T, S) the shape expression that defines the
shape <span class="textit">T</span> in the schema <span class=
"textit">S</span>, and denote <span class="textit">incl</span>(T,
S) the set of included properties associated with the definition of
the shape <span class="textit">T</span> in <span class=
"textit">S</span>. Note that if <span class="textit">T</span> is a
closed shape, then <span class="textit">incl</span>(T, S) is
empty.</p>
<div><b>Definition <span class="arabic">3</span></b> &nbsp;
[Typing, Valid typing] <a name="def:valid-typing" id=
"def:valid-typing"></a>A <span class="textit">typing</span> of a
graph <span class="textit">G</span> is a map that associates a
(possibly empty) set of shape labels with every node of
<span class="textit">G</span>.
<p>For a shape expression schema <span class="textit">S</span> and
a graph <span class="textit">G</span>, a typing <span class=
"textit">t</span> is called <span class="textit">valid
typing</span> of <span class="textit">G</span> by <span class=
"textit">S</span> if for every node <span class="textit">n</span>
in <span class="textit">G</span> and every shape label <span class=
"textit">T</span> in <span class="textit">t(n)</span>, there exist
three mutually disjoint sets <span class="textit">Matched</span>,
<span class="textit">OpenProp</span>, <span class=
"textit">Rest</span> such that</p>
<ol>
<li><a name="enum:1" id="enum:1"></a> <span class=
"textit">out</span>(G,n) = <span class="textit">Matched</span>
<span class="MATH"><img width="15" height="14" align="bottom"
border="0" src="img1.png" alt="$ \cup$" /></span> <span class=
"textit">OpenProp</span> <span class="MATH"><img width="15" height=
"14" align="bottom" border="0" src="img1.png" alt=
"$ \cup$" /></span> <span class="textit">Rest</span>, and</li>
<li><a name="enum:2" id="enum:2"></a> <span class=
"textit">Rest</span> = {<span class="textit">(n, p, u)</span>
<span class="MATH"><img width="15" height="30" align="middle"
border="0" src="img5.png" alt="$ \in$" /></span> <span class=
"textit">out</span>(G,n) <span class="MATH"><img width="9" height=
"32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class="textit">p</span> <span class=
"MATH"><img width="15" height="30" align="middle" border="0" src=
"img6.png" alt="$ \not\in$" /></span> <span class=
"textit">properties</span>(<span class="textit">expr</span>(T,
S))}, and</li>
<li><a name="enum:3" id="enum:3"></a> <span class=
"textit">Matched</span> = {<span class="textit">(n, p, u)</span>
<span class="MATH"><img width="15" height="30" align="middle"
border="0" src="img5.png" alt="$ \in$" /></span> <span class=
"textit">out</span>(G,n) <span class="MATH"><img width="9" height=
"32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class="textit">(n, p, u)</span> matches
<span class="textit">a::C</span> for some triple constraint
<span class="textit">a::C</span> that appears in <span class=
"textit">expr</span>(T, S)}, and</li>
<li><a name="enum:valid-typing-shape-constr-condition" id=
"enum:valid-typing-shape-constr-condition"></a> there exists a
proof tree with corresponding witness mapping <span class=
"textit">wm</span> for the fact that <span class=
"textit">Matched</span> satisfies <span class=
"textit">expr</span>(T, S) s.t., for all shape triple constraint
<span class="textit">a::C</span> that occurs in <span class=
"textit">expr</span>(T, S), and for all triple <span class=
"textit">(n, p, u)</span> with <span class="textit">wm((n, p,
u))</span> = <span class="textit">a::C</span>, we have <span class=
"textit">C</span> <span class="MATH"><img width="15" height="30"
align="middle" border="0" src="img5.png" alt="$ \in$" /></span>
<span class="textit">t(u)</span>, and</li>
<li><a name="enum:4" id="enum:4"></a> for all triple <span class=
"textit">(n, p, u)</span> in <span class="textit">OpenProp</span>,
we have <span class="textit">p</span> <span class=
"MATH"><img width="15" height="30" align="middle" border="0" src=
"img5.png" alt="$ \in$" /></span> <span class=
"textit">incl</span>(T, S), and</li>
<li><a name="enum:5" id="enum:5"></a> if <span class=
"textit">T</span> is a closed shape, then <span class=
"textit">Rest</span> = <span class="MATH"><img width="12" height=
"32" align="middle" border="0" src="img7.png" alt=
"$ \emptyset$" /></span>.</li>
</ol>
</div>
<p>In the above definition, intuitively,</p>
<ol>
<li><span class="textit">out</span>(G, n) can be decomposed in
three disjoint sets <span class="textit">Matched</span>,
<span class="textit">OpenProp</span>, <span class=
"textit">Rest</span> s.t.</li>
<li><span class="textit">Rest</span> contains exactly the triples
which property is not mentioned in <span class=
"textit">expr</span>(T, S), and</li>
<li><span class="textit">Matched</span> contains exactly the
triples that match some of the triple constraints that appear in
<span class="textit">expr</span>(T, S). Moreover</li>
<li><span class="textit">Matched</span> needs to satisfy
<span class="textit">expr</span>(T, S), and to propagate the shape
constraints: whenever a triple <span class="textit">(n, p,
u)</span> is a witness for the shape constraint <span class=
"textit">a::C</span>, the required shape <span class=
"textit">C</span> is indeed associated to its object node
<span class="textit">u</span> by the valid typing <span class=
"textit">t</span>. Additionally,</li>
<li>the triples which properties appear in <span class=
"textit">expr</span>(T, S), but did not match any of the triple
constraints from <span class="textit">expr</span>(T, S), must have
their property among the allowed extra properties. Finally,</li>
<li>for closed shapes, non extra triples than those used for
satisfying <span class="textit">expr</span>(T, S) are allowed.
Remark that, for closed shapes, <span class="textit">incl</span>(T,
S) is empty, therefore <span class="textit">OpenProp</span> is also
empty.</li>
</ol>
For a node <span class="textit">n</span> in a graph <span class=
"textit">G</span> and a schema <span class="textit">S</span>, we
say that <span class="textit">n</span> <span class=
"textit">satisfies shape</span> <span class="textit">T</span> from
<span class="textit">S</span> if there exists a valid typing
<span class="textit">t</span> of for graph <span class=
"textit">G</span> by <span class="textit">S</span> s.t.
<span class="textit">T</span> is in <span class=
"textit">t(n)</span>.
</section>
<section>
<h2>Complex shape constraints</h2>
<p><a name="sec:shex-full" id="sec:shex-full"></a></p>
<p>In the previous sections we considered that a shape constraint
is simply a shape label, indicating the required shape for a node.
In what follows, we introduce more complex shape constraints as
conjunctions and disjunctions of required shapes, as defined by the
following abstract syntax.</p>
<p><br />
<span class="textit">ShapeConstraint</span>::= <span class=
"textit">DisjShapeConstraint</span> <span class="MATH"><img width=
"9" height="32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class=
"textit">ConjShapeConstraint</span><br />
<span class="textit">DisjShapeConstraint</span>::= <span class=
"textit">ShapeLabel</span> (<span class="textsf">or</span>
<span class="textit">ShapeLabel</span>)*<br />
<span class="textit">ConjShapeConstraint</span>::= <span class=
"textit">ShapeLabel</span> (<span class="textsf">and</span>
<span class="textit">ShapeLabel</span>)*</p>
<p>Extending the semantics to this new construct requires only a
slight modification of valid typing, namely the
condition&nbsp;<a href=
"#enum:valid-typing-shape-constr-condition">1</a>. from
Definition&nbsp;<a href="#def:valid-typing">3</a> is to be replaced
by the following.</p>
<div><b>Definition <span class="arabic">4</span></b> &nbsp; [Valid
typing, amends the condition&nbsp;<a href=
"#enum:valid-typing-shape-constr-condition">4</a> from
Definition&nbsp;<a href="#def:valid-typing">3</a>]&nbsp;<br />
<a name="def:valid-typing-full" id="def:valid-typing-full"></a>
<ol>
<li><a name="enum:valid-typing-shape-constr-condition" id=
"enum:valid-typing-shape-constr-condition"></a> there exists a
proof tree with corresponding witness mapping <span class=
"textit">wm</span> for the fact that <span class=
"textit">Matched</span> satisfies <span class=
"textit">expr</span>(T, S) s.t., for all shape triple constraint
<span class="textit">a::C</span> that occurs in <span class=
"textit">expr</span>(T, S), and for all triple <span class=
"textit">(n, p, u)</span> with <span class="textit">wm((n, p,
u))</span> = <span class="textit">a::C</span>, we have
<ul>
<li>if <span class="textit">a::C</span> is a disjunctive shape
constraint, say <span class="textit">C = T1 <span class=
"textsf">or</span> ...<span class="textsf">or</span> Tk</span>,
then <span class="textit">T</span>i belongs to <span class=
"textit">t(u)</span> for some <span class="textit">T</span>i among
<span class="textit">T1, ...Tk</span>, and</li>
<li>if <span class="textit">a::C</span> is a conjunctive shape
constraint, say <span class="textit">C = T1 <span class=
"textsf">and</span> ...<span class="textsf">and</span> Tk</span>,
then {T1, ..., Tk} <span class="MATH"><img width="17" height="30"
align="middle" border="0" src="img8.png" alt=
"$ \subseteq$" /></span> <span class="textit">t(u)</span>, that is,
all the required types belong to <span class=
"textit">t(u)</span>.</li>
</ul>
</li>
</ol>
</div>
</section>
<section>
  <h2>Adding a one-of constraint</h2>
<section>
<h3> Syntax</h3>
<p>We add the one-of operator to the abstract syntax by the
following.</p>
<p><br />
<span class="textit">ShapeExpr</span>::= <span class=
"textit">EmptyShape</span><br />
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> (<span class=
"textit">TripleConstraint</span> <span class="MATH"><img width="9"
height="32" align="middle" border="0" src="img3.png" alt=
"$ \mid$" /></span> <span class=
"textit">InverseTripleConstraint</span>) <span class=
"textit">Cardinality</span><br />
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> <span class=
"textit">DisjunctiveShape</span><br />
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> <span class=
"textit">GroupShape</span><br />
<span class="MATH"><img width="9" height="32" align="middle"
border="0" src="img3.png" alt="$ \mid$" /></span> <span class=
"textit">OneOfShape</span><br />
<span class="textit">OneOfShape</span>::= <span class=
"textit">ShapeExpr</span> ('<span class="MATH"><img width="17"
height="30" align="middle" border="0" src="img9.png" alt=
"$ \odot$" /></span>' <span class=
"textit">ShapeExpr</span>)*<br /></p>
<p>We impose a syntactic restriction to the use of the one-of
operator, which is that all types that appear in the
sub-expressions of <span class="textit">OneOfShape</span> are non
recursive. Formally, for a schema <span class="textit">S</span>,
the <span class="textit">shapes dependency graph</span> of
<span class="textit">S</span> is the directed graph which nodes are
the shape labels that occur in <span class="textit">S</span>, and
that has an edge from <span class="textit">T1</span> to
<span class="textit">T2</span> iff the shape name <span class=
"textit">T2</span> appears in the shape definition for <span class=
"textit">T1</span> in <span class="textit">S</span> (that is, there
is a triple shape constraint <span class="textit">a::C</span> in
<span class="textit">expr</span>(T1, S) s.t. <span class=
"textit">T2</span> is one of the types in <span class=
"textit">C</span>). We denote <span class=
"textit">depgraph</span>(S) the dependency graph of <span class=
"textit">S</span>. Moreover, for a shape label <span class=
"textit">T</span> in <span class="textit">S</span>, let
<span class="textit">depgraph</span>(S, T) be the sub-graph of
<span class="textit">depgraph</span>(S) induced by the set of nodes
<span class="textit">T2</span> that are reachable from <span class=
"textit">T</span> in <span class="textit">depgraph</span>(S); here
by reachable we mean standard reachability in graphs.</p>
<p>Given a schema <span class="textit">S</span> and a shape label
<span class="textit">T</span> in <span class="textit">S</span>, we
say that <span class="textit">T</span> is <span class=
"textit">recursion free</span> in <span class="textit">S</span> iff
<span class="textit">depgraph</span>(S, T) is a directed acyclic
graph.</p>
<p>We now impose the following syntactic restriction on schemas
<span class="textit">S</span> using the one-of operator.</p>
<blockquote>For all one-of sub-expression <span class=
"textit">Expr</span> 1 <span class="MATH"><img width="17" height=
"30" align="middle" border="0" src="img9.png" alt=
"$ \odot$" /></span> ...<span class="MATH"><img width="17" height=
"30" align="middle" border="0" src="img9.png" alt=
"$ \odot$" /></span> <span class="textit">Expr</span> k that
appears in some shape definition in <span class="textit">S</span>,
and for all shape label <span class="textit">T</span> that appears
in some of the <span class="textit">Expr</span> 1, ...,
<span class="textit">Expr</span> k, the type <span class=
"textit">T</span> is recursion free in <span class=
"textit">S</span>.</blockquote>
Schemas that do not satisfy this syntactic restriction are
considered invalid schemas. Remark also that it can be tested in
linear time in the size of the representation of the schema whether
a schema enjoys this syntactic restriction.
</section>
<section>
<h3>Semantics</h3>
<p>For defining the semantics of the one-of operator, we amend
Definition&nbsp;<a href="#def:satisfies">2</a> and
Definition&nbsp;<a href="#def:valid-typing-full">4</a> in the
following way.</p>
<div><b>Definition <span class="arabic">5</span></b> &nbsp; [Set of
triples satisfies a shape expression, amends
Definition&nbsp;<a href="#def:satisfies">2</a>]&nbsp;<br />
<ul>
<li><span class="textit">Expr</span> is a one-of shape, let
<span class="textit">Expr</span> = <span class="textit">Expr</span>
4 <span class="MATH"><img width="17" height="30" align="middle"
border="0" src="img9.png" alt="$ \odot$" /></span> <span class=
"textit">Expr</span> 2 <span class="MATH"><img width="17" height=
"30" align="middle" border="0" src="img9.png" alt=
"$ \odot$" /></span> ...<span class="MATH"><img width="17" height=
"30" align="middle" border="0" src="img9.png" alt=
"$ \odot$" /></span> <span class="textit">Expr</span> k, and
<span class="textit">Neigh</span> satisfies <span class=
"textit">Expr</span> 1, or <span class="textit">Neigh</span>
satisfies <span class="textit">Expr</span> 2, ... or <span class=
"textit">Neigh</span> satisfies <span class="textit">Expr</span>
k;</li>
</ul>
</div>
The corresponding inference rule is
<p><img src="html-handmade-images/rule-choice.png" /></p>
<p><br />
We now introduce a notation. Consider a schema <span class=
"textit">S</span> and a proof tree for some <span class=
"textit">Neigh</span> <span class="MATH"><img width="14" height=
"14" align="bottom" border="0" src="img4.png" alt=
"$ \vdash$" /></span> <span class="textit">Expr</span>, where
<span class="textit">Neigh</span> is a set of triples and
<span class="textit">Expr</span> is a shape definition in
<span class="textit">S</span>. Given a node <span class=
"textit">r</span> in that proof tree that corresponds to an
application of rule-choice, let <span class="textit">Expr</span> ri
be the choice sub-expression used in the proof in node <span class=
"textit">r</span> (that is, node <span class="textit">r</span> has
the shape of rule-choice above, and <span class=
"textit">Expr</span> ri is the <span class="textit">Expr</span> i
in the premise of <span class="textit">r</span> in the proof tree).
We denote <span class="textit">Sri</span> the schema obtained from
<span class="textit">S</span> by removing the sub-expression
<span class="textit">Expr</span> ri from <span class=
"textit">S</span>.</p>
<div><b>Definition <span class="arabic">6</span></b> &nbsp; [Valid
typing, amends Definition&nbsp;<a href=
"#def:valid-typing-full">4</a>]&nbsp;<br />
<ol>
<li><small class="FOOTNOTESIZE"><a name=
"enum:valid-typing-shape-constr-condition" id=
"enum:valid-typing-shape-constr-condition"></a> there exists a
proof tree with corresponding witness mapping</small> <span class=
"textit"><small class="FOOTNOTESIZE">wm</small></span><small class=
"FOOTNOTESIZE">for the fact that <span class=
"textit">Matched</span> satisfies <span class=
"textit">expr</span>(T, S) s.t., for all shape triple
constraint</small> <span class="textit"><small class=
"FOOTNOTESIZE">a::C</small></span> <small class="FOOTNOTESIZE">that
occurs in <span class="textit">expr</span>(T, S), and for all
triple</small> <span class="textit"><small class="FOOTNOTESIZE">(n,
p, u)</small></span> <small class="FOOTNOTESIZE">with</small>
<span class="textit"><small class="FOOTNOTESIZE">wm((n, p,
u))</small></span><small class="FOOTNOTESIZE">=</small>
<span class="textit"><small class=
"FOOTNOTESIZE">a::C</small></span><small class="FOOTNOTESIZE">, we
have</small>
<ul>
<li><small class="FOOTNOTESIZE">if</small> <span class=
"textit"><small class="FOOTNOTESIZE">a::C</small></span>
<small class="FOOTNOTESIZE">is a disjunctive shape constraint,
say</small> <span class="textit"><small class="FOOTNOTESIZE">C = T1
<span class="textsf">or</span> ...<span class="textsf">or</span>
Tk</small></span><small class="FOOTNOTESIZE">, then</small>
<span class="textit"><small class=
"FOOTNOTESIZE">T</small></span><small class="FOOTNOTESIZE">i
belongs to</small> <span class="textit"><small class=
"FOOTNOTESIZE">t(u)</small></span> <small class="FOOTNOTESIZE">for
some</small> <span class="textit"><small class=
"FOOTNOTESIZE">T</small></span><small class="FOOTNOTESIZE">i
among</small> <span class="textit"><small class="FOOTNOTESIZE">T1,
...Tk</small></span><small class="FOOTNOTESIZE">, and</small></li>
<li><small class="FOOTNOTESIZE">if</small> <span class=
"textit"><small class="FOOTNOTESIZE">a::C</small></span>
<small class="FOOTNOTESIZE">is a conjunctive shape constraint,
say</small> <span class="textit"><small class="FOOTNOTESIZE">C = T1
<span class="textsf">and</span> ...<span class="textsf">and</span>
Tk</small></span><small class="FOOTNOTESIZE">, then {T1, ..., Tk}
<span class="MATH"><img width="17" height="30" align="middle"
border="0" src="img8.png" alt="$ \subseteq$" /></span></small>
<span class="textit"><small class=
"FOOTNOTESIZE">t(u)</small></span><small class="FOOTNOTESIZE">,
that is, all the required types belong to</small> <span class=
"textit"><small class=
"FOOTNOTESIZE">t(u)</small></span><small class=
"FOOTNOTESIZE">,</small><br />
and moreover</li>
<li>for all node <span class="textit">r</span> of the proof tree
that correspons to an application of rule-choice, there does not
exist a valid typing of <span class="textit">G</span> by
<span class="textit">Sri</span>.</li>
</ul>
</li>
</ol>
</div>
The newly added condition basically means that for all graph
<span class="textit">G</span>, for all node <span class=
"textit">n</span> in <span class="textit">G</span>, for all schema
<span class="textit">S</span>, and for all shape label <span class=
"textit">T</span> in <span class="textit">S</span>, all valid
typings <span class="textit">t</span> of <span class=
"textit">G</span> by <span class="textit">S</span> such that
<span class="textit">T</span> <span class="MATH"><img width="15"
height="30" align="middle" border="0" src="img5.png" alt=
"$ \in$" /></span> <span class="textit">t(n)</span> agree on the
one-of sub-expression <span class="textit">Expr</span> i in
<span class="textit">expr</span>(T, S) used for witnessing that
<span class="textit">out</span>(G, n) satisfies <span class=
"textit">expr</span>(T, S), for all one-of expression <span class=
"textit">Expr</span> 1 <span class="MATH"><img width="17" height=
"30" align="middle" border="0" src="img9.png" alt=
"$ \odot$" /></span> ...<span class="MATH"><img width="17" height=
"30" align="middle" border="0" src="img9.png" alt=
"$ \odot$" /></span> <span class="textit">Expr</span> k in
<span class="textit">expr</span>(T, S).
<p>This apparently very strong requirement is easy to check.
Indeed, even though the definition requires for all valid typings
to agree, we do not need to check all the valid typings. Because of
the non recursiveness restriction for schemas, it is sufficient to
check a small number of possible typings and conclude whether the
property holds for all valid typings.</p>
</section>
</section>
</section>

<!--
    <section id="matching">
      <h2>Matching</h2>
      <p>
        This section defines the semantics of <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shapes</a> as a test to see if a <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> in an RDF graph fulfills the shapes constraints.
        Section 6 <a href="assoc">Associating Nodes with Shapes</a> defines facilities for associating a <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> with a <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a>.
      </p>
      <div class="defn">
        <dfn id="dfn-shacl-triple-constraint-matches">triple constraint matches</dfn>
        <p>
          Evaluating a <a title="SHACL constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraint</a> against a <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> produces a boolean value.
          Evaluation of each form of constraint is defined in <a href="#eval-triple-constraints">6.1 Triple Constraint Evaluation</a>.
        </p>
      </div>
      <div class="defn">
        <dfn id="dfn-shacl-shape-matches">shape matches</dfn>
        <p>
          If the <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a> has no <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraint</a>, the result is true.
          Otherwise, evaluation produces the result is the result of evaluating <a title="triple constraint matches" href="#dfn-shacl-triple-constraint-matches">triple constraint matches</a> on the <a title="constraint" href="#dfn-shacl-triple-constraint" class="internalDFN">triple constraint</a> with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a>.
        </p>
        <p>
          The set of failing triples for a shape is the set of failing triples for each constraint minus the passing triples for each constraint.
          A <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> <dfn id="dfn-shacl-matches">matches</dfn> a <a title="SHACL shape" href="#dfn-shacl-shape" class="internalDFN">shape</a> if there are no remaining failing triples.
          The result is a boolean value.
        </p>
      </div>
      <section id="eval-triple-constraints">
        <h3>Triple Constraint Evaluation</h3>

        <div class="defn">
          <dfn id="dfn-shacl-property-constraint-matches">triple constraint matches</dfn>
          <p>
            The <dfn id="dfn-shacl-matching-triples">matching triples</dfn> is the set of triples in the graph with the subject node of the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> and a predicate of the <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint's</a> predicate.
            Evaluation of a triple constraint produces true if each of the following is true:
          </p>
          <ul>
            <li>If the triple constraint has a <a title="SHACL minimum cardinality" href="#dfn-shacl-min-card" class="internalDFN">minimum cardinality</a> greather than 0, the <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> number at least that minimum cardinality.</li>
            <li>If the triple constraint has a <a title="SHACL maximum cardinality" href="#dfn-shacl-max-card" class="internalDFN">maximum cardinality</a> greather than 0, the <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> number no more than that maximum cardinality.</li>
            <li>If there is a <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">term constraint</a> present, for each object in <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a>, that object matches (see <a href="#eval-term-constraints">6.2 Term Constraint Evaluation</a>)</li>
          </ul>
        </div>

        <div class="defn">
          <dfn id="dfn-shacl-inverse-property-constraint-matches">inverse triple constraint matches</dfn>
          <p>
            The <a title="shacl matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> is the set of triples in the graph with the subject node of the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> and a predicate of the <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraint's</a> predicate.
          </p>
        </div>

        <div class="defn">
          <dfn id="dfn-shacl-and-constraint-matches">group shape matches</dfn>
          <p>
            Evaluation of an <a title="group shape" href="#dfn-shacl-and-constraint" class="internalDFN">group shape</a> produces true if evaluation of each of the <a title="SHACL conjunct" href="#dfn-shacl-conjunct" class="internalDFN">conjuncts</a> with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> produces true.
          </p>
        </div>

        <div class="defn">
          <dfn id="dfn-shacl-or-constraint-matches">disjunctive shape matches</dfn>
          <p>
            Evaluation of an <a title="disjunctive shape" href="#dfn-shacl-or-constraint" class="internalDFN">disjunctive shape</a> produces true if evaluation of any of the constituent constraints with the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> produces true.
          </p>
        </div>
      </section>

      <section id="eval-term-constraints">
        <h3>Term Constraint Evaluation</h3>

        <p>
          <a title="SHACL term constraint" href="#dfn-shacl-term-constraint" class="internalDFN">Term constraints</a> are tested against the objects of <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> in <a title="SHACL triple constraint" href="#dfn-shacl-property-constraint" class="internalDFN">triple constraints</a> and the subjects of <a title="SHACL matching triples" href="#dfn-shacl-matching-triples" class="internalDFN">matching triples</a> in <a title="SHACL triple constraint" href="#dfn-shacl-inverse-property-constraint" class="internalDFN">inverse triple constraints</a>.
        </p>

        <div class="defn">
          <dfn id="dfn-node-type-matches">node type matches</dfn>
          <p>
            Evaluation of a <a title="SHACL node type" href="#dfn-shacl-node-type" class="internalDFN">node type</a> produces true if the evaluated term is of the same RDF Node type (<a title="RDF IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri" class="externalDFN">IRI</a>, <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a>, or <a title="RDF Blank Node" href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node" class="externalDFN">Blank Node</a>).
          </p>
        </div>

				<div class="defn">
          <dfn id="dfn-shacl-datatype-matches">datatype matches</dfn>
          <p>
            Evaluation of a <a title="SHACL datatype" href="#dfn-shacl-datatype" class="internalDFN">datatype</a> produces true if the evaluated term is an <a title="RDF Literal" href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal" class="externalDFN">RDF literal</a> with the same <a title="datatype IRI" href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri" class="externalDFN">datatype IRI</a>.
          </p>
        </div>

				<div class="defn">
          <dfn id="dfn-shacl-value-set-matches">value set matches</dfn>
          <p>
            Evaluation of a <a title="SHACL value set" href="#dfn-shacl-value-set" class="internalDFN">value set</a> produces true if the evaluated term is a member of the set of <a title="shacl allowed values" href="#dfn-shacl-allowed-value" class="internalDFN">allowed values</a>.
          </p>
        </div>

				<div class="defn">
          <dfn id="dfn-shacl-value-shape-matches">value shape matches</dfn>
          <p>
            Evaluation of a <a title="SHACL value shape" href="#dfn-shacl-value-shape" class="internalDFN">value shape</a> is the result of evaluating <a title="SHACL shape matches" href="#dfn-shacl-shape-matches" class="internalDFN">shape matches</a> where the <a title="SHACL focus node" href="#dfn-shacl-focus-node" class="internalDFN">focus node</a> is the evaluated term.
          </p>
        </div>

      </section>
    </section>
-->

    <!-- section>
      <h2>notes</h2>
      <p>
Adding examples...<br/>
<br/>
<b># empty</b><br/>
<br/>
empty: no constraint.<br/>
<br/>
Example:<br/>
<br/>
<br/>
Note:If we are using open shapes, it will match any node without constraint.<br/>
<br/>
(Maybe, the following comment can be omitted:<br/>
In case of closed shapes it would match a node without any incoming or outgoing edges.<br/>
)<br/>
<br/>
<br/>
<b># arc</b><br/>
<br/>
arc predicate value cardinality: match an arc in the graph with some cardinality.<br/>
<br/>
Two possibilities: unbounded cardinality and bounded cardinality<br/>
<br/>
## arc with unbounded cardinality<br/>
<br/>
arc predicate value {m, unbounded}: it will match a node that has at least m outgoing arcs and whose objects match with the value.<br/>
<br/>
In the axiomatic semantics, I look for m outgoing arcs that match the predicate and value...and return the remaining triples...I think I should reject if there are remaining triples that match the predicate but have values that don't match...
      </p>

<div class="issue">
<h3>Issue (RemainingTriples)</h3>
<p>
It is not clear what is the best semantics when there are remaining triples with the same predicate that don't match the object. Eric's proposal is to fail in that case. Which would mean that the semantics needs to consider that there are no remaining triples with the same predicate and a value that doesn't match. Current axiomatic semantics doesn't fail in that case as it considers those triples "remaining" triples...it would fail if we are using closed shapes.
</p>
<h4>Example:</h4>
<pre>
     schema   -&gt; &lt;shape&gt; { :shoeSize &lt;xsd:integer {1,1} }
     data  -&gt;       &lt;x&gt; :shoeSize "hi" . (should fail because the value doesn't match xsd:integer...
</pre>
<p>
[[<b>Eric</b>...Could you exlain here what you said about missing/failure in natural language...I know you said me in the Skype, but I would like to read it to have a more clear understanding on how you do it...so I could model that with the axiomatic semantics...]
</p>
</div>

<h3>arc with bounded cardinality</h3>
<p>
arc predicate value {m,n}: it will match a node that has between m and n outgoing arcs and whose objects match with the value.
</p>

<div class="issue">
<h3>Issue (remaining triples)</h3>
<p>
It has to review that there are no remaining triples that contain the predicate...
</p>
</div>

<h3>inverse arcs</h3>
<p>
There are also two possibilities: bounded and unbounded cardinality.
The semantics is mostly the same as "arc" but it matches the subjects instead ot the objects.
</p>
<h4>inverse arc with unbounded cardinality</h4>

<p>
inverseArc predicate value {m,unbounded}<br/>
<br/>
## inverse arc with bounded cardinality<br/>
<br/>
inverseArc predicate value {m,unbounded}<br/>
<br/>
# And, conjunction (or interleave)<br/>
<br/>
and(E1,...En): it matches if there are triples that match with E1 and there are triples that match with E2.
</p>

<div class="note">
<h4>Note</h4>
<p>
With this semantics, the same triple can be used to match parts of E1 and of E2.
</p>
<h4>Example:</h4>
<pre>
    schema: &lt;x&gt; { :a xsd:integer, :a . }
    data: &lt;x&gt; :a 1
</pre>
<p>
This example may look non-intuitive because it looks as if it would mean that the shape has two arcs, one with an integer and another with any value, but if there is a single arc with an integer which passes both conjunctions, it also pass.
</p>
</div>

<div class="issue">
<h3>Issue (Multioccurrence)</h3>
<p>
There is an issue when the same predicate occurs in the conjunction. For example:
</p>

<pre>
schema: &lt;x&gt; { :bioParent { :gender ("F") } {1,1} , :bioParent { :gender ("M") }&nbsp; {1,1} }
data: &lt;x&gt; :bioParent [ :gender "F" ] ; :bioParent [ :gender "M" ] .&nbsp; =&gt; Fail
data: &lt;x&gt; :bioParent [ :gender "F" ] ; :bioParent [ :gender "M" ] ; :bioParent [ :gender "Q" ] . =&gt; Fail
data: &lt;x&gt; :bioParent [ :gender "F" ] ; :bioParent [ :gender "M" ] ; :xxx [ :gender "Q" ] . =&gt; Fail should pass because open shapes...extra triples
</pre>

<p>
This issue depends on the "RemainingTriples" issue and the solution to that issue would solve this one.
</p>
</div>

<h3>Or, disjunction</h3>

<p>
or(E1...En): matches if the triples match any of E1...En shapes.<br/>
</p>

<h2>Extended features change that to "Issues"</h2>

<h3>Not</h3>
<p>
not(Shape): Matches if the triples don't match the Shape.
</p>

<div class="issue">
<h3>Issue (NegationShapes)</h3>
<p>
Negation of whole shapes can be difficult to handle when it is combined with recursive shapes.
</p>
<p class="todo">
Explain better and give some example...
</p>
<p>
We may define a simpler definition of negation which only negates arcs and not whole shapes.
</p>
</div>

<h3>noArc(Predicate,Value)</h3>
<p>
matches if there are no outgoing arc with that predicate and an object that matches that Value
</p>

<h3>noInverseArc(Predicate,Value)</h3>
<p>
matches if there are no incoming arc with that predicate and a subject that matches that value.
</p>

<h3>oneOf</h3>
<p>
oneOf(E1,E2) - matches if the triples match with E1 or they match with E2 but not with both.
</p>

<div class="issue">
<h3>Issue (Exclusive-or)</h3>
<p>
Exclusive Or seems to be more intuitive from use cases...for example, "a person has either full name or first name and given name, but not both. The main problem is that it needs negation.
</p>
</div>
<h3>Closed Shapes</h3>

<p>
close(E): matches if the triples match with node E and there are no remaining triples.
</p>

<h3>Issue</h3>
<p>
Maybe include also the notion of closed Schema
</p>
<h3>Cardinality on groups</h3>
<p>
group(E,cardinality): matches if the triples match with Shape E the number of times expressed by the cardinality
</p>

<h3>Extensibility mechanism</h3>

<p>
Extension(Language Code): matches if there is an external processor for language "Language" that process "Code" and returns true.
</p>

    </section -->

  </body>
</html>

