<!DOCTYPE html>
<html>
    <head>
        <META http-equiv="Content-Type" content="text/html; charset=utf-8">
        <link href="lib/shacl/css/shacldoc.css" rel="stylesheet" type="text/css">
        <script async="async" class="remove" src="//www.w3.org/Tools/respec/respec-w3c-common"></script>
    </head>
    <body>
        <script>document.title = "SHACL Vocabulary Reference";</script><script class="remove">var respecConfig = {"edDraftURI":"http:\/\/w3c.github.io\/data-shapes\/shacl-ref\/","specStatus":"WD","shortName":"shacl-ref","editors":[{"name":"Holger Knublauch","url":"http:\/\/knublauch.com","company":"TopQuadrant, Inc.","companyURL":"http:\/\/topquadrant.com","mailto":"holger@topquadrant.com"}],"wg":"RDF Data Shapes Working Group","wg":"https:\/\/www.w3.org\/2014\/data-shapes\/wiki\/Main_Page","wg":"public-data-shapes","wgPatentURI":"http:\/\/www.w3.org\/2004\/01\/pp-impl\/73865\/status"}</script>
        <section id="sotd"></section>
        <section id="abstract">
            <p>This document provides a formal definition of the classes and shapes from
			the SHACL Vocabulary.
			The document has been automatically generated from the vocabulary&nbsp;<a href="http://www.w3.org/ns/shacl">http://www.w3.org/ns/shacl</a>.
		</p>
        </section>
        <section>
            <h2>Classes</h2>
            <section>
                <h3>Shape Classes</h3>
                <section>
                    <h3>sh:Shape</h3>
                    <p class="shacldoc-comment">The class of shapes.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:scopeClass</td><td>rdfs:Class</td><td>[0..]</td><td>Links a Shape to a class, establishing that all instances of that class are expected to have this shape.</td>
                        </tr>
                        <tr>
                            <td>sh:scopeShape</td><td>sh:Shape</td><td>[0..]</td><td>Links a Shape to other Shapes that the tested nodes need to fulfill before the constraints of the shape are evaluated.</td>
                        </tr>
                        <tr>
                            <td>sh:inverseProperty</td><td>sh:InversePropertyConstraint</td><td>[0..]</td><td>Declares that a given incoming reference property is relevant for matching resources.</td>
                        </tr>
                        <tr>
                            <td>sh:property</td><td>sh:PropertyConstraint</td><td>[0..]</td><td>Declares that a given property is relevant for matching resources.</td>
                        </tr>
                        <tr>
                            <td>sh:constraint</td><td>sh:Constraint</td><td>[0..]</td><td>Defines arbitrary constraints on the matching resources. Use sh:property for structural property declarations.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:ShapeClass</h3>
                    <p class="shacldoc-comment">The metaclass for classes that are also shapes.</p>
                    <p>
                        <b>Type: </b>rdfs:Class</p>
                </section>
            </section>
            <section>
                <h3>Constraint Classes</h3>
                <section>
                    <h3>sh:Constraint</h3>
                    <p class="shacldoc-comment">An abstract superclass of constraints. Constraints are either template calls or "native" constraints with an executable body.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:scopeShape</td><td>sh:Shape</td><td>[0..]</td><td>Links a constraint to Shapes that the tested nodes need to fulfill before the constraint is evaluated.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:NativeConstraint</h3>
                    <p class="shacldoc-comment">A constraint that has a native executable body attached with it.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:sparqlEntailment</td><td></td><td>[0..1]</td><td>The SPARQL entailment required to execute the SPARQL query.</td>
                        </tr>
                        <tr>
                            <td>sh:severity</td><td>sh:ResultClass</td><td>[0..1]</td><td>Specifies the default rdf:type to produce for any constraint violation.</td>
                        </tr>
                        <tr>
                            <td>sh:sparql</td><td>xsd:string</td><td>[0..1]</td><td>The SPARQL SELECT query to execute.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[0..1]</td><td>Specifies the default sh:predicate to produce for any constraint violation.</td>
                        </tr>
                        <tr>
                            <td>sh:resultAnnotation</td><td>sh:ResultAnnotation</td><td>[0..]</td><td>Result annotations provide information about additional properties that the constructed constraint violations shall have.</td>
                        </tr>
                        <tr>
                            <td>sh:message</td><td>xsd:string</td><td>[0..]</td><td>Specifies the default sh:message(s) to produce for any constraint violation. May have multiple values for different languages.</td>
                        </tr>
                        <tr>
                            <td>rdfs:comment</td><td>xsd:string</td><td>[0..]</td><td>A human-readable explanation of this constraint. May have multiple values for different languages.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:TemplateConstraint</h3>
                    <p class="shacldoc-comment">A constraint that is instantiating a template.</p>
                    <p>
                        <b>Type: </b>sh:ConstraintTemplate</p>
                </section>
            </section>
            <section>
                <h2>Macro Classes</h2>
                <div class="shacldoc-tree">
                    <div class="shacldoc-tree-node">
                        <a href="#Macro">sh:Macro</a>
                        <div class="shacldoc-tree-node">
                            <a href="#Function">sh:Function</a>
                        </div>
                        <div class="shacldoc-tree-node">
                            <a href="#Template">sh:Template</a>
                            <div class="shacldoc-tree-node">
                                <a href="#ConstraintTemplate">sh:ConstraintTemplate</a>
                            </div>
                        </div>
                    </div>
                </div>
                <section>
                    <h3>sh:ConstraintTemplate</h3>
                    <p class="shacldoc-comment">A template backed by a SPARQL query that is used for constraint validation.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:resultAnnotation</td><td>sh:ResultAnnotation</td><td>[0..]</td><td>Result annotations provide information about additional properties that the constructed constraint violations shall have.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[0..1]</td><td>Specifies the default sh:predicate to produce for any constraint violation.</td>
                        </tr>
                        <tr>
                            <td>sh:message</td><td>xsd:string</td><td>[0..]</td><td>Specifies the default sh:message(s) to produce for any constraint violation. May have multiple values for different languages.</td>
                        </tr>
                        <tr>
                            <td>sh:severity</td><td>sh:ResultClass</td><td>[0..1]</td><td>Specifies the default rdf:type to produce for any constraint violation.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:Function</h3>
                    <p class="shacldoc-comment">A macro implementing a SPARQL function, backed by a SPARQL ASK or SELECT query.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:sparql</td><td>xsd:string</td><td>[0..1]</td><td>A SPARQL ASK or SELECT query that can reference the supplied arguments.</td>
                        </tr>
                        <tr>
                            <td>sh:cachable</td><td>xsd:boolean</td><td>[0..1]</td><td>True to indicate that this function will always return the same values for the same combination of arguments, regardless of the query graphs. Engines can use this information to cache and reuse previous function calls.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:Macro</h3>
                    <p class="shacldoc-comment">Abstract superclass of macro components of a SHACL library, especially Functions and Templates. Macros can take arguments, which are constraints that are different from PropertyConstraints in that they can only have at most one value.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:argument</td><td>sh:Argument</td><td>[0..]</td><td>Declares the argument(s) of this macro.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:Template</h3>
                    <p class="shacldoc-comment">A macro that acts as an abstraction of a (reusable) SPARQL query. The query can be parameterized by the supplied arguments.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:sparql</td><td>xsd:string</td><td>[0..1]</td><td>The SPARQL query to execute.</td>
                        </tr>
                        <tr>
                            <td>sh:labelTemplate</td><td>xsd:string</td><td>[0..]</td><td>Outlines how human-readable labels of instances of this template class shall be produced. The values must be strings that can contain {?argName} as placeholders for the actual values of the given argument. There may be multiple values, for different languages.</td>
                        </tr>
                    </table>
                </section>
            </section>
            <section>
                <h2>Results Vocabulary</h2>
                <div class="shacldoc-tree">
                    <div class="shacldoc-tree-node">
                        <a href="#Result">sh:Result</a>
                        <div class="shacldoc-tree-node">
                            <a href="#ConstraintViolation">sh:ConstraintViolation</a>
                            <div class="shacldoc-tree-node">
                                <a href="#Error">sh:Error</a>
                                <div class="shacldoc-tree-node">
                                    <a href="#FatalError">sh:FatalError</a>
                                </div>
                            </div>
                            <div class="shacldoc-tree-node">
                                <a href="#Warning">sh:Warning</a>
                            </div>
                        </div>
                        <div class="shacldoc-tree-node">
                            <a href="#Info">sh:Info</a>
                        </div>
                    </div>
                </div>
                <section>
                    <h3>sh:ConstraintViolation</h3>
                    <p class="shacldoc-comment">A validation result representing a constraint violation.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                </section>
                <section>
                    <h3>sh:Error</h3>
                    <p class="shacldoc-comment">A constraint violation indicating an error.</p>
                    <p>
                        <b>Type: </b>sh:ResultClass</p>
                </section>
                <section>
                    <h3>sh:FatalError</h3>
                    <p class="shacldoc-comment">An error that cannot be recovered and further evaluation may terminate immediately. Engines may decide to perform the validation of potentially fatal constraints first.</p>
                    <p>
                        <b>Type: </b>sh:ResultClass</p>
                </section>
                <section>
                    <h3>sh:Info</h3>
                    <p class="shacldoc-comment">An INFO-level validation result.</p>
                    <p>
                        <b>Type: </b>sh:ResultClass</p>
                </section>
                <section>
                    <h3>sh:Result</h3>
                    <p class="shacldoc-comment">Instances of subclasses of this class can be constructed during constraint validation, to represent a single validation result.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:object</td><td></td><td>[0..1]</td><td>The object of triples involved in this result.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[0..1]</td><td>The predicate of triples involved in this result.</td>
                        </tr>
                        <tr>
                            <td>sh:root</td><td>rdfs:Resource</td><td>[0..1]</td><td>The root resource of the result (often: the focus node).</td>
                        </tr>
                        <tr>
                            <td>sh:message</td><td>xsd:string</td><td>[0..]</td><td>A human-readable message explaining the cause of the result. Multiple values are possible assuming they have different languages.</td>
                        </tr>
                        <tr>
                            <td>sh:detail</td><td>sh:Result</td><td>[0..]</td><td>Can link a result with other results that provide more details. This is especially useful to describe violations against nested patterns or shapes.</td>
                        </tr>
                        <tr>
                            <td>sh:subject</td><td></td><td>[0..1]</td><td>The subject of triples involved in this result.</td>
                        </tr>
                        <tr>
                            <td>sh:source</td><td>sh:Constraint</td><td>[0..]</td><td>The Constraint that caused this. This property gets filled in automatically by the constraint validation engine.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:Warning</h3>
                    <p class="shacldoc-comment">A non-critical constraint violation indicating a warning.</p>
                    <p>
                        <b>Type: </b>sh:ResultClass</p>
                </section>
            </section>
            <section>
                <h3>Other Classes</h3>
                <section>
                    <h3>sh:Profile</h3>
                    <p class="shacldoc-comment">A profile is a collection of templates. Profiles can be used to group together templates with similar complexity. Tools can indicate that they support specific profiles only.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:member</td><td>sh:Template</td><td>[0..]</td><td></td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:ResultAnnotation</h3>
                    <p class="shacldoc-comment">Defines the rules to derive the values of a given annotation property as extra values for a constraint violation.</p>
                    <p>
                        <b>Type: </b>sh:ShapeClass</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Property</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:annotationVarName</td><td>xsd:string</td><td>[0..1]</td><td>The name of the SPARQL variable from the SELECT clause that shall be used for the values.</td>
                        </tr>
                        <tr>
                            <td>sh:annotationValue</td><td></td><td>[0..1]</td><td>The values of the annotation property.</td>
                        </tr>
                        <tr>
                            <td>sh:annotationProperty</td><td>rdf:Property</td><td>[1..1]</td><td>The annotation property that shall be set.</td>
                        </tr>
                    </table>
                </section>
            </section>
        </section>
        <section>
            <h2>Constraint Templates</h2>
            <section>
                <h2>Property Constraint Templates</h2>
                <section>
                    <h3>sh:AbstractAllowedValuesPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies the allowed values for a property by pointing to a List of nodes.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:allowedValues</td><td>rdf:List</td><td>[1..1]</td><td>The rdf:List containing the allowed values of the property.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object
		WHERE {
			?this ?predicate ?object .
			FILTER NOT EXISTS {
				GRAPH ?shapesGraph {
					?allowedValues (rdf:rest*)/rdf:first ?object .
				}
			}
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractCountPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint on the cardinality of the property using minCount and maxCount. By default, a property may have 0 to unlimited number of values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:maxCount</td><td>xsd:integer</td><td>[0..1]</td><td>The maximum number of values that the property must have. Defaults to unlimited.</td>
                        </tr>
                        <tr>
                            <td>sh:minCount</td><td>xsd:integer</td><td>[0..1]</td><td>The minimum number of values that the property must have. Defaults to 0.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?count ?minCount ?maxCount
		WHERE {
			BIND (sh:valueCount(?this, ?predicate) AS ?count) .
			FILTER ((?count &lt; ?minCount) || (bound(?maxCount) &amp;&amp; (?count &gt; ?maxCount))) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractDatatypeFacetPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Abstract base class for datatype-related constraints.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                </section>
                <section>
                    <h3>sh:AbstractDatatypePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that all values of the property must be literals of a certain datatype. This will accept strings with language tags instead of xsd:string.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:datatype</td><td>rdfs:Datatype</td><td>[1..1]</td><td>The datatype that all values of the property must have, based on the semantics defined by the function sh:hasDatatype.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?datatype
		WHERE {
			?this ?predicate ?object .
			FILTER (!sh:hasDatatype(?object, ?datatype)) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractHasValuePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies that the given property must have the specified value (it may also have others).</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:hasValue</td><td></td><td>[1..1]</td><td>The required value of the property.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?hasValue
		WHERE {
			FILTER NOT EXISTS { ?this ?predicate ?hasValue }
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractLengthPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies the exact length of literal values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:length</td><td>xsd:integer</td><td>[1..1]</td><td>The length permitted for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?length ?objectLength
		WHERE {
			?this ?predicate ?object .
			BIND (STRLEN(str(?object)) AS ?objectLength) .
			FILTER (?objectLength != ?length) .
		} 
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractMaxExclusivePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies an (exclusive) maximum value for literal values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:maxExclusive</td><td></td><td>[1..1]</td><td>The exclusive maximum value permitted for this property: ?value &lt; ?maxExclusive</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?maxExclusive
		WHERE {
			?this ?predicate ?object .
			FILTER (?object &gt;= ?maxExclusive) .
		} 
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractMaxInclusivePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies an (inclusive) maximum value for literal values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:maxInclusive</td><td></td><td>[1..1]</td><td>The inclusive maximum value permitted for this property: ?value &lt;= ?maxInclusive</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?maxInclusive
		WHERE {
			?this ?predicate ?object .
			FILTER (?object &gt; ?maxInclusive) .
		} 
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractMaxLengthPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies the max length of literal values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:maxLength</td><td>xsd:integer</td><td>[1..1]</td><td>The max length permitted for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?maxLength ?objectLength
		WHERE {
			?this ?predicate ?object .
			BIND (STRLEN(str(?object)) AS ?objectLength) .
			FILTER (?objectLength &gt; ?maxLength) .
		} 
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractMinExclusivePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies an (exclusive) minimum value for literal values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:minExclusive</td><td></td><td>[1..1]</td><td>The exclusive minimum value permitted for this property: ?value &gt; ?minInclusive</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?minExclusive
		WHERE {
			?this ?predicate ?object .
			FILTER (?object &lt;= ?minExclusive) .
		} 
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractMinInclusivePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies an (inclusive) minimum value for literal values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:minInclusive</td><td></td><td>[1..1]</td><td>The inclusive minimum value permitted for this property: ?value &gt;= ?minInclusive</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?minInclusive
		WHERE {
			?this ?predicate ?object .
			FILTER (?object &lt; ?minInclusive) .
		} 
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractMinLengthPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies the min length of literal values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:minLength</td><td>xsd:integer</td><td>[1..1]</td><td>The min length permitted for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?minLength ?objectLength
		WHERE {
			?this ?predicate ?object .
			BIND (STRLEN(str(?object)) AS ?objectLength) .
			FILTER (?objectLength &lt; ?minLength) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractNodeKindPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies the valid node kind of a property.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:nodeKind</td><td>sh:NodeKind</td><td>[1..1]</td><td>The node kind that all values of the property must be of.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?nodeKind
		WHERE {
			?this ?predicate ?object ;
			FILTER (!sh:hasNodeKind(?object, ?nodeKind)) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractPatternPropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Specifies a regular expression that all values of the property need to match.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:pattern</td><td>xsd:string</td><td>[1..1]</td><td>The (regular expression) pattern for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?pattern
		WHERE {
			?this ?predicate ?object .
			FILTER (!regex(str(?object), ?pattern)) .
		} 
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractValueShapePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that all values of the property must have a certain shape.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                        <tr>
                            <td>sh:valueShape</td><td>sh:Shape</td><td>[1..1]</td><td>The shape that the values must have.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?valueShape
		WHERE {
			?this ?predicate ?object .
			FILTER (!sh:hasShape(?object, ?valueShape, ?shapesGraph)) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractValueTypePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that all values of the property must be of a certain type. For resources this will accept instances of subclasses. Untyped blank nodes are allowed if a defaultValueType has been specified. For literals this will accept strings with language tags instead of xsd:string.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:defaultValueType</td><td>rdfs:Class</td><td>[0..1]</td><td>If specified then blank nodes that have no rdf:type pass this constraint. The type of those resources is assumed to be ?defaultValueType.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                        <tr>
                            <td>sh:valueType</td><td>rdfs:Class</td><td>[1..1]</td><td>The type that all values of the property must have, based on the semantics defined by the function sh:hasType.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?valueType
		WHERE {
			?this ?predicate ?object .
			FILTER (!sh:hasType(?object, ?valueType)) .
			FILTER (!bound(?defaultValueType) || !isBlank(?object) || EXISTS { ?object a ?anyType }) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:PropertyConstraint (Template)</h3>
                    <p class="shacldoc-comment">Declares the structural constraints for a property at the associated class. The supported arguments are inherited from the superclasses.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:allowedValues</td><td>rdf:List</td><td>[1..1]</td><td>The rdf:List containing the allowed values of the property.</td>
                        </tr>
                        <tr>
                            <td>sh:datatype</td><td>rdfs:Datatype</td><td>[1..1]</td><td>The datatype that all values of the property must have, based on the semantics defined by the function sh:hasDatatype.</td>
                        </tr>
                        <tr>
                            <td>sh:defaultValueType</td><td>rdfs:Class</td><td>[0..1]</td><td>If specified then blank nodes that have no rdf:type pass this constraint. The type of those resources is assumed to be ?defaultValueType.</td>
                        </tr>
                        <tr>
                            <td>sh:hasValue</td><td></td><td>[1..1]</td><td>The required value of the property.</td>
                        </tr>
                        <tr>
                            <td>sh:length</td><td>xsd:integer</td><td>[1..1]</td><td>The length permitted for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:maxCount</td><td>xsd:integer</td><td>[0..1]</td><td>The maximum number of values that the property must have. Defaults to unlimited.</td>
                        </tr>
                        <tr>
                            <td>sh:maxExclusive</td><td></td><td>[1..1]</td><td>The exclusive maximum value permitted for this property: ?value &lt; ?maxExclusive</td>
                        </tr>
                        <tr>
                            <td>sh:maxInclusive</td><td></td><td>[1..1]</td><td>The inclusive maximum value permitted for this property: ?value &lt;= ?maxInclusive</td>
                        </tr>
                        <tr>
                            <td>sh:maxLength</td><td>xsd:integer</td><td>[1..1]</td><td>The max length permitted for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:minCount</td><td>xsd:integer</td><td>[0..1]</td><td>The minimum number of values that the property must have. Defaults to 0.</td>
                        </tr>
                        <tr>
                            <td>sh:minExclusive</td><td></td><td>[1..1]</td><td>The exclusive minimum value permitted for this property: ?value &gt; ?minInclusive</td>
                        </tr>
                        <tr>
                            <td>sh:minInclusive</td><td></td><td>[1..1]</td><td>The inclusive minimum value permitted for this property: ?value &gt;= ?minInclusive</td>
                        </tr>
                        <tr>
                            <td>sh:minLength</td><td>xsd:integer</td><td>[1..1]</td><td>The min length permitted for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:nodeKind</td><td>sh:NodeKind</td><td>[1..1]</td><td>The node kind that all values of the property must be of.</td>
                        </tr>
                        <tr>
                            <td>sh:pattern</td><td>xsd:string</td><td>[1..1]</td><td>The (regular expression) pattern for values of this property.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                        <tr>
                            <td>sh:valueShape</td><td>sh:Shape</td><td>[1..1]</td><td>The shape that the values must have.</td>
                        </tr>
                        <tr>
                            <td>sh:valueType</td><td>rdfs:Class</td><td>[1..1]</td><td>The type that all values of the property must have, based on the semantics defined by the function sh:hasType.</td>
                        </tr>
                    </table>
                </section>
            </section>
            <section>
                <h2>Inverse Property Constraint Templates</h2>
                <section>
                    <h3>sh:AbstractCountInversePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint on the cardinality of an incoming property using minCount and maxCount. By default, an inverse property may have 0 to unlimited number of values.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:maxCount</td><td>xsd:integer</td><td>[0..1]</td><td>The maximum number of values that the inverse property must have. Defaults to unlimited.</td>
                        </tr>
                        <tr>
                            <td>sh:minCount</td><td>xsd:integer</td><td>[0..1]</td><td>The minimum number of values that the inverse property must have. Defaults to 0.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?object) ?predicate ?minCount ?maxCount ?count
		WHERE {
			BIND (sh:inverseValueCount(?this, ?predicate) AS ?count) .
			FILTER ((?count &lt; ?minCount) || (bound(?maxCount) &amp;&amp; (?count &gt; ?maxCount))) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractValueTypeInversePropertyConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that all incoming values of the property must be of a certain type. This will accept instances of subclasses..</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                        <tr>
                            <td>sh:valueType</td><td>rdfs:Class</td><td>[1..1]</td><td>The type that all values of the inverse property must have, based on the semantics defined by the function sh:hasType.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT (?this AS ?object) ?subject ?predicate ?valueType
		WHERE {
			?subject ?predicate ?this .
			FILTER (!sh:hasType(?subject, ?valueType)) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:InversePropertyConstraint (Template)</h3>
                    <p class="shacldoc-comment">Declares the structural constraints for an incoming property at the associated class. The supported arguments are inherited from the superclasses.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:maxCount</td><td>xsd:integer</td><td>[0..1]</td><td>The maximum number of values that the inverse property must have. Defaults to unlimited.</td>
                        </tr>
                        <tr>
                            <td>sh:minCount</td><td>xsd:integer</td><td>[0..1]</td><td>The minimum number of values that the inverse property must have. Defaults to 0.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                        <tr>
                            <td>sh:valueType</td><td>rdfs:Class</td><td>[1..1]</td><td>The type that all values of the inverse property must have, based on the semantics defined by the function sh:hasType.</td>
                        </tr>
                    </table>
                </section>
            </section>
            <section>
                <h2>Argument Constraint Templates</h2>
                <section>
                    <h3>sh:AbstractArgumentDatatypeConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that the value of an argument must be a literal of a certain datatype. This will accept strings with language tags instead of xsd:string.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:datatype</td><td>rdfs:Datatype</td><td>[1..1]</td><td>The datatype that all values of the property must have.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?datatype
		WHERE {
			?this ?predicate ?object .
			FILTER (!sh:hasDatatype(?object, ?datatype)) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractArgumentMaxCountConstraint (Abstract Template)</h3>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate
		WHERE {
			FILTER EXISTS {
				?this ?predicate ?value1 .
				?this ?predicate ?value2 .
				FILTER (?value1 != ?value2) .
			}
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractArgumentValueTypeConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that the value of an argument must be of a certain type. For resources this will accept instances of subclasses. For literals this will accept strings with language tags instead of xsd:string.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                        <tr>
                            <td>sh:valueType</td><td>rdfs:Class</td><td>[1..1]</td><td>The type that all values of the property must have, based on the semantics defined by the function sh:hasType.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object ?valueType
		WHERE {
			?this ?predicate ?object .
			FILTER (!sh:hasType(?object, ?valueType)) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:AbstractOptionalArgumentConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that a non-optional argument must have a value, similar to minCount = 1, unless it has been declared optional, or a sh:defaultValue exists.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:defaultValue</td><td></td><td>[0..1]</td><td>The default value of this argument, to be used if no other value has been specified.</td>
                        </tr>
                        <tr>
                            <td>sh:optional</td><td>xsd:boolean</td><td>[1..1]</td><td>True to indicate that the property does not require a value. By default, the value is required.</td>
                        </tr>
                        <tr>
                            <td>sh:optionalWhenInherited</td><td>xsd:boolean</td><td>[1..1]</td><td>True to indicate that the property does not require a value when used by a subclass template. If set to true, then instances of subclasses do not need to fill in all required arguments - incomplete templates will simply not be executed. By default, the value is required.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate
		WHERE {
			FILTER (!bound(?defaultValue) &amp;&amp; !?optional &amp;&amp; !?optionalWhenInherited &amp;&amp; NOT EXISTS { ?this ?predicate ?any }) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:Argument (Template)</h3>
                    <p class="shacldoc-comment">Declares an argument that gets mapped to a variable in the parameterized SPARQL query.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:datatype</td><td>rdfs:Datatype</td><td>[1..1]</td><td>The datatype that all values of the property must have.</td>
                        </tr>
                        <tr>
                            <td>sh:defaultValue</td><td></td><td>[0..1]</td><td>The default value of this argument, to be used if no other value has been specified.</td>
                        </tr>
                        <tr>
                            <td>sh:optional</td><td>xsd:boolean</td><td>[1..1]</td><td>True to indicate that the property does not require a value. By default, the value is required.</td>
                        </tr>
                        <tr>
                            <td>sh:optionalWhenInherited</td><td>xsd:boolean</td><td>[1..1]</td><td>True to indicate that the property does not require a value when used by a subclass template. If set to true, then instances of subclasses do not need to fill in all required arguments - incomplete templates will simply not be executed. By default, the value is required.</td>
                        </tr>
                        <tr>
                            <td>sh:predicate</td><td>rdf:Property</td><td>[1..1]</td><td>The Property being constrained.</td>
                        </tr>
                        <tr>
                            <td>sh:valueType</td><td>rdfs:Class</td><td>[1..1]</td><td>The type that all values of the property must have, based on the semantics defined by the function sh:hasType.</td>
                        </tr>
                    </table>
                </section>
            </section>
            <section>
                <h2>Other Constraint Templates</h2>
                <section>
                    <h3>sh:AndConstraint (Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that all of the provided shapes must be valid for the focus resource.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:shapes</td><td>rdf:List</td><td>[1..1]</td><td>A list of shapes that will be validated.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT *
		WHERE {
			FILTER EXISTS {
				GRAPH ?shapesGraph {
					?shapes rdf:rest*/rdf:first ?shape .
				}
				FILTER (!sh:hasShape(?this, ?shape, ?shapesGraph)) .
			}
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:ClosedShapeConstraint (Template)</h3>
                    <p class="shacldoc-comment">Triggers an error for each triple of the focus node that has a predicate that is not explicitly enumerated using sh:property in the surrounding shape.</p>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT ?this (?this AS ?subject) ?predicate ?object
		WHERE {
			?this ?predicate ?object .
			FILTER (?predicate != rdf:type &amp;&amp; ?predicate != sh:nodeShape) .
			FILTER NOT EXISTS {
				GRAPH ?shapesGraph {
					?currentShape sh:property/sh:predicate ?predicate .
				}
			}
		}	
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:NotConstraint (Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that the focus node must not have a given shape, essentially negating the conditions represented by the shape.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:shape</td><td>sh:Shape</td><td>[1..1]</td><td>The shape to negate.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT *
		WHERE {
			FILTER (sh:hasShape(?this, ?shape, ?shapesGraph)) .
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:OrConstraint (Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that at least one of several provided shapes must be valid for the focus resource.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:shapes</td><td>rdf:List</td><td>[1..1]</td><td>A list of shapes that will be validated.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT *
		WHERE {
			FILTER NOT EXISTS {
				GRAPH ?shapesGraph {
					?shapes rdf:rest*/rdf:first ?shape .
				}
				FILTER sh:hasShape(?this, ?shape, ?shapesGraph) .
			}
		}
		</pre>
                    </div>
                </section>
                <section>
                    <h3>sh:TemplateConstraint (Abstract Template)</h3>
                    <p class="shacldoc-comment">A constraint that is instantiating a template.</p>
                </section>
                <section>
                    <h3>sh:XorConstraint (Template)</h3>
                    <p class="shacldoc-comment">Enforces a constraint that exactly one of multiple provided shapes must be valid for the focus resource.</p>
                    <table class="shacldoc-properties-table">
                        <tr>
                            <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                        </tr>
                        <tr>
                            <td>sh:shapes</td><td>rdf:List</td><td>[1..1]</td><td>A list of shapes that will be validated.</td>
                        </tr>
                    </table>
                    <div class="shacldoc-def shacldoc-def-sparql">
                        <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                        <pre class="shacldoc-def-sparql-body">
		SELECT *
		WHERE {
			FILTER (sh:validShapeCount(?this, ?shapes, ?shapesGraph) != 1) .
		}
		</pre>
                    </div>
                </section>
            </section>
        </section>
        <section>
            <h2>Functions</h2>
            <section>
                <h3>sh:Functions (Abstract Function)</h3>
                <p class="shacldoc-comment">The recommended abstract superclass for all functions, so that they are grouped together under a common root in class trees etc.</p>
                <p>
                    <b>Return type:</b><span>&nbsp;</span>
                </p>
            </section>
            <section>
                <h3>sh:hasDatatype (Function)</h3>
                <p class="shacldoc-comment">Checks whether a given node (?arg1) is a literal with a given datatype (?arg2). If the datatype is xsd:string, then the function will also accept literals with a language tag.</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td></td><td>[1..1]</td><td>The node to check the datatype of.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>rdfs:Datatype</td><td>[1..1]</td><td>The datatype that the node must have.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;xsd:boolean</span>
                </p>
                <div class="shacldoc-def shacldoc-def-sparql">
                    <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                    <pre class="shacldoc-def-sparql-body">
		ASK {
			{
				FILTER isLiteral(?arg1) .
			} .
			BIND (datatype(?arg1) AS ?datatype) .
			FILTER ((?datatype = ?arg2) || (rdf:langString = ?datatype &amp;&amp; ?arg2 = xsd:string)) .
		}
		</pre>
                </div>
            </section>
            <section>
                <h3>sh:hasNodeKind (Function)</h3>
                <p class="shacldoc-comment">Checks whether a given node (?arg1) has a given sh:NodeKind (?arg2). For example, sh:hasNodeKind(42, sh:Literal) = true.</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td></td><td>[1..1]</td><td>The node to check the node kind of.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>sh:NodeKind</td><td>[1..1]</td><td>The node kind that the node must have.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;xsd:boolean</span>
                </p>
                <div class="shacldoc-def shacldoc-def-sparql">
                    <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                    <pre class="shacldoc-def-sparql-body">
		ASK {
			FILTER ((isIRI(?arg1) &amp;&amp; ?arg2 = sh:IRI) ||
				(isLiteral(?arg1) &amp;&amp; ?arg2 = sh:Literal) ||
				(isBlank(?arg1) &amp;&amp; ?arg2 = sh:BlankNode))
		}
		</pre>
                </div>
            </section>
            <section>
                <h3>sh:hasShape (Function)</h3>
                <p class="shacldoc-comment">Validates whether a given resource (?arg1) fulfills all error-level constraints defined for a given shape (?arg2). This creates a (possibly recursive) constraint validator.</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td>rdfs:Resource</td><td>[1..1]</td><td>The resource to validate.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>sh:Shape</td><td>[1..1]</td><td>The shape containing the constraints that need to be validated.</td>
                    </tr>
                    <tr>
                        <td>sh:arg3</td><td>sh:Graph</td><td>[1..1]</td><td>The graph containing the shape definitions.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;xsd:boolean</span>
                </p>
            </section>
            <section>
                <h3>sh:hasType (Function)</h3>
                <p class="shacldoc-comment">Checks whether a given node (?arg1) is an instance of a given class (?arg2) or its subclasses. If arg2 is rdf:Property then the function returns true if ?arg1 is an untyped IRI.</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td></td><td>[1..1]</td><td>The node to check the type of.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>rdfs:Class</td><td>[1..1]</td><td>The type that the node must have.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;xsd:boolean</span>
                </p>
                <div class="shacldoc-def shacldoc-def-sparql">
                    <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                    <pre class="shacldoc-def-sparql-body">
		ASK {
			{
				{
					FILTER (isIRI(?arg1) || isBlank(?arg1)) .
				} .
				?class (rdfs:subClassOf)* ?arg2 .
				?arg1 a ?class .
			}
			UNION
			{
				# Allow untyped resources for rdfs:Resource and rdf:Property
				FILTER ((isIRI(?arg1) || isBlank(?arg1)) &amp;&amp; (?arg2 = rdfs:Resource || ?arg2 = rdf:Property) &amp;&amp; NOT EXISTS { ?arg1 a ?any }) .
			}
			UNION
			{
				# Allow untyped blank nodes with rdf:first if expected type is rdf:List
				FILTER (?arg2 = rdf:List &amp;&amp; isBlank(?arg1) &amp;&amp; EXISTS { ?arg1 rdf:first ?any }) .
			}
		}
		</pre>
                </div>
            </section>
            <section>
                <h3>sh:inverseValueCount (Function)</h3>
                <p class="shacldoc-comment">Gets the number of values of a given property (?arg2) at a given object (?arg1). The result is the number of matches of (?subject, ?arg2, ?arg1).</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td>rdfs:Resource</td><td>[1..1]</td><td>The object resource.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>rdf:Property</td><td>[1..1]</td><td>The property to get the value count of.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;xsd:integer</span>
                </p>
                <div class="shacldoc-def shacldoc-def-sparql">
                    <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                    <pre class="shacldoc-def-sparql-body">
		SELECT ((COUNT(?subject)) AS ?result)
		WHERE {
			?subject ?arg2 ?arg1 .
		}
		</pre>
                </div>
            </section>
            <section>
                <h3>sh:propertyValue (Function)</h3>
                <p class="shacldoc-comment">Gets the 'first' value of a given property (?arg2) at a given subject (?arg1). The behavior is arbitrary if multiple values are present.</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td>rdfs:Resource</td><td>[1..1]</td><td>The subject resource.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>rdf:Property</td><td>[1..1]</td><td>The property to get the value of.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;</span>
                </p>
                <div class="shacldoc-def shacldoc-def-sparql">
                    <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                    <pre class="shacldoc-def-sparql-body">
		SELECT ?object
		WHERE {
			?arg1 ?arg2 ?object .
		}
		</pre>
                </div>
            </section>
            <section>
                <h3>sh:validShapeCount (Function)</h3>
                <p class="shacldoc-comment">Counts the number of shapes from a given rdf:List (?arg2) defined in a given shapes graph (?arg3) where a given focus node (?arg1) returns no error-level constraint violations.</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td>rdfs:Resource</td><td>[1..1]</td><td>The focus node.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>rdf:List</td><td>[1..1]</td><td>The list of shapes to walk through.</td>
                    </tr>
                    <tr>
                        <td>sh:arg3</td><td>rdfs:Resource</td><td>[1..1]</td><td>The current shapes graph.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;xsd:integer</span>
                </p>
                <div class="shacldoc-def shacldoc-def-sparql">
                    <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                    <pre class="shacldoc-def-sparql-body">
		SELECT (COUNT(*) AS ?result)
		WHERE {
			GRAPH ?arg3 {
				?arg2 rdf:rest*/rdf:first ?shape .
			}
			FILTER (sh:hasShape(?arg1, ?shape, ?arg3)) .
		}
		</pre>
                </div>
            </section>
            <section>
                <h3>sh:valueCount (Function)</h3>
                <p class="shacldoc-comment">Gets the number of values of a given property (?arg2) at a given subject (?arg1). The result is the number of matches of (?arg1, ?arg2, ?object).</p>
                <table class="shacldoc-properties-table">
                    <tr>
                        <th>Argument</th><th>Type</th><th>Count</th><th>Description</th>
                    </tr>
                    <tr>
                        <td>sh:arg1</td><td>rdfs:Resource</td><td>[1..1]</td><td>The subject resource.</td>
                    </tr>
                    <tr>
                        <td>sh:arg2</td><td>rdf:Property</td><td>[1..1]</td><td>The property to get the value count of.</td>
                    </tr>
                </table>
                <p>
                    <b>Return type:</b><span>&nbsp;xsd:integer</span>
                </p>
                <div class="shacldoc-def shacldoc-def-sparql">
                    <div class="shacldoc-def-header">SPARQL DEFINITION</div>
                    <pre class="shacldoc-def-sparql-body">
		SELECT ((COUNT(?object)) AS ?result)
		WHERE {
			?arg1 ?arg2 ?object .
		}
		</pre>
                </div>
            </section>
        </section>
    </body>
</html>
